[
  {
    "title": "The zero max",
    "body": "Return a version of the given array where each zero value in the array is replaced by the\n    largest odd value to the right of the zero in the array.\n    If there is no odd value to the right of the zero, leave the zero as a zero.",
    "example": "zeroMax([0, 5, 0, 3]) → [5, 5, 3, 3] \n zeroMax([0, 4, 0, 3]) → [3, 4, 3, 3] \n zeroMax([0, 1, 0]) → [1, 1, 0]",
    "level": "easy",
    "solution": {
      "content": "public int[] zeroMax(final int[] inputArray) {\n        int maxValue = Integer.MIN_VALUE;\n\n        int[] result = Arrays.copyOf(inputArray, inputArray.length);\n\n        Objects.requireNonNull(inputArray, \"Input array must not be null\");\n\n        if (inputArray.length < 2) {\n            return new int[0];\n        }\n\n        for (int i = result.length - 1; i >= 0; i--) {\n            if (result[i] % 2 != 0) {\n                maxValue = Math.max(maxValue, result[i]);\n            }\n\n            if (result[i] == 0 && maxValue != Integer.MIN_VALUE) {\n                result[i] = maxValue;\n            }\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "The Reverse integer",
    "body": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.",
    "example": "Input: x = 123, Output: 321; Input: x = -123, Output: -321; Input: x = 120, Output: 21",
    "level": "medium",
    "solution": {
      "content": "public Integer reverseNumbers(Integer number) {\n        var reverse = 0L;\n        var digit = 0;\n\n        while (number != 0) {\n            digit = number % 10;\n            reverse = reverse * 10 + digit;\n            number /= 10;\n        }\n\n        if (reverse > Integer.MAX_VALUE || reverse < Integer.MIN_VALUE) {\n            return 0;\n        }\n\n        return (int) reverse;\n    }"
    }
  },
  {
    "title": "The two sum",
    "body": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n You may assume that each input would have exactly one solution, and you may not use the same element twice.\n You can return the answer in any order.",
    "example": "Input: nums = [2,7,11,15], target = 9, Output: [0,1], Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]; Input: nums = [3,2,4], target = 6, Output: [1,2]; Input: nums = [3,3], target = 6, Output: [0,1]",
    "level": "easy",
    "solution": {
      "content": "public int[] findTwoSum(final int[] inputArray, final int target) {\n        Objects.requireNonNull(inputArray, \"Input array must not be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"Input array must contain at least two elements\");\n        }\n\n        HashMap<Integer, Integer> lookup = new HashMap<>();\n\n        for (int i = 0; i < inputArray.length; i++) {\n            int complement = target - inputArray[i];\n            if (lookup.containsKey(complement)) {\n                return new int[]{lookup.get(complement), i};\n            }\n\n            lookup.put(inputArray[i], i);\n\n        }\n        throw new IllegalArgumentException(\"No two elements sum up to the target\");\n    }"
    }
  },
  {
    "title": "Palindrome Number",
    "body": "Given an integer x, return true if x is a \npalindrome\n, and false otherwise. Input: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.",
    "example": "Input: x = 121, Output: true, Explanation: 121 reads as 121 from left to right and from right to left; Input: x = -121, Output: false, Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.",
    "level": "easy",
    "solution": {
      "content": "public boolean checkPalindromeNumber(final int number) {\n        if (number < 0 || (number != 0 && number % 10 == 0)) {\n            return false;\n        }\n\n        int reversed = 0;\n        int n = number;\n\n        while (n != 0) {\n            int digit = n % 10;\n            reversed = reversed * 10 + digit;\n            n /= 10;\n        }\n\n        return reversed == number;\n    }"
    }
  },
  {
    "title": "Longest Common Prefix",
    "body": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\"",
    "example": "Input: strs = [\"flower\",\"flow\",\"flight\"], Output: \"fl\"; Input: strs = [\"dog\",\"racecar\",\"car\"], Output: \"\", Explanation: There is no common prefix among the input strings.",
    "level": "easy",
    "solution": {
      "content": "public String findLongestSubstringWithoutRepeatingCharacters(final String inputText) {\n        Objects.requireNonNull(inputText, \"The sentence cannot be null\");\n\n        final String trimmed = inputText.toLowerCase().trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        boolean hasLetter = trimmed.chars().anyMatch(Character::isAlphabetic);\n\n        if (!hasLetter) {\n            throw new IllegalArgumentException(\"The sentence contains no letters\");\n        }\n\n        final String[] inputStringArray = trimmed.split(\"\\\\s+\");\n\n        if (inputStringArray.length < 2) {\n            throw new IllegalArgumentException(\"The sentence must contain at least two words.\");\n        }\n\n        String prefix = inputStringArray[0];\n\n        for (String item : inputStringArray) {\n            while (item.indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty()) {\n                    return \"\";\n                }\n            }\n        }\n        return prefix;\n    }"
    }
  },
  {
    "title": "Valid Parentheses",
    "body": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. ",
    "example": "Input: s = \"()\", Output: true; Input: s = \"()[]{}\", Output: true; Input: s = \"(]\", Output: false",
    "level": "easy",
    "solution": {
      "content": "Objects.requireNonNull(text, \"The sentence cannot be null\");\n\n        String trimmed = text.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only white spaces\");\n        }\n\n        Deque<Character> deque = new ArrayDeque<>();\n\n        for (char symbol : trimmed.toCharArray()) {\n            switch (symbol) {\n                case '(', '{', '[' -> {\n                    deque.push(switch (symbol) {\n                        case '(' -> ')';\n                        case '{' -> '}';\n                        case '[' -> ']';\n                        default -> throw new IllegalStateException(\"Unexpected opening bracket: \" + symbol);\n                    });\n                }\n                case ')', '}', ']' -> {\n                    if (deque.isEmpty() || deque.pop() != symbol) {\n                        return false;\n                    }\n                }\n                default -> {\n                    // Skip non-bracket characters\n                }\n            }\n        }\n\n        return deque.isEmpty();\n    }"
    }
  },
  {
    "title": "Find the Index of the First Occurrence in a String",
    "body": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
    "example": "Input: haystack = \"sadbutsad\", needle = \"sad\", Output: 0, Explanation: \"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0; Input: haystack = \"leetcode\", needle = \"leeto\", Output: -1, Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1",
    "level": "easy"
  },
  {
    "title": "Search Insert Position",
    "body": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.",
    "example": "Input: nums = [1,3,5,6], target = 5, Output: 2; Input: nums = [1,3,5,6], target = 2, Output: 1; Input: nums = [1,3,5,6], target = 7, Output: 4",
    "level": "easy",
    "solution": {
      "content": "public static int binarySearch(int[] sortedArray, int target) {\n        int left = 0;\n        int right = sortedArray.length - 1;\n        int result = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (sortedArray[mid] == target) {\n                result = mid;\n                right = mid - 1;\n            } else if (sortedArray[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "Plus One",
    "body": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's. \n Increment the large integer by one and return the resulting array of digits.",
    "example": "Input: digits = [1,2,3], Output: [1,2,4], Explanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\n Thus, the result should be [1,2,4]; Input: digits = [4,3,2,1], Output: [4,3,2,2], Explanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\n Thus, the result should be [4,3,2,2]",
    "level": "easy",
    "solution": {
      "content": "public int[] plusOne(final int[] digits) {\n        Objects.requireNonNull(digits, \"The array cannot be null\");\n\n        for (int i = digits.length - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n\n        int[] result = new int[digits.length + 1];\n        result[0] = 1;\n        return result;\n    }"
    }
  },
  {
    "title": "Concatenate two arrays in Java",
    "body": "Concatenate two arrays  with the standard Java API",
    "example": "String[] strArray1 = {\"element 1\", \"element 2\", \"element 3\"}; String[] strArray2 = {\"element 4\", \"element 5\"}; result = String[] expectedStringArray = {\"element 1\", \"element 2\", \"element 3\", \"element 4\", \"element 5\"}; int[] intArray1 = { 0, 1, 2, 3 };\nint[] intArray2 = { 4, 5, 6, 7 };\nint[] expectedIntArray = { 0, 1, 2, 3, 4, 5, 6, 7 };",
    "level": "easy",
    "solution": {
      "content": "public static void additionOfArrays(final int[] firstArray, final int[] secondArray) {\n        IntStream\n                .concat(Arrays.stream(firstArray), Arrays.stream(secondArray))\n                .distinct()\n                .sorted()\n                .forEach(System.out::print);\n    }"
    }
  },
  {
    "title": "Count Character Frequencies",
    "body": "Write a method that takes a string and returns a Map<Character, Integer> representing the frequency of each character (ignore spaces and case sensitivity).",
    "example": "Input: \"Programming\"\nOutput: {r=2, o=1, g=2, a=1, m=2, i=1, n=1, p=1}",
    "level": "easy",
    "solution": {
      "content": "public Map<Character, Integer> countCharacterFrequencies(final String sentence) {\n        final Map<Character, Integer> frequencyMap = new HashMap<>();\n\n        Objects.requireNonNull(sentence, \"The sentence cannot be null\");\n\n        final String trimmed = sentence.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        boolean hasLetter = trimmed.chars().anyMatch(Character::isAlphabetic);\n\n        if (!hasLetter) {\n            throw new IllegalArgumentException(\"The sentence contains no letters\");\n        }\n\n        for (final char symbol : trimmed.toCharArray()) {\n            if (Character.isAlphabetic(symbol)) {\n                char c = Character.toLowerCase(symbol);\n                frequencyMap.merge(c, 1, Integer::sum);\n            }\n        }\n        return frequencyMap;\n    }"
    }
  },
  {
    "title": "Word Frequency Counter",
    "body": "Write a program that takes a block of text input (as a single String) and calculates how many times each word appears. Words should be treated as case-insensitive. The output should display each word along with its frequency in descending order.",
    "example": "Input: Hello word word and word \n, Output: {word=3, and=1, hello=1}",
    "level": "easy",
    "solution": {
      "content": "public Map<String, Integer> counterWordFrequency(final String inputWords) {\n        Objects.requireNonNull(inputWords, \"The sentence cannot be null\");\n\n        final Map<String, Integer> frequencyMap = new HashMap<>();\n\n        final String trimmed = inputWords.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        final boolean hasLetter = trimmed.chars().anyMatch(Character::isAlphabetic);\n\n        if (!hasLetter) {\n            throw new IllegalArgumentException(\"The sentence contains no letters\");\n        }\n\n        final String[] words = trimmed.split(\"\\\\s+\");\n\n        for (final String word : words) {\n            final String cleanWord = word.toLowerCase().replaceAll(\"[^a-z]\", \"\");\n\n            frequencyMap.merge(cleanWord, 1, Integer::sum);\n        }\n\n        return frequencyMap.entrySet().stream().sorted(Map.Entry.<String, Integer>comparingByValue().reversed())\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));\n    }"
    }
  },
  {
    "title": "Binary Search",
    "body": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.\n\n",
    "example": "Input: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4; Input: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1",
    "level": "easy",
    "solution": {
      "content": "public static int binarySearch(int[] sortedArray, int target) {\n        int left = 0;\n        int right = sortedArray.length - 1;\n        int result = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (sortedArray[mid] == target) {\n                result = mid;\n                right = mid - 1;\n            } else if (sortedArray[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "Check Bubble Sort",
    "body": "Take 10 numbers and shuffle them into a random order.  Your goal is to sort the numbers into ascending numerical order as shown below, using a bubble sort.\n",
    "example": "[7, 12, 9, 11, 3] => [3, 7, 9, 11, 12]",
    "level": "easy",
    "solution": {
      "content": "public int[] bubbleSort(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"The array should contain min 2 elements\");\n        }\n\n        boolean swaped = true;\n\n        final int length = inputArray.length;\n\n        for (int i = 0; i < length - 1 && swaped; i++) {\n            swaped = false;\n\n            for (int j = 0; j < length - i - 1; j++) {\n                if (inputArray[j] > inputArray[j + 1]) {\n                    int temp = inputArray[j];\n                    inputArray[j] = inputArray[j + 1];\n                    inputArray[j + 1] = temp;\n                    swaped = true;\n                }\n            }\n        }\n\n        return inputArray;\n    }"
    }
  },
  {
    "title": "Calculate Character",
    "body": "Count the number of occurrences of a char in a String in Java",
    "example": "test => {t-2, e-1, s-1}",
    "level": "easy",
    "solution": {
      "content": "public Map<Character, Long> countCharsStream(final String text) {\n        return text.chars()\n                .mapToObj(i -> (char) i)\n                .collect(Collectors.groupingBy(Function.identity(),\n                        Collectors.counting()));\n    }"
    }
  },
  {
    "title": "Compare Version Numbers",
    "body": "Given two version strings, version1 and version2, compare them. A version string consists of revisions separated by dots '.'. The value of the revision is its integer conversion ignoring leading zeros.\n\nTo compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0. \n Return the following:\n\nIf version1 < version2, return -1.\nIf version1 > version2, return 1.\nOtherwise, return 0.",
    "example": "Input: version1 = \"1.2\", version2 = \"1.10\"\n\nOutput: -1\n\nExplanation:\n\nversion1's second revision is \"2\" and version2's second revision is \"10\": 2 < 10, so version1 < version2.   Input: version1 = \"1.01\", version2 = \"1.001\"\n\nOutput: 0\n\nExplanation:\n\nIgnoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".  Input: version1 = \"1.0\", version2 = \"1.0.0.0\"\n\nOutput: 0\n\nExplanation:\n\nversion1 has less revisions, which means every missing revision are treated as \"0\".",
    "level": "easy",
    "solution": {
      "content": "public int compareVersions(final String version1, final String version2) {\n        Objects.requireNonNull(version1, \"Version1 cannot be null\");\n        Objects.requireNonNull(version2, \"Version2 cannot be null\");\n\n        if (version1.isEmpty() || version2.isEmpty()) {\n            throw new IllegalArgumentException(\"Version strings cannot be empty\");\n        }\n\n        final String[] v1Parts = version1.split(\"\\\\.\");\n        final String[] v2Parts = version2.split(\"\\\\.\");\n\n        final int maxLength = Math.max(v1Parts.length, v2Parts.length);\n\n        for (int i = 0; i < maxLength; i++) {\n            int v1 = i < v1Parts.length ? Integer.parseInt(v1Parts[i]) : 0;\n            int v2 = i < v2Parts.length ? Integer.parseInt(v2Parts[i]) : 0;\n\n            if (v1 != v2) {\n                return Integer.compare(v1, v2);\n            }\n        }\n\n        return 0;\n    }"
    }
  },
  {
    "title": "Duplicate elements array and remove",
    "body": "Find all duplicates elements in array and remove them. Return a new array",
    "example": "{1,1,2,2,3,4,5,6} => result = {1,2,3,4,5,6}",
    "level": "easy",
    "solution": {
      "content": "public Integer[] findDuplicatesAndRemove(final Integer[] inputArray) {\n        Objects.requireNonNull(inputArray, \"Input array must not be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"Input array must contain at least two elements\");\n        }\n\n        Set<Integer> uniqElements = new LinkedHashSet<>(Arrays.asList(inputArray));\n\n\n        return uniqElements.toArray(new Integer[0]);\n    }"
    }
  },
  {
    "title": "Factorial",
    "body": "Create a function for the finding the factorial",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public int factorial(final int number) {\n        if (number < 0) throw new IllegalArgumentException(\"Factorial is undefined for negative numbers\");\n        if (number >= 20)\n            throw new IllegalArgumentException(\"Factorial result overflows int. Use a smaller number or BigInteger.\");\n\n        return IntStream.rangeClosed(2, number).reduce(1, Math::multiplyExact);\n    }"
    }
  },
  {
    "title": "Fibonacci Series Generator",
    "body": "Create a Java method that prints the first n numbers of the Fibonacci sequence, where n is a positive integer parameter passed to the method.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public long getFibonacciNumber(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"The number must be non-negative\");\n        }\n\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n\n        long prev2 = 0;\n        long prev1 = 1;\n\n        for (int i = 2; i <= n; i++) {\n            long current = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = current;\n        }\n\n        return prev1;\n    }"
    }
  },
  {
    "title": "Find duplicates in array",
    "body": "Find all duplicates in array an return them in the a new array",
    "example": "{1,1,2,2,3} => result = {1,2}",
    "level": "easy",
    "solution": {
      "content": "public int[] findDuplicates(final int[] inputArray) {\n        Set<Integer> duplicates = new HashSet<>();\n        Set<Integer> actual = new HashSet<>();\n\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"The array cannot have less than two elements.\");\n        }\n\n        for (int item : inputArray) {\n            if (!actual.add(item)) {\n                duplicates.add(item);\n            }\n        }\n        return duplicates.stream().mapToInt(Integer::intValue).toArray();\n    }"
    }
  },
  {
    "title": "Find duplicates In arrays",
    "body": "Find all duplicates in arrays an return them in the a new array",
    "example": "array1 = {1,2,3,4}, array1 = {1,2,3,5} => result =  {1,2,3}",
    "level": "easy",
    "solution": {
      "content": "public int[] findDuplicatesInArrays(final Integer[] firstArray, final Integer[] secondArray) {\n        Objects.requireNonNull(firstArray, \"The firstArray cannot be null\");\n        Objects.requireNonNull(secondArray, \"The secondArray cannot be null\");\n\n        if (firstArray.length == 0 || secondArray.length == 0) {\n            throw new IllegalArgumentException(\"Neither input array can be empty\");\n        }\n\n        Set<Integer> actual = new HashSet<>(Arrays.asList(firstArray));\n        Set<Integer> duplicates = new HashSet<>();\n\n        for (int item : secondArray) {\n            if (actual.contains(item)) {\n                duplicates.add(item);\n            }\n        }\n\n        return duplicates.stream().mapToInt(Integer::intValue).toArray();\n    }"
    }
  },
  {
    "title": "Find sum of elements in array",
    "body": "Calculate all elements in the array and return a result",
    "example": "{1,2,3} => result = 6",
    "level": "easy",
    "solution": {
      "content": "public static int findNumberOfPair(final int[] inputNumber, final int sumElements) {\n        if (inputNumber.length < sumElements) {\n            return inputNumber.length;\n        }\n        int count = 0;\n        for (int i = 0; i < inputNumber.length; i++) {\n            for (int j = i + 1; j < inputNumber.length; j++) {\n                if ((inputNumber[i] + inputNumber[j]) == sumElements) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }"
    }
  },
  {
    "title": "FizzBuzz. Loop and Stream.",
    "body": "Given an integer n, return a string array answer (1-indexed) where: answer[i] == \"FizzBuzz\" if i is divisible by 3 and 5 \n, answer[i] == \"Fizz\" if i is divisible by 3 \n, answer[i] == \"Buzz\" if i is divisible by 5 \n, answer[i] == i (as a string) if none of the above conditions are true \n",
    "example": "Input: n = 3, Output: [\"1\",\"2\",\"Fizz\"] \n; Input: n = 5, Output: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n; Input: n = 15, Output: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n;",
    "level": "easy",
    "solution": {
      "content": "public static void getFizzBuzz() {\n        PrintStream printStream = System.out;\n        for (int i = 1; i < 100; i++) {\n            if (i % 15 == 0) {\n                printStream.println(\" Fizz Buzz \" + i);\n            } else if (i % 3 == 0) {\n                printStream.println(\" Fizz \" + i);\n            } else if (i % 5 == 0) {\n                printStream.println(\" Buzz \" + i);\n            } else {\n                printStream.println(\" \" + i);\n            }\n        }\n    } \n  private static void streamFizBuzz() {\n        IntStream.rangeClosed(1, 100)\n                .mapToObj(i -> i % 3 == 0 ? (i % 5 == 0 ? \"Fizz Buzz \" : \"Fizz \") : (i % 5 == 0 ? \"Buzz \" : i + \" \"))\n                .forEach(System.out::println);\n    }"
    }
  },
  {
    "title": "Flip array",
    "body": "Returns an array in flip order",
    "example": "{1,2,3,4} => {4,3,2,1}",
    "level": "easy",
    "solution": {
      "content": "public int[] flipArrayDeclarativeApproach(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"Input array must not be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"Input array must contain at least two elements\");\n        }\n\n\n        return IntStream.range(0, inputArray.length)\n                .map(i -> inputArray[inputArray.length - 1 - i])\n                .toArray();\n\n    }"
    }
  },
  {
    "title": "Length in array",
    "body": "Count a length array",
    "example": " {1,2,3,4}  result = 4",
    "level": "easy",
    "solution": {
      "content": " public static int countArrayLength(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n        \n        return inputArray.length;\n    }"
    }
  },
  {
    "title": "LuckyTicket. With arguments string and numeric",
    "body": "Bus ticket numbers consist of 6 decimal digits. It is considered lucky when the sum of the first three digits equals the sum of the last three digits. ",
    "example": "123321 = > is lucky, 123322 => is not lucky",
    "level": "easy",
    "solution": {
      "content": "public boolean isLuckyTicket1(final String text) {\n        Objects.requireNonNull(text, \"The sentence cannot be null\");\n\n        final String trimmed = text.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only space\");\n        }\n\n        if (trimmed.length() != 6 && !trimmed.matches(\"\\\\d{6}\")) {\n            throw new IllegalArgumentException(\"Ticket must contain exactly 6 digits\");\n        }\n\n        int firstSum = 0;\n\n        int secondSum = 0;\n\n        for (int i = 0; i < 3; i++) {\n            firstSum += Character.getNumericValue(text.charAt(i));\n            secondSum += Character.getNumericValue(text.charAt(i + 3));\n        }\n        return firstSum == secondSum;\n    }"
    }
  },
  {
    "title": "Matrix diagonal sum",
    "body": "Given a square matrix mat, return the sum of the matrix diagonals.\n\nOnly include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.",
    "example": "Input: mat = [[1,2,3],\n              [4,5,6],\n              [7,8,9]], Output: 25\nExplanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25; Input: mat = [[1,1,1,1],\n              [1,1,1,1],\n              [1,1,1,1],\n              [1,1,1,1]], Output: 8; Input: mat = [[5]], Output: 5",
    "level": "easy",
    "solution": {
      "content": "public int matrixDiagonalSum(final int[][] inputMatrixData) {\n        int result = 0;\n\n        Objects.requireNonNull(inputMatrixData, \"The matrix data cannot be null\");\n\n        for (int[] row : inputMatrixData) {\n            if (row.length != inputMatrixData.length) {\n                throw new IllegalArgumentException(\"Matrix must be square\");\n            }\n        }\n\n        for (int i = 0; i < inputMatrixData.length; i++) {\n            result += inputMatrixData[i][i];\n\n            if (i != inputMatrixData.length - 1 - i) {\n                result += inputMatrixData[i][inputMatrixData.length - 1 - i];\n            }\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Merge arrays",
    "body": "The merge two arrays",
    "example": "array1 = {1,2,3}, array2= {4,5,6}, result = {1,2,3,4,5,6}",
    "level": "easy",
    "solution": {
      "content": "public String[] mergeArrays(final String[] first, final String... second) {\n        Objects.requireNonNull(first, \"The first array cannot be null\");\n        Objects.requireNonNull(second, \"The second array cannot be null\");\n\n        List<String> mergedList = new ArrayList<>(first.length + second.length);\n\n        Collections.addAll(mergedList, first);\n        Collections.addAll(mergedList, second);\n        return mergedList.toArray(new String[0]);\n    }"
    }
  },
  {
    "title": "Find min and max values in array",
    "body": "Given an array of size N. The task is to find the maximum and the minimum element of the array using the minimum number of comparisons.",
    "example": "Input: arr[] = {3, 5, 4, 1, 9}\nOutput: Minimum element is: 1\n              Maximum element is: 9; Input: arr[] = {22, 14, 8, 17, 35, 3}\nOutput:  Minimum element is: 3\n              Maximum element is: 35",
    "level": "easy",
    "solution": {
      "content": "public static int[] findMinMax(int[] array) {\n        Objects.requireNonNull(array, \"An array must not be null\");\n\n        Integer min = null; \n        Integer max = null;\n        \n        for (Integer value : array) {\n            if (value == null) continue;\n            if (min == null || value < min) min = value;\n            if (max == null || value > max) max = value;\n        }\n\n        if (min == null || max == null) {\n            return new int[]{};\n        }\n\n        return new int[]{min, max};\n    }"
    }
  },
  {
    "title": "Find min and max values in list",
    "body": "Given a list of size N. The task is to find the maximum and the minimum element of the array using the minimum number of comparisons.",
    "example": "Input: List<Integer> = List.of(3, 5, 4, 1, 9)\nOutput: Minimum element is: 1\n              Maximum element is: 9; \n Input: List<Integer> = List.of(22, 14, 8, 17, 35, 3)\nOutput:  Maximum element is: 35 \n, Minimum element is: 3\n              Maximum element is: 35",
    "level": "easy",
    "solution": {
      "content": "public record MinMax(Integer min, Integer max) {}\n\npublic static MinMax findMinMax(List<Integer> list) {\n    Objects.requireNonNull(list, \"List must not be null\");\n\n    Integer min = null, max = null;\n    for (Integer val : list) {\n        if (val == null) continue;\n        if (min == null || val < min) min = val;\n        if (max == null || val > max) max = val;\n    }\n\n    if (min == null || max == null) {\n        throw new IllegalArgumentException(\"List contains only nulls or is empty\");\n    }\n\n    return new MinMax(min, max);\n}"
    }
  },
  {
    "title": "Missing Number",
    "body": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
    "example": "Example 1:\n\nInput: nums = [3,0,1]\n\nOutput: 2\n\nExplanation:\n\nn = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.; Example 2:\n\nInput: nums = [0,1]\n\nOutput: 2\n\nExplanation:\n\nn = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.Example 3:\n\nInput: nums = [9,6,4,2,3,5,7,0,1]\n\nOutput: 8\n\nExplanation:\n\nn = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.",
    "level": "easy",
    "solution": {
      "content": "public int[] missingNumber(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"An array cannot be null\");\n\n        List<Integer> missing = new ArrayList<>();\n\n        int[] array = Arrays.stream(inputArray).distinct().sorted().toArray();\n\n        for (int i = 0; i < array.length - 1; i++) {\n            int current = array[i];\n            int next = array[i + 1];\n            if (next - current > 1) {\n                for (int j = current + 1; j < next; j++) {\n                    missing.add(j);\n                }\n            }\n        }\n        return missing.stream().mapToInt(Integer::intValue).toArray();\n    }"
    }
  },
  {
    "title": "Move zeroes",
    "body": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.",
    "example": "Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]; Input: nums = [0]\nOutput: [0]",
    "level": "easy",
    "solution": {
      "content": "public int[] moveZeroes(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"The array must contain at least two elements.\");\n        }\n\n        int nonZeroPos = 0;\n        for (int i = 0; i < inputArray.length; i++) {\n            if (inputArray[i] != 0) {\n                inputArray[nonZeroPos++] = inputArray[i];\n            }\n        }\n\n        while (nonZeroPos < inputArray.length) {\n            inputArray[nonZeroPos++] = 0;\n        }\n\n        return inputArray;\n    }"
    }
  },
  {
    "title": "Find Number of Element. Line Method.",
    "body": "Need to find index element in the array",
    "example": "{10,20,30,40} => target = 30, result = 2, because this is a index of element 30",
    "level": "easy",
    "solution": {
      "content": "public static int binarySearch(int[] sortedArray, int target) {\n        int left = 0;\n        int right = sortedArray.length - 1;\n        int result = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (sortedArray[mid] == target) {\n                result = mid;\n                right = mid - 1;\n            } else if (sortedArray[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "ParseString. Full version",
    "body": "Parse the string and get all numbers from the string. Divide elements into two arrays. In the first array, only even numbers and in the second, only odd numbers. In the first array, sort by natural order, and second sort in reverse order. ",
    "example": "text = f1f10d3f4f5f9f0f6, result => {1,4,6,10}, {9,5,3}",
    "level": "easy",
    "solution": {
      "content": "public static void parseString(final String text) {\n        String[] newString = text.split(\"[^\\\\d]+\");\n\n        List<String> list = Arrays.stream(newString)\n                .filter(s -> !s.isEmpty())\n                .toList();\n\n        int[] numArr = new int[list.size()];\n\n        for (int i = 0; i < list.size(); i++) {\n            numArr[i] = Integer.parseInt(list.get(i));\n        }\n\n        int[] firstArray = new int[]{};\n        int[] secondArray = new int[]{};\n\n        for (int item : numArr) {\n            if (item % 2 == 0) {\n                int[] temp = new int[firstArray.length + 1];\n                System.arraycopy(firstArray, 0, temp, 0, firstArray.length);\n                temp[firstArray.length] = item;\n                firstArray = temp;\n            } else {\n                int[] temp = new int[secondArray.length + 1];\n                System.arraycopy(secondArray, 0, temp, 0, secondArray.length);\n                temp[secondArray.length] = item;\n                secondArray = temp;\n            }\n        }\n        naturalSort(firstArray);\n\n\n\n        reverseSort(secondArray);\n    }, private static void naturalSort(final int[] inputArray) {\n        for (int i = 0; i < inputArray.length; i++) {\n            int left = inputArray[i];\n            for (int j = i - 1; j >= 0; j--) {\n                int right = inputArray[j];\n                if (left < right) {\n                    inputArray[j + 1] = right;\n                    inputArray[j] = left;\n                }\n            }\n        }\n        for (int item : inputArray) {\n            System.out.print(\" \" + item);\n        }\n    }\n\n    private static void reverseSort(final int[] inputArray) {\n        for (int i = 0; i < inputArray.length - 1; i++) {\n            for (int j = i + 1; j < inputArray.length; j++) {\n                if (inputArray[i] < inputArray[j]) {\n                    int tempNumber = inputArray[i];\n                    inputArray[i] = inputArray[j];\n                    inputArray[j] = tempNumber;\n                }\n\n            }\n        }\n\n        for (int item : inputArray) {\n            System.out.print(\" \" + item);\n        }\n    }"
    }
  },
  {
    "title": "Valid Palindrome. The argument string and numeric",
    "body": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.",
    "example": "Input: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome. Input: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome. Input: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.",
    "level": "easy",
    "solution": {
      "content": "public static boolean isPoly(final String inputText) {\n        char[] newString = inputText\n                .replaceAll(\"^A-Za-z0-9]\", \"\")\n                .toLowerCase()\n                .toCharArray();\n\n        char[] reverseString = new char[newString.length];\n\n        for (int i = 0; i < newString.length; i++) {\n            reverseString[(newString.length - 1) - i] = newString[i];\n        }\n\n        return new String(reverseString).equalsIgnoreCase(inputText);\n    }    public boolean checkPalindromeNumber(final int number) {\n        if (number < 0 || (number != 0 && number % 10 == 0)) {\n            return false;\n        }\n\n        int reversed = 0;\n        int n = number;\n\n        while (n != 0) {\n            int digit = n % 10;\n            reversed = reversed * 10 + digit;\n            n /= 10;\n        }\n\n        return reversed == number;\n    }"
    }
  },
  {
    "title": "Quick Sort",
    "body": "Quicksort is a divide-and-conquer algorithm",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public static int[] quickSort(int[] inputNumber, int begin, int end) {\n        if (begin < end) {\n            int partitionIndex = partition(inputNumber, begin, end);\n\n            quickSort(inputNumber, begin, partitionIndex - 1);\n            quickSort(inputNumber, partitionIndex + 1, end);\n        }\n        return inputNumber;\n    }    private static int partition(int[] inputNumber, int begin, int end) {\n        int pivot = inputNumber[end];\n        int i = (begin - 1);\n\n        for (int j = begin; j < end; j++) {\n            if (inputNumber[j] <= pivot) {\n                i++;\n\n                int swapTemp = inputNumber[i];\n                inputNumber[i] = inputNumber[j];\n                inputNumber[j] = swapTemp;\n            }\n        }\n\n        int swapTemp = inputNumber[i + 1];\n        inputNumber[i + 1] = inputNumber[end];\n        inputNumber[end] = swapTemp;\n\n        return i + 1;\n    }"
    }
  },
  {
    "title": "Remove First Letter from ich word from list and sort",
    "body": "Remove the first character",
    "example": "{Tony, Anna, Tom}, result => {nna, ony, om}",
    "level": "easy",
    "solution": {
      "content": "public static List<String> removeFirstLetter(final List<String> names) {\n        return names.stream()\n                .map(name -> name.substring(1))\n                .sorted()\n                .toList();\n    }"
    }
  },
  {
    "title": "Reverse string",
    "body": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.",
    "example": "Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]; Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
    "level": "easy",
    "solution": {
      "content": "public static String reverseText(final String inputText) {\n        Objects.requireNonNull(inputText, \"The input text cannot be null\");\n\n        final String trimmed = inputText.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The input text contains only spaces\");\n        }\n\n        if (trimmed.length() < 2) {\n            throw new IllegalArgumentException(\"The input must contain at least two characters\");\n        }\n\n        final char[] inputArray = trimmed.toCharArray();\n        final char[] reversed = new char[inputArray.length];\n\n        for (int i = 0; i < inputArray.length; i++) {\n            reversed[inputArray.length - i - 1] = inputArray[i];\n        }\n\n        return new String(reversed);\n    }"
    }
  },
  {
    "title": "Selection Sort",
    "body": "Implement Selection Sort is a comparison-based sorting algorithm",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public static int[] selectionSorting(final int... inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"The array must contain at least two elements.\");\n        }\n\n        for (int i = 0; i < inputArray.length - 1; i++) {\n            int minimalValue = i;\n            for (int j = i + 1; j < inputArray.length; j++) {\n                if (inputArray[j] < inputArray[minimalValue]) {\n                    minimalValue = j;\n                }\n            }\n\n            if (minimalValue != i) {\n                final int temp = inputArray[minimalValue];\n                inputArray[minimalValue] = inputArray[i];\n                inputArray[i] = temp;\n            }\n        }\n\n        return Arrays.copyOf(inputArray, inputArray.length);\n    }"
    }
  },
  {
    "title": "Singleton",
    "body": "Implement a singleton pattern",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class Singleton {\n\n    private static volatile Singleton instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n\n        return instance;\n    }\n}"
    }
  },
  {
    "title": "Stack",
    "body": "Implement stack",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class Stack {\n    private final int[] stackArray;\n    private final int capacity;\n    private int top;\n\n    public Stack(int capacity) {\n        if (capacity <= 0) {\n            throw new IllegalArgumentException(\"The stack capacity must be greater than zero\");\n        }\n\n        this.capacity = capacity;\n\n        this.stackArray = new int[capacity];\n\n        this.top = -1;\n    }\n\n    public void push(int element) {\n        if (isFull()) {\n            throw new IllegalStateException(\"Stack is full\");\n        }\n        stackArray[++top] = element;\n    }\n\n    public int pop() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Stack is empty\");\n        }\n        return stackArray[top--];\n    }\n\n    public int peek() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Stack is empty\");\n        }\n        return stackArray[top];\n    }\n\n    public boolean isEmpty() {\n        return top == -1;\n    }\n\n    public boolean isFull() {\n        return top == capacity - 1;\n    }"
    }
  },
  {
    "title": "Queue",
    "body": "Implement queue",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class Queue {\n\n    private final int[] arr;\n    private int front;\n    private int rear;\n    private final int capacity;\n    private int count;\n\n\n    Queue(int size) {\n        arr = new int[size];\n        capacity = size;\n        front = 0;\n        rear = -1;\n        count = 0;\n    }\n\n    public void dequeue() {\n        if (isEmpty()) {\n            System.out.println(\"Underflow\\nProgram Terminated\");\n            System.exit(-1);\n        }\n\n        int x = arr[front];\n\n        System.out.println(\"Removing \" + x);\n\n        front = (front + 1) % capacity;\n        count--;\n\n    }\n\n    public void enqueue(int item) {\n        if (isFull()) {\n            System.out.println(\"Overflow\\nProgram Terminated\");\n            System.exit(-1);\n        }\n\n        System.out.println(\"Inserting \" + item);\n\n        rear = (rear + 1) % capacity;\n        arr[rear] = item;\n        count++;\n    }\n\n    public int peek() {\n        if (isEmpty()) {\n            System.out.println(\"Underflow\\nProgram Terminated\");\n            System.exit(-1);\n        }\n        return arr[front];\n    }\n\n    public int size() {\n        return count;\n    }\n\n    public boolean isEmpty() {\n        return (size() == 0);\n    }\n\n    public boolean isFull() {\n        return (size() == capacity);\n    }"
    }
  },
  {
    "title": "Remove one array from another array",
    "body": "Implement function for remove all the elements of the array1 from array2",
    "example": "elements in first array [100, 200, 300, 400, 500, 600]\nelements in second array [300, 500]\nfirst array after removing second array from first array\n[100, 200, 400, 600]",
    "level": "easy",
    "solution": {
      "content": "public static int[] subtractSecondArrayFromFirst(final int[] firstArray, final int... secondArray) {\n        List<Integer> firstList = new ArrayList<>(Arrays.stream(firstArray).boxed().toList());\n        List<Integer> secondList = Arrays.stream(secondArray).boxed().toList();\n\n        firstList.removeAll(secondList);\n\n        return firstList.stream().mapToInt(Integer::intValue).toArray();\n    }"
    }
  },
  {
    "title": "Find second min and max value in array",
    "body": "Given an array arr[] of size N, find the second max and second smallest element in an array.",
    "example": "nput: arr[] = {12, 13, 1, 10, 34, 1}; Output: 10 13",
    "level": "easy"
  },
  {
    "title": "Count words in String",
    "body": "Given a string, count the number of words in it. The words are separated by the following characters: space (' ') or new line ('\\n') or tab ('\\t') or a combination of these.",
    "example": "text = Hello world, result = 2",
    "level": "easy"
  },
  {
    "title": "Change the first word with last in String",
    "body": "Implement a function which change the first word with last in String",
    "example": "text = Hello world, result => world Hello",
    "level": "easy",
    "solution": {
      "content": "public String changeFirstAndLastWordsInSentence(final String text) {\n        Objects.requireNonNull(text, \"The sentence cannot be null\");\n\n        if (text.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence is empty or contains only whitespace.\");\n        }\n\n        String[] wordsArray = text.split(\"\\\\s+\");\n        if (wordsArray.length < 2) {\n            throw new IllegalArgumentException(\"The sentence must contain at least two words.\");\n        }\n\n        String firstItem = wordsArray[0];\n        wordsArray[0] = wordsArray[wordsArray.length - 1];\n        wordsArray[wordsArray.length - 1] = firstItem;\n\n        return String.join(\" \", wordsArray);\n    }"
    }
  },
  {
    "title": "Change the first element with last in Array",
    "body": "Implement a function which Change the first element with last in Array",
    "example": "[1,2,3,4], result => [4,2,3,1]",
    "level": "easy"
  },
  {
    "title": "Number of Armstrong",
    "body": "The k-digit number N is an Armstrong number if and only if the k-th power of each digit sums to N.\n\nGiven a positive integer N, return true if and only if it is an Armstrong number.",
    "example": "Input: 153\nOutput: true\nExplanation: \n153 is a 3-digit number, and 153 = 1^3 + 5^3 + 3^3; Input: 123\nOutput: false\nExplanation: \n123 is a 3-digit number, and 123 != 1^3 + 2^3 + 3^3 = 36.",
    "level": "easy",
    "solution": {
      "content": "public static boolean armstrongNumber(final int number) {\n        int temp = number;\n        int sum = 0;\n        int length = String.valueOf(number).length();\n\n        while (temp > 0) {\n            int digit = temp % 10;\n\n            sum += (int) Math.pow(digit, length);\n\n            temp /= 10;\n        }\n\n        return sum == number;\n    }"
    }
  },
  {
    "title": "Alternate capitalization",
    "body": "Given a string, capitalize the letters that occupy even indexes and odd indexes separately, and return as shown below. Index 0 will be considered even.",
    "example": "For example, capitalize(\"abcdef\") = ['AbCdEf', 'aBcDeF']. The input should be a lowercase string with no spaces)",
    "level": "easy",
    "solution": {
      "content": "public String[] capitalize(final String inputText) {\n        Objects.requireNonNull(inputText, \"The input cannot be null\");\n\n        final String trimmed = inputText.trim().toLowerCase();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The input contains only spaces\");\n        }\n\n        StringBuilder evenCaps = new StringBuilder();\n        StringBuilder oddCaps = new StringBuilder();\n\n        for (int i = 0; i < trimmed.length(); i++) {\n            char c = trimmed.charAt(i);\n            if (i % 2 == 0) {\n                evenCaps.append(Character.toUpperCase(c));\n                oddCaps.append(c);\n            } else {\n                evenCaps.append(c);\n                oddCaps.append(Character.toUpperCase(c));\n            }\n        }\n\n        return new String[]{evenCaps.toString(), oddCaps.toString()};\n    }"
    }
  },
  {
    "title": "Valid Anagram",
    "body": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "example": "Example 1:\n\nInput: s = \"anagram\", t = \"nagaram\"\n\nOutput: true; Input: s = \"rat\", t = \"car\"\n\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "public boolean isAnagram(final String first, final String second) {\n        Objects.requireNonNull(first, \"The first array cannot be null\");\n        Objects.requireNonNull(second, \"The second array cannot be null\");\n\n        char[] firstArray = first.trim().toLowerCase().toCharArray();\n        char[] secondArray = second.trim().toLowerCase().toCharArray();\n\n        if (firstArray.length != secondArray.length) {\n            return false;\n        }\n\n        Arrays.sort(firstArray);\n        Arrays.sort(secondArray);\n\n        return Arrays.equals(firstArray, secondArray);\n    }"
    }
  },
  {
    "title": "Add Binary",
    "body": "Given two binary strings a and b, return their sum as a binary string.",
    "example": "Example 1:\n\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"; Example 2:\n\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"",
    "level": "easy",
    "solution": {
      "content": "private static String addBinary(final String a, final String b) {\n        return Integer.toBinaryString(Integer.parseInt(a, 2) + Integer.parseInt(b, 2));\n    }"
    }
  },
  {
    "title": "3Sum",
    "body": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.",
    "example": "Input: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]], Input: nums = [0,1,1]\nOutput: [], Input: nums = [0,0,0]\nOutput: [[0,0,0]]",
    "level": "easy",
    "solution": {
      "content": "public List<List<Integer>> threeSum(int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"Input array cannot be null\");\n        List<List<Integer>> result = new ArrayList<>();\n\n        if (inputArray.length < 3) return result;\n\n        Arrays.sort(inputArray);\n\n        for (int i = 0; i < inputArray.length - 2; i++) {\n            if (i > 0 && inputArray[i] == inputArray[i - 1]) continue; // Skip duplicates for i\n\n            int left = i + 1;\n            int right = inputArray.length - 1;\n\n            while (left < right) {\n                int sum = inputArray[i] + inputArray[left] + inputArray[right];\n\n                if (sum == 0) {\n                    result.add(Arrays.asList(inputArray[i], inputArray[left], inputArray[right]));\n                    left++;\n                    right--;\n\n                    while (left < right && inputArray[left] == inputArray[left - 1]) left++;\n                    while (left < right && inputArray[right] == inputArray[right + 1]) right--;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "Warm days",
    "body": "Find the number of days when the temperature was higher or equal to a certain set temperature.",
    "example": "{25, 30, 20, 28, 22, 35, 18}, temp = 25, result = 3",
    "level": "easy",
    "solution": {
      "content": "private static int countWarmDays(int threshold, int[] data) {\n        int count = 0;\n        for (int datum : data) {\n            if (datum > threshold) {\n                count = count + 1;\n            }\n        }\n        return count;\n    }"
    }
  },
  {
    "title": "Find First Palindromic String in the Array",
    "body": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\n\nA string is palindromic if it reads the same forward and backward.",
    "example": "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first; Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
    "level": "easy",
    "solution": {
      "content": "public static String firstPalindromeInArray(final String[] words) {\n        for (String word : words) {\n            if (new StringBuilder(word).reverse().toString().equals(word)) {\n                return word;\n            }\n        }\n        return \"\";\n    }"
    }
  },
  {
    "title": "Zero max",
    "body": "Return a version of the given array where each zero value in the array is replaced by the\n    largest odd value to the right of the zero in the array.\n    If there is no odd value to the right of the zero, leave the zero as a zero.",
    "example": "zeroMax([0, 5, 0, 3]) → [5, 5, 3, 3]\n    zeroMax([0, 4, 0, 3]) → [3, 4, 3, 3]\n        zeroMax([0, 1, 0]) → [1, 1, 0]",
    "level": "easy",
    "solution": {
      "content": "public int[] zeroMax(final int[] inputArray) {\n        int maxValue = Integer.MIN_VALUE;\n\n        int[] result = Arrays.copyOf(inputArray, inputArray.length);\n\n        Objects.requireNonNull(inputArray, \"Input array must not be null\");\n\n        if (inputArray.length < 2) {\n            return new int[0];\n        }\n\n        for (int i = result.length - 1; i >= 0; i--) {\n            if (result[i] % 2 != 0) {\n                maxValue = Math.max(maxValue, result[i]);\n            }\n\n            if (result[i] == 0 && maxValue != Integer.MIN_VALUE) {\n                result[i] = maxValue;\n            }\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Double sort",
    "body": "Implement Double sorting, in the context of sorting algorithms, generally refers to sorting a list based on two criteria.",
    "example": "",
    "level": "easy"
  },
  {
    "title": "The decorator pattern",
    "body": "Implement Decorator is a structural design pattern",
    "example": "",
    "level": "easy"
  },
  {
    "title": "The builder pattern",
    "body": "Implement The builder pattern",
    "example": "",
    "level": "easy"
  },
  {
    "title": "The reverse integer",
    "body": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).",
    "example": "Input: x = 123\nOutput: 321, Input: x = -123\nOutput: -321, Input: x = 120\nOutput: 21",
    "level": "easy",
    "solution": {
      "content": "public Integer reverseNumbers(Integer number) {\n        var reverse = 0L;\n        var digit = 0;\n\n        while (number != 0) {\n            digit = number % 10;\n            reverse = reverse * 10 + digit;\n            number /= 10;\n        }\n\n        if (reverse > Integer.MAX_VALUE || reverse < Integer.MIN_VALUE) {\n            return 0;\n        }\n\n        return (int) reverse;\n    }"
    }
  },
  {
    "title": "Find Closest Number to Zero",
    "body": "Given an integer array nums of size n, return the number with the value closest to 0 in nums. If there are multiple answers, return the number with the largest value.",
    "example": "Input: nums = [-4,-2,1,4,8]\nOutput: 1, Input: nums = [2,-1,1]\nOutput: 1",
    "level": "easy",
    "solution": {
      "content": "public int findClosetNumberToZero(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length == 0) {\n            throw new IllegalArgumentException(\"The array should contain min 1 item\");\n        }\n\n        int result = inputArray[0];\n\n        for (int number : inputArray) {\n            int absNumber = Math.abs(number);\n            int absResult = Math.abs(result);\n\n            if (absNumber < absResult || (absNumber == absResult && number > result)) {\n                result = number;\n            }\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Counting Bits",
    "body": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.",
    "example": "Input: n = 2, Output: [0,1,1], Explanation:\n0 --> 0\n1 --> 1\n2 --> 10; Input: n = 5\nOutput: [0,1,1,2,1,2]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101",
    "level": "easy"
  },
  {
    "title": "Valid Boomerang",
    "body": "Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.\n\nA boomerang is a set of three points that are all distinct and not in a straight line.",
    "example": "Example 1:\n\nInput: points = [[1,1],[2,3],[3,2]]\nOutput: true; Example 2:\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: false",
    "level": "easy"
  },
  {
    "title": "Count Vowels in a String",
    "body": "Write a method that counts the number of vowels (a, e, i, o, u) in a given string. The method should ignore case.",
    "example": "text = test, result => 1",
    "level": "easy",
    "solution": {
      "content": "public class Exercise {\n    private static final Set<Character> VOWELS = Set.of('a', 'e', 'i', 'o', 'u');\n\n    public long countVowels(final String text) {\n        Objects.requireNonNull(text, \"The sentence cannot be null\");\n\n        final String normalizedText = text.toLowerCase().trim().replaceAll(\"[^a-z]\", \"\");\n\n        if (normalizedText.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces or no vowels\");\n        }\n\n        return normalizedText\n                .chars()\n                .mapToObj(c -> (char) c)\n                .filter(VOWELS::contains)\n                .count();\n    }\n}"
    }
  },
  {
    "title": "Basic Banking Application (Object-Oriented)",
    "body": "Create a simplified banking application. Define a BankAccount class with attributes like accountNumber, accountHolderName, and balance. The class should have methods for:\n 1. Depositing money.\n 2. Withdrawing money (ensure sufficient balance).\n 3. Displaying account details; Then, create a Bank class that manages multiple BankAccount objects (e.g., using a List or Map). The Bank class should provide methods to:\n 1. Create a new bank account.\n 2. Find an account by account number.\n 3. Perform deposits and withdrawals on specific accounts.\n 4. Display details of all accounts; Hint: This exercise emphasizes object-oriented principles.\n\n",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class BankAccount {\n    private static final Logger LOGGER = Logger.getLogger(BankAccount.class.getName());\n\n    private static final AtomicInteger lastID = new AtomicInteger(1);\n    private final int accountNumber;\n    private final String accountHolderName;\n    private BigDecimal balance;\n\n    public BankAccount(String accountHolderName) {\n        this.accountNumber = lastID.getAndIncrement();\n        this.accountHolderName = accountHolderName;\n        this.balance = BigDecimal.ZERO;\n    }\n\n    public BigDecimal getBalance() {\n        return balance;\n    }\n\n    public int getAccountNumber() {\n        return accountNumber;\n    }\n\n    public String getAccountHolderName() {\n        return accountHolderName;\n    }\n\n    public void depositMoney(final BigDecimal money) {\n        if (money == null || money.compareTo(BigDecimal.ZERO) <= 0) {\n            throw new IllegalArgumentException(\"Deposit amount must be positive.\");\n        }\n\n        LOGGER.log(Level.INFO, \"Account {0}: Current balance before deposit: {1}\",\n                new Object[]{accountNumber, getBalance()});\n\n        this.balance = this.balance.add(money);\n\n        LOGGER.log(Level.INFO, \"Account {0}: Current balance after deposit: {1}\",\n                new Object[]{accountNumber, getBalance()});\n    }\n\n    public void withdrawMoney(final BigDecimal money) {\n        if (money == null || money.compareTo(BigDecimal.ZERO) <= 0) {\n            throw new IllegalArgumentException(\"Withdrawal amount must be positive.\");\n        }\n\n        if (this.balance.compareTo(money) < 0) {\n            throw new IllegalArgumentException(\"The balance %.2f doesn't have another money\".formatted(getBalance()));\n        }\n\n        LOGGER.log(Level.INFO, \"Account {0}: Current balance before withdrawal: {1}\",\n                new Object[]{accountNumber, getBalance()});\n\n        this.balance = this.balance.subtract(money);\n\n        LOGGER.log(Level.INFO, \"Account {0}: Current balance after withdrawal: {1}\",\n                new Object[]{accountNumber, getBalance()});\n    }\n\n    @Override\n    public String toString() {\n        return \"Account ID = %d, Name = %s, Balance = %s\".formatted(this.accountNumber, this.accountHolderName, this.balance.toPlainString());\n    }\n}     public class Bank {\n    private static final Logger LOGGER = Logger.getLogger(Bank.class.getName());\n\n    private final String name;\n    private final Map<Integer, BankAccount> bankAccountList;\n\n    public Bank(String name) {\n        this.name = name;\n        this.bankAccountList = new HashMap<>();\n    }\n\n    public void createNewBankAccount(final BankAccount bankAccount) {\n        BankAccount bankAccountByNumber = findBankAccountByNumber(bankAccount.getAccountNumber());\n        if (bankAccountByNumber == null) {\n            this.bankAccountList.put(bankAccount.getAccountNumber(), bankAccount);\n            LOGGER.info(\"The new bank account created\");\n        }\n    }\n\n    public void addDeposit(final int accountNumber, final BigDecimal amount) {\n        BankAccount bankAccountByNumber = findBankAccountByNumber(accountNumber);\n        if (bankAccountByNumber != null) {\n            bankAccountByNumber.depositMoney(amount);\n        } else {\n            LOGGER.log(Level.INFO, \"Account not found: {0}\", accountNumber);\n            throw new IllegalArgumentException(\"Account not found: {0}\" + accountNumber);\n        }\n    }\n\n    public void addDraw(final int accountNumber, final BigDecimal amount) {\n        BankAccount bankAccountByNumber = findBankAccountByNumber(accountNumber);\n        if (bankAccountByNumber != null) {\n            bankAccountByNumber.withdrawMoney(amount);\n        } else {\n            LOGGER.log(Level.INFO, \"Account not found: {0}\", accountNumber);\n            throw new IllegalArgumentException(\"Account not found: {0}\" + accountNumber);\n        }\n    }\n\n    private BankAccount findBankAccountByNumber(final int accountNumber) {\n        return bankAccountList.get(accountNumber);\n    }\n\n    public Map<Integer, BankAccount> getBankAccountList() {\n        return bankAccountList;\n    }\n\n    @Override\n    public String toString() {\n        return \"The bank with name = %s, and with accounts = [%s]\".formatted(this.name, getBankAccountList());\n    }\n}"
    }
  },
  {
    "title": "Basic Calculator",
    "body": "Create a console-based Java application that acts as a simple calculator. It should prompt the user to enter two numbers and then choose an operation (addition, subtraction, multiplication, or division). After the user makes their selections, the program should perform the calculation and display the result. You should handle potential InputMismatchException for non-numeric input and ArithmeticException for division by zero.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class BasicCalculator {\n    private static final Scanner SCANNER = new Scanner(System.in);\n    private static final Logger LOGGER = Logger.getLogger(BasicCalculator.class.getName());\n\n    public static void main(String[] args) {\n        userInput();\n    }\n\n    private static void userInput() {\n        boolean keepLooping = true;\n\n        while (keepLooping) {\n            LOGGER.log(Level.INFO, \"Enter first and second numbers or 'Q' to quit:\");\n            String firstInput = SCANNER.next().trim();\n            if (firstInput.equalsIgnoreCase(\"q\")) {\n                LOGGER.log(Level.INFO, \"Exit\");\n                return;\n            }\n\n            String secondInput = SCANNER.next().trim();\n            if (secondInput.equalsIgnoreCase(\"q\")) {\n                LOGGER.log(Level.INFO, \"Exit\");\n                return;\n            }\n\n            int a = Integer.parseInt(firstInput);\n            int b = Integer.parseInt(secondInput);\n\n            SCANNER.nextLine();\n\n            System.out.println(\"Enter an operation(addition, subtraction, multiplication, division) or 'Q' to quit: \");\n            String operation = SCANNER.nextLine().trim().toLowerCase();\n            if (operation.equalsIgnoreCase(\"q\")) {\n                LOGGER.log(Level.INFO, \"Exit\");\n                return;\n            }\n\n            try {\n                int result = calculate(a, b, operation);\n                LOGGER.log(Level.INFO, \"The result: {0}\", result);\n            } catch (ArithmeticException | IllegalArgumentException e) {\n                LOGGER.log(Level.WARNING, \"Calculation error: {0}\", e.getMessage());\n            } catch (InputMismatchException e) {\n                LOGGER.log(Level.WARNING, \"Non-numeric input received.\");\n                SCANNER.nextLine();\n            }\n        }\n    }\n\n    public static int calculate(int a, int b, String operation) {\n        return switch (operation) {\n            case \"addition\" -> (a + b);\n            case \"subtraction\" -> (a - b);\n            case \"multiplication\" -> (a * b);\n            case \"division\" -> {\n                if (b == 0) {\n                    throw new ArithmeticException(\"Division by zero is not allowed.\");\n                }\n                yield (a / b);\n            }\n            default -> throw new IllegalArgumentException(\"Invalid operation: \" + operation);\n        };\n    }\n}"
    }
  },
  {
    "title": "Student Management System (Console-Based)",
    "body": "Develop a console application to manage student records. The application should allow users to: \n 1. Add a new student (with properties like ID, name, age, and a list of courses). \n 2. Display details of all students. \n 3. Find a student by ID and display their details. \n 4. Update a student's age or courses.\n 5. Delete a student by ID; \n Hint: Use a List (e.g., ArrayList) to store Student objects. Each Student should be a separate class with appropriate attributes and methods.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public interface StudentOperations {\n\n    boolean addStudent(final Student student);\n\n    boolean updateStudentAge(final int studentId, final int age);\n\n    boolean addStudentCourse(final int studentId, final Course course);\n\n    boolean deleteStudent(final int studentId);\n}\n, public class Student {\n\n    private static final Logger LOGGER = Logger.getLogger(Student.class.getName());\n\n    private static final AtomicInteger idCounter = new AtomicInteger(1);\n\n    private final int studentId;\n    private final String studentName;\n    private int studentAge;\n    private final List<Course> courses;\n\n    public Student(String studentName, int studentAge, List<Course> courses) {\n        this.studentId = idCounter.getAndIncrement();\n        this.studentName = studentName;\n        this.studentAge = studentAge;\n        this.courses = new ArrayList<>(courses);\n    }\n\n    public int getStudentId() {\n        return studentId;\n    }\n\n    public void setStudentAge(int studentAge) {\n        this.studentAge = studentAge;\n    }\n\n    public String getStudentName() {\n        return studentName;\n    }\n\n    public List<Course> getCourses() {\n        return List.copyOf(this.courses);\n    }\n\n    public boolean addCourse(final Course course) {\n        if (this.courses.contains(course)) {\n            LOGGER.warning(\"Course \" + course.name() + \" already exists for student \" + this.studentId);\n            return false;\n        }\n        this.courses.add(course);\n        LOGGER.info(\"Course \" + course.name() + \" added to student \" + this.studentId);\n\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student[id=%d, name=%s, age=%d, courses=%s]\".formatted(this.studentId, this.studentName, this.studentAge, this.courses);\n    }\n}, public class ManageStudentSystem implements StudentOperations {\n\n    private static final Logger LOGGER = Logger.getLogger(ManageStudentSystem.class.getName());\n\n    private String name;\n\n    private List<Student> studentList = new ArrayList<>();\n\n    public ManageStudentSystem(String name) {\n        this.name = name;\n    }\n\n    public void showAllStudents() {\n        this.studentList.forEach(student -> System.out.println(\"The student: \" + student));\n    }\n\n    public Student findStudent(final int studentId) {\n        if (studentId <= 0) {\n            throw new IllegalArgumentException(\"Student ID must be non-zero.\");\n        }\n\n        for (final Student student : studentList) {\n            if (student.getStudentId() == studentId) {\n                LOGGER.info(\"The student  \" + student.getStudentName() + \" found\");\n                return student;\n            }\n        }\n        LOGGER.info(\"The student is not found\");\n        return null;\n    }\n\n    @Override\n    public boolean addStudent(Student student) {\n        if (student.getStudentId() <= 0) {\n            throw new IllegalArgumentException(\"Student ID must be positive.\");\n        }\n\n        final Student existStudent = findStudent(student.getStudentId());\n        if (Objects.isNull(existStudent)) {\n            this.studentList.add(student);\n            LOGGER.info(\"Student added: \" + student.getStudentName());\n            return true;\n        }\n        LOGGER.warning(\"Attempted to add duplicate student ID: \" + student.getStudentId());\n        return false;\n    }\n\n    @Override\n    public boolean updateStudentAge(final int studentId, int age) {\n        if (studentId <= 0 || age <= 0) {\n            throw new IllegalArgumentException(\"Student ID or Age must be non-zero.\");\n        }\n        final Student existStudent = findStudent(studentId);\n        if (!Objects.isNull(existStudent)) {\n\n            existStudent.setStudentAge(age);\n            LOGGER.info(\"For Student: \" + existStudent.getStudentName() + \" the age was changed\");\n            return true;\n        }\n        LOGGER.warning(\"The student doesn't update\");\n        return false;\n    }\n\n    @Override\n    public boolean addStudentCourse(int studentId, final Course course) {\n        final Student existStudent = findStudent(studentId);\n        if (!Objects.isNull(existStudent)) {\n            existStudent.addCourse(course);\n            LOGGER.info(\"For Student: \" + existStudent.getStudentName() + \"the course was added\" + course);\n            return true;\n        }\n        LOGGER.warning(\"For Student didn't add the course\");\n        return false;\n    }\n\n\n    @Override\n    public boolean deleteStudent(final int studentId) {\n        if (studentId == 0) {\n            throw new IllegalArgumentException(\"Student ID must be non-zero.\");\n        }\n\n        final Student existStudent = findStudent(studentId);\n        if (!Objects.isNull(existStudent)) {\n            this.studentList.remove(existStudent);\n            LOGGER.info(\"The Student: \" + existStudent.getStudentName() + \" was delete\");\n            return true;\n        }\n        LOGGER.warning(\"The Student: wasn't delete\");\n        return false;\n    }\n}, record Course(String name) {\n\n    @Override\n    public String toString() {\n        return String.format(\"The course name  = %s\", this.name);\n    }\n}"
    }
  },
  {
    "title": "Simple Inventory Management",
    "body": "Design a small inventory management system for a store. The system should allow users to:\n 1. Add new products (with properties like product ID, name, price, and quantity in stock). \n 2. Display all products and their current stock. \n 3. Update the quantity of a specific product. \n  4. Search for a product by name or ID.\n 5. Remove a product from the inventory; Hint: Again, use a List or Map (e.g., HashMap) to store Product objects, where Product is a separate class. Consider how to handle duplicate product IDs.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public enum Category {\n\n    PRODUCE, DAIRY, CEREAL, MEAT, BEVERAGE;\n} public class InventoryManagement implements InventoryOperations {\n    private static final Logger LOGGER = Logger.getLogger(InventoryManagement.class.getName());\n\n    private final String name;\n\n    private final Map<Integer, Product> productStore = new HashMap<>();\n\n    public InventoryManagement(String name) {\n        this.name = name;\n    }\n\n    public void listInventory() {\n        this.productStore.values().forEach(System.out::println);\n    }\n\n    public List<Product> findProductByName(final String name) {\n        return this.productStore.values()\n                .stream()\n                .filter(product -> product.getName().equalsIgnoreCase(name))\n                .toList();\n    }\n\n    public Optional<Product> findProduct(final int productId) {\n        if (productId <= 0) {\n            throw new IllegalArgumentException(\"The product ID must be non-zero.\");\n        }\n\n        Product exist = this.productStore.getOrDefault(productId, null);\n        if (!Objects.isNull(exist)) {\n            LOGGER.info(\"The product  \" + productId + \" found\");\n            return Optional.of(exist);\n        }\n\n        LOGGER.info(\"The product is not found\");\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return this.productStore.entrySet().stream()\n                .map(entry -> String.format(\"%-15s : and goods  = %s%n\", entry.getKey(), entry.getValue()))\n                .collect(Collectors.joining(\"\\n\"));\n    }\n\n    @Override\n    public void addProduct(final Product product) {\n        if (this.productStore.containsKey(product.getId())) {\n            LOGGER.info(\"The product \" + product.getId() + \" already exists in inventory system\" + this.name);\n            return;\n        }\n\n        this.productStore.put(product.getId(), product);\n        LOGGER.info(\"The product \" + product.getId() + \" added to inventory system\" + this.name);\n    }\n\n    @Override\n    public boolean updateProduct(final int productId, final int quantity) {\n        final Optional<Product> existProduct = findProduct(productId);\n        if (!Objects.isNull(existProduct)) {\n            LOGGER.info(\"The product \" + productId + \" update sucess in inventory system\" + this.name);\n            existProduct.ifPresentOrElse(product -> product.setQuantity(quantity), existProduct::get);\n            return true;\n        }\n        LOGGER.info(\"The product \" + productId + \" wasn't found to inventory system\" + this.name);\n        return false;\n    }\n\n    @Override\n    public boolean deleteProduct(final int productId) {\n        final Optional<Product> existProduct = findProduct(productId);\n        if (!Objects.isNull(existProduct)) {\n            LOGGER.info(\"The product \" + productId + \" removed successfully from inventory system\" + this.name);\n            this.productStore.remove(productId);\n            return true;\n        }\n        LOGGER.info(\"The product \" + productId + \" is not found to inventory system\" + this.name);\n        return false;\n    }\n}   public interface InventoryOperations {\n\n    void addProduct(final Product product);\n\n    boolean updateProduct(final int productId, final int quantity);\n\n    boolean deleteProduct(final int productId);\n}   public class Product {\n    private static final AtomicInteger idCounter = new AtomicInteger(1);\n\n    private final int id;\n    private final String name;\n    private final BigDecimal price;\n    private volatile int quantity;\n    private final Category category;\n\n    public Product(String name, BigDecimal price, int quantity, Category category) {\n        this.category = category;\n        this.id = idCounter.getAndIncrement();\n        this.name = validateName(name);\n        this.price = validatePrice(price);\n        this.quantity = validateQuantity(quantity);\n    }\n\n    private String validateName(String name) {\n        if (name == null || name.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The name is empty or contains only whitespace.\");\n        }\n        return name.trim();\n    }\n\n    private BigDecimal validatePrice(BigDecimal price) {\n        if (price == null || price.compareTo(BigDecimal.ZERO) <= 0) {\n            throw new IllegalArgumentException(\"The price must be positive.\");\n        }\n        return price;\n    }\n\n    private int validateQuantity(int quantity) {\n        if (quantity <= 0) {\n            throw new IllegalArgumentException(\"The quantity must be positive.\");\n        }\n        return quantity;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getQuantity() {\n        return quantity;\n    }\n\n    public void setQuantity(int quantity) {\n        if (quantity <= 0) {\n            throw new IllegalArgumentException(\"The quantity must be positive.\");\n        }\n        this.quantity = quantity;\n    }\n\n    @Override\n    public String toString() {\n        return \"The product [id = %d,  name = %s, price = %.2f, quantity = %d and category = %s]%n\".formatted(this.id, this.name, this.price, this.quantity, this.category);\n    }\n}"
    }
  },
  {
    "title": "Text File Analyzer",
    "body": "Write a Java program that takes a text file as input and performs the following analyses: \n 1. Counts the total number of words in the file.\n 2. Counts the total number of lines in the file.\n 3. Counts the occurrences of each unique word (case-insensitive).\n 4. Finds the 5 most frequent words. Hint: The program should handle FileNotFoundException and other potential IOExceptions. You will need to use FileReader, BufferedReader, and potentially Scanner for file processing, along with data structures like Map for word counts.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class TextFileAnalyzer {\n    private static final Logger logger = Logger.getLogger(TextFileAnalyzer.class.getName());\n\n    private final Path filePath;\n\n    private String cachedContent;\n\n    public TextFileAnalyzer(String pathToFile) {\n        if (pathToFile == null || pathToFile.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"File path cannot be empty.\");\n        }\n\n        this.filePath = Path.of(pathToFile.trim());\n\n        if (!Files.exists(filePath)) {\n            throw new IllegalArgumentException(\"File does not exist at: \" + filePath);\n        }\n    }\n\n    private String readFileContent() {\n        if (cachedContent == null) {\n            try {\n                cachedContent = Files.readString(filePath, StandardCharsets.UTF_8);\n            } catch (IOException exception) {\n                logger.log(Level.WARNING, \"Error reading file: {0}\", exception.getMessage());\n                cachedContent = \"\";\n            }\n        }\n        return cachedContent;\n    }\n\n    public void countsTotalNumberWordsInFile() {\n        String[] words = readFileContent().toLowerCase().split(\"\\\\W+\");\n        logger.info(\"Total words:\" + words.length);\n    }\n\n    public void countsTotalNumberLinesInFile() {\n        try {\n            try (BufferedReader reader = Files.newBufferedReader(filePath)) {\n                long lines = reader.lines().count();\n                logger.info(\"Total lines:\" + lines);\n            }\n        } catch (IOException exception) {\n            logger.warning(\"Error reading lines\" + exception.getMessage());\n        }\n    }\n\n    public void countsOccurrencesUniqueWordInFile(final boolean top5) {\n        Map<String, Long> freq = Arrays.stream(readFileContent().split(\"\\\\W+\"))\n                .filter(words -> !words.isEmpty())\n                .map(String::toLowerCase)\n                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n\n        if (top5) {\n            freq\n                    .entrySet()\n                    .stream()\n                    .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))\n                    .limit(5)\n                    .forEach(e -> logger.info(e.getKey() + \" : \" + e.getValue()));\n        } else {\n            freq.forEach((key, value) -> logger.info(key + \":\" + value));\n        }\n    }\n}"
    }
  },
  {
    "title": "Check for Prime Number",
    "body": "Write a method that checks whether a given integer is a prime number. Return true if it is prime, otherwise return false.",
    "example": "2: The smallest prime number, and the only even prime number.\n3: Divisible only by 1 and 3.\n5: Divisible only by 1 and 5.\n7: Divisible only by 1 and 7.\n11: Divisible only by 1 and 11",
    "level": "easy",
    "solution": {
      "content": "public boolean checkPrimeNumber(final int number) {\n    if (number <= 1) return false;\n    if (number == 2) return true;\n\n    for (int i = 2; i <= Math.sqrt(number); i++) {\n        if (number % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}"
    }
  },
  {
    "title": "Sum of Digits",
    "body": "Write a method that takes a positive integer and returns the sum of its digits.",
    "example": "For example, 123 should return 6",
    "level": "easy",
    "solution": {
      "content": "public int sumOfDigits(final int number) {\n    int sum = 0;\n    int n = Math.abs(number);\n\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}"
    }
  },
  {
    "title": "Simple Calculator (Switch Case)",
    "body": "Implement a basic calculator that supports +, -, *, and /. The user provides two numbers and an operator, and the method returns the result.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public int createSimpleCalculator(final int a, final int b, final String operator) {\n    int result;\n\n    switch (operator.trim()) {\n        case \"+\" -> result = a + b;\n        case \"-\" -> result = a - b;\n        case \"*\" -> result = a * b;\n        case \"/\" -> {\n            if (b == 0) {\n                throw new ArithmeticException(\"Cannot divide by zero\");\n            }\n            result = a / b;\n        }\n        default -> throw new IllegalArgumentException(\"Unsupported operator: \" + operator);\n    }\n\n    return result;\n}"
    }
  },
  {
    "title": "Create a Person Class",
    "body": "Create a Person class with the fields name, age, and email. Add constructors, getters, setters, and a method to display the information.",
    "example": "Hint: Think about validation (input integrity), string formatting and immutability",
    "level": "easy",
    "solution": {
      "content": "public class Person {\n    private final String name;\n    private final int age;\n    private final String email;\n\n    public Person(String name, int age, String email) {\n        if (name.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The name cannot be null\");\n        }\n        this.name = name;\n\n        if (age < 0) throw new IllegalArgumentException(\"Age cannot be negative\");\n        this.age = age;\n\n        if (email.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The email cannot be null\");\n        }\n        this.email = email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"The person name is : %s, with age is : %d, and email =  %s\", this.name, this.age, this.email);\n    }\n}"
    }
  },
  {
    "title": "Greatest Common Divisor of Strings",
    "body": "For two strings s and t, we say \"t divides s\" if and only if s = t + t + t + ... + t + t (i.e., t is concatenated with itself one or more times).\n\nGiven two strings str1 and str2, return the largest string x such that x divides both str1 and str2.",
    "example": "Input: str1 = \"ABCABC\", str2 = \"ABC\"\nOutput: \"ABC\", Input: str1 = \"ABABAB\", str2 = \"ABAB\"\nOutput: \"AB\", Input: str1 = \"LEET\", str2 = \"CODE\"\nOutput: \"\"",
    "level": "easy",
    "solution": {
      "content": ""
    }
  },
  {
    "title": "Temperature Converter",
    "body": "Create a console application that converts temperatures between Celsius and Fahrenheit. The program should:\n 1. Prompt the user to enter a temperature value. \n 2. Prompt the user to specify the original unit (Celsius or Fahrenheit). \n 3. Perform the conversion using the appropriate formulas: \n  -> Celsius to Fahrenheit: F=C×9/5+32 \n -> Fahrenheit to Celsius: C=(F−32)×5/9 \n 4. Display the converted temperature in the new unit. \n 5. Allow the user to perform multiple conversions until they choose to exit.",
    "example": "Implement robust input validation to ensure numeric input and valid unit choices.",
    "level": "easy",
    "solution": {
      "content": "public class TemperatureConverter {\n\n    private static final Scanner SCANNER = new Scanner(System.in);\n    private static final Logger LOGGER = Logger.getLogger(TemperatureConverter.class.getName());\n\n    public static void main(String[] args) {\n        userInput();\n    }\n\n    private static void userInput() {\n        boolean keepLooping = true;\n\n        while (keepLooping) {\n            System.out.println(\"Enter a temperature number or 'Q' to quit:\");\n            String temperatureInput = SCANNER.next().trim();\n            if (temperatureInput.equalsIgnoreCase(\"q\")) {\n                LOGGER.log(Level.INFO, \"Exit\");\n                return;\n            }\n\n            double temperature;\n            try {\n                temperature = Double.parseDouble(temperatureInput);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid temperature input. Please enter a numeric value.\");\n                LOGGER.warning(\"Invalid temperature input: \" + temperatureInput);\n                continue;\n            }\n\n            SCANNER.nextLine();\n\n            System.out.println(\"Is the temperature in Celsius or Fahrenheit? (Type 'C' or 'F' or 'Q' to quit)\");\n            String operation = SCANNER.nextLine().trim().toLowerCase();\n            if (operation.equalsIgnoreCase(\"q\")) {\n                LOGGER.log(Level.INFO, \"User quit at temperature input\");\n                return;\n            }\n\n            try {\n                final double convertedTemperature = converter(temperature, operation);\n                String targetUnit = \"\";\n                if (operation.equals(\"celsius\") || operation.equalsIgnoreCase(\"c\")) {\n                    targetUnit = \"Fahrenheit\";\n                } else if (operation.equals(\"fahrenheit\") || operation.equalsIgnoreCase(\"f\")) {\n                    targetUnit = \"Celsius\";\n                } else {\n                    targetUnit = \"Unknown Unit\";\n                }\n                System.out.printf(\"The convertion temperature: %.3f to %s%n\".formatted(convertedTemperature, targetUnit));\n            } catch (ArithmeticException | IllegalArgumentException e) {\n                System.err.println(\"Error: Invalid conversion unit provided. Please choose 'Celsius' or 'Fahrenheit'.\");\n                LOGGER.log(Level.WARNING, \"Converter error: {0}\", e.getMessage());\n            }\n        }\n        SCANNER.nextLine();\n    }\n\n    public static double converter(final double temperature, final String operation) {\n        return switch (operation) {\n            case \"celsius\", \"c\" -> (temperature * 9.0 / 5.0) + 32.0;\n            case \"fahrenheit\", \"f\" -> (temperature - 32.0) * 5.0 / 9.0;\n            default -> throw new IllegalArgumentException(\"Invalid operation: \" + operation);\n        };\n    }\n}"
    }
  },
  {
    "title": "Simple Command-Line To-Do List",
    "body": "Create a basic command-line application that allows users to manage a to-do list. The application should support the following commands: \n add <task description>: Adds a new task to the list. \n list: Displays all tasks with their corresponding numbers. \n mark <task number>: Marks a task as completed. \n delete <task number>: Removes a task from the list. \n exit: Quits the application.",
    "example": "Use a List (e.g., ArrayList) to store String tasks. Consider how to handle invalid task numbers or commands.",
    "level": "easy",
    "solution": {
      "content": "public class Application {\n    private static final Logger LOGGER = Logger.getLogger(Application.class.getName());\n    private static final Scanner SCANNER = new Scanner(System.in);\n\n    public void runApplication() {\n        final TaskDAO taskDAO = new TaskDAO();\n        final TaskService taskService = new TaskService(taskDAO);\n\n        boolean keepLooping = true;\n\n        while (keepLooping) {\n            try {\n                displayMenu();\n                final String choice = SCANNER.next().trim().toLowerCase();\n                SCANNER.nextLine();\n                switch (choice) {\n                    case \"add\" -> {\n                        LOGGER.log(Level.INFO, \"The add method\");\n                        taskService.add();\n                    }\n                    case \"list\" -> {\n                        LOGGER.log(Level.INFO, \"The list method \");\n                        taskService.getAllTasks();\n                    }\n\n                    case \"mark\" -> {\n                        LOGGER.log(Level.INFO, \"The mark method\");\n                        taskService.markTask();\n                    }\n\n                    case \"delete\" -> {\n                        LOGGER.log(Level.INFO, \"The delete method \");\n                        taskService.delete();\n                    }\n                    case \"exit\" -> {\n                        LOGGER.log(Level.INFO, \"The exist method\");\n                        keepLooping = false;\n                    }\n                    default -> LOGGER.log(Level.INFO, \"{0} not a valid option ❌\", choice);\n                }\n            } catch (IllegalArgumentException | ArithmeticException exception) {\n                LOGGER.warning(exception.getMessage());\n            }\n        }\n    }\n\n    private void displayMenu() {\n        System.out.println(\"\"\"\n                Choose:\n                \n                add - Adds a new task to the list.\n                list - Displays all tasks with their corresponding numbers.\n                mark - Marks a task as completed.\n                delete  - Removes a task from the list.\n                exit - Exit\n                \"\"\");\n    }\n}   public interface IService {\n\n    boolean add();\n\n    void getAllTasks();\n\n    void markTask();\n\n    void delete();\n}   public class Task {\n    private static final AtomicInteger lastId = new AtomicInteger(1);\n\n    private final int id;\n    private final String title;\n    private final String description;\n    private final TaskPriority taskPriority;\n    private boolean isFinished;\n\n    public Task(String title, String description, TaskPriority taskPriority) {\n        this.id = lastId.getAndIncrement();\n        this.title = title;\n        this.description = description;\n        this.taskPriority = taskPriority;\n        this.isFinished = false;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setFinished(boolean finished) {\n        isFinished = finished;\n    }\n\n    @Override\n    public String toString() {\n        return \"[ID=%d] Title: %s | Description: %s | Priority: %s | Status: %s\".formatted(\n                id, title, description, taskPriority, isFinished ? \"Finished\" : \"Not Finished\");\n    }\n}  public class TaskDAO {\n    private static final Logger LOGGER = Logger.getLogger(TaskDAO.class.getName());\n\n    private final List<Task> taskList = new ArrayList<>();\n\n    public List<Task> getAllTasks() {\n        LOGGER.info(\"Get all tasks \" + TaskDAO.class.getName());\n        return taskList;\n    }\n\n    public void addTask(final Task task) {\n        if (Objects.isNull(task)) {\n            LOGGER.warning(\"Add the task issue\" + TaskDAO.class.getName());\n            throw new IllegalArgumentException(\"The task can't be null or empty\");\n        }\n        taskList.add(task);\n    }\n\n    public void removeTask(final Task task) {\n        if (Objects.isNull(task)) {\n            LOGGER.warning(\"remove task issue\" + TaskDAO.class.getName());\n            throw new IllegalArgumentException(\"The task can't be null or empty\");\n        }\n        taskList.remove(task);\n    }\n\n    public boolean findTaskByTitle(final String title) {\n        if (title.trim().isEmpty()) {\n            LOGGER.warning(\"find Task By Title issue\" + TaskDAO.class.getName());\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n        final var tasks = getAllTasks();\n        for (var task : tasks) {\n            if (task.getTitle().equalsIgnoreCase(title)) {\n                return true;\n            }\n        }\n        LOGGER.warning(\"find Task By Title issue\" + TaskDAO.class.getName());\n        return false;\n    }\n\n    public Optional<Task> findTaskByNumber(final int taskNUmber) {\n        if (taskNUmber <= 0) {\n            throw new IllegalArgumentException(\"The taskNumber must be non-zero.\");\n        }\n\n        return getAllTasks().stream().filter(task -> task.getId() == taskNUmber).findFirst();\n    }\n}  public enum TaskPriority {\n    MINOR(\"MINOR\"),\n    MAJOR(\"MAJOR\"),\n    CRITICAL(\"CRITICAL\");\n\n    private final String priority;\n\n    TaskPriority(String priority) {\n        this.priority = priority;\n    }\n\n    public String getPriority() {\n        return priority;\n    }\n\n    public static TaskPriority findByValue(String value) {\n        return Arrays.stream(values())\n                .filter(taskPriority -> taskPriority.getPriority().equalsIgnoreCase(value))\n                .findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\"The %s value is not in the list\".formatted(value)));\n\n    }\n}  public class TaskService implements IService {\n    private static final Logger LOGGER = Logger.getLogger(TaskService.class.getName());\n    private static final Scanner SCANNER = new Scanner(System.in);\n\n    private final TaskDAO taskDao;\n\n    public TaskService(TaskDAO taskDao) {\n        this.taskDao = taskDao;\n    }\n\n    @Override\n    public boolean add() {\n        System.out.println(\"Add title, description, and priority(minor, major or critical) via comma:\");\n        final String inputText = SCANNER.nextLine();\n        final String[] data = inputText.replaceAll(\" +\", \"\").split(\",\");\n        final String userTitle = data[0];\n        final String userDescription = data[1];\n        final String userPriority = data[2];\n\n        if (userTitle.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        if (userDescription.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        if (userPriority.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        if (this.taskDao.findTaskByTitle(userTitle)) {\n            System.out.printf(\"The task with title %s  = is exists in the list\".formatted(userTitle));\n            LOGGER.info(\"The task didn't find\");\n            return false;\n        }\n\n        Task newTask = new Task(userTitle, userDescription, TaskPriority.findByValue(userPriority.toUpperCase()));\n\n        this.taskDao.addTask(newTask);\n\n        LOGGER.info(\"The task was added\");\n\n        System.out.printf(\"The task %s was added%n\".formatted(newTask));\n\n        return true;\n    }\n\n    @Override\n    public void getAllTasks() {\n        LOGGER.info(\"Returns all tasks\");\n        if (this.taskDao.getAllTasks().isEmpty()) {\n            System.out.println(\"The list is emnty\");\n            return;\n        }\n        this.taskDao.getAllTasks().forEach(task -> System.out.println(\"The task:\" + task));\n    }\n\n    @Override\n    public void markTask() {\n        int taskNumber = 0;\n        System.out.println(\"Add a task number, please:\");\n        try {\n            taskNumber = Integer.parseInt(SCANNER.nextLine().trim());\n        } catch (InputMismatchException exception) {\n            System.out.println(\"Invalid number. Please enter a numeric task ID.\");\n            LOGGER.log(Level.WARNING, \"The issue {0}\", exception.getMessage());\n            LOGGER.log(Level.WARNING, \"The stack trace {0}\", exception.getStackTrace());\n            return;\n        }\n\n\n        int finalTaskNumber = taskNumber;\n\n        taskDao.findTaskByNumber(taskNumber).ifPresentOrElse(task -> {\n                    task.setFinished(true);\n                    System.out.println(\"The task was marked\");\n                },\n                () -> {\n                    LOGGER.warning(\"The task with ID = %s doesn't exist, The task wasn't marked %n\".formatted(finalTaskNumber));\n                    System.out.println(\"The task wasn't marked\");\n                });\n    }\n\n    @Override\n    public void delete() {\n        System.out.println(\"Add a task number, please:\");\n        int taskNumber = 0;\n        try {\n            taskNumber = SCANNER.nextInt();\n        } catch (InputMismatchException exception) {\n            System.out.println(\"Invalid number. Please enter a numeric task ID.\");\n            LOGGER.log(Level.WARNING, \"The issue {0}\", exception.getMessage());\n            LOGGER.log(Level.WARNING, \"The stack trace {0}\", exception.getStackTrace());\n        }\n\n        this.taskDao.findTaskByNumber(taskNumber).ifPresentOrElse(task -> {\n            taskDao.removeTask(task);\n            System.out.println();\n        }, () -> {\n            LOGGER.warning(\"The task wasn't deleted as it doesn't exist.\");\n            System.out.println(\"The task was deleted\");\n        });\n\n    }\n}"
    }
  },
  {
    "title": "Basic File Operations (Copy & Rename)",
    "body": "Write a Java program that allows a user to perform basic file operations. The program should: \n 1. Prompt the user for a source file path. \n 2. Prompt the user for a destination file path. \n 3. Implement a feature to copy the content of the source file to the destination file. \n 4. Implement a feature to rename the source file to a new name provided by the user (after copying, or as a separate operation).",
    "example": "Handle potential IOExceptions (e.g., file not found, permission denied) and provide informative messages to the user. Use java.io.File or java.nio.file.Path and Files for operations.",
    "level": "easy",
    "solution": {
      "content": "public interface IFileOperations {\n    void showFiles();\n\n    void readFile();\n\n    void copyFile();\n\n    void renameFile();\n\n    void deleteFile();\n}  public class FileOperationsService implements IFileOperations {\n    private static final Logger LOGGER = Logger.getLogger(FileOperationsService.class.getName());\n    private static final String BACK_TO_MENU_TEXT = \"Back to Main menu\";\n    private static final String NO_FILE_FOUND = \"No file found\";\n\n    private final Scanner scanner;\n\n    public FileOperationsService(Scanner scanner) {\n        this.scanner = scanner;\n    }\n\n    @Override\n    public void showFiles() {\n        System.out.println(\"Add the path for the read files in directory, please:\");\n        final String directory = this.scanner.nextLine();\n        try {\n            listFiles(Path.of(directory));\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"The issue message, in show file method is: \", exception);\n        }\n    }\n\n    @Override\n    public void readFile() {\n        System.out.println(\"Add the path for the read source file or type 'q' for back to the main menu, please:\");\n        final String pathToFile = this.scanner.nextLine().trim();\n\n        if (isQuitCommand(pathToFile)) {\n            return;\n        }\n\n        final Path path = Path.of(pathToFile);\n\n        if (!Files.exists(path)) {\n            System.out.println(NO_FILE_FOUND);\n            return;\n        }\n\n        try {\n            final String content = Files.readString(path);\n            System.out.println(content);\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"The issue message, in read file method is: \", exception);\n            System.out.printf(\"The file %s didn't read %n\".formatted(pathToFile));\n        }\n    }\n\n    @Override\n    public void copyFile() {\n        System.out.println(\"Add the path for the copy source file, and path to destination file. Or type 'q' for back to the main menu, please:\");\n        final String sourceFile = this.scanner.nextLine();\n        final String destinationFile = this.scanner.nextLine();\n\n        if (isQuitCommand(sourceFile)) {\n            return;\n        }\n        if (isQuitCommand(destinationFile)) {\n            return;\n        }\n\n        if (!Files.exists(Path.of(sourceFile))) {\n            System.out.println(NO_FILE_FOUND);\n            return;\n        }\n\n        try {\n            Files.copy(Path.of(sourceFile), Path.of(destinationFile), StandardCopyOption.REPLACE_EXISTING);\n            System.out.printf(\"The file %s, copied to destination file %s with content %n\".formatted(sourceFile, destinationFile));\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"The issue message, in copy file method is: \", exception);\n            System.out.printf(\"The file %s didn't copy %n\".formatted(sourceFile));\n        }\n    }\n\n    @Override\n    public void renameFile() {\n        System.out.println(\"Add the path for the rename file, and new file name. Or type 'q' for back to the main menu, please:\");\n        final String pathToFile = this.scanner.nextLine().trim();\n        final String newFileName = this.scanner.nextLine().trim();\n\n        if (isQuitCommand(pathToFile)) {\n            return;\n        }\n\n        if (isQuitCommand(newFileName)) {\n            return;\n        }\n\n        if (!Files.exists(Path.of(pathToFile))) {\n            System.out.println(NO_FILE_FOUND);\n            return;\n        }\n\n        try {\n            Files.move(Path.of(pathToFile), Paths.get(pathToFile).resolveSibling(newFileName));\n            System.out.printf(\"The file %s renamed successfully with new file name is %s%n\".formatted(pathToFile, newFileName));\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"The issue message, in rename file method is: \", exception);\n            System.out.printf(\"The file %s didn't rename %n\".formatted(pathToFile));\n        }\n    }\n\n    @Override\n    public void deleteFile() {\n        System.out.println(\"Add the path for the delete source file or type 'q' for back to the main menu, please:\");\n        final String pathToFile = this.scanner.nextLine();\n        final Path path = Path.of(pathToFile);\n\n        if (isQuitCommand(pathToFile)) {\n            return;\n        }\n\n        if (!Files.exists(path)) {\n            System.out.println(NO_FILE_FOUND);\n            return;\n        }\n\n        if (!Files.isDirectory(path)) {\n            System.out.println(\"It is not a directory\");\n        }\n\n        try {\n            Files.deleteIfExists(path);\n            System.out.println(\"File deleted successfully.\");\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"The issue message, in delete file method is:\", exception);\n            System.out.printf(\"The file %s was not found%n\".formatted(pathToFile));\n        }\n    }\n\n    private void listFiles(final Path directory) throws IOException {\n        if (!Files.isDirectory(directory)) {\n            throw new IllegalArgumentException(\"Provided path is not a directory or incorrect path: \" + directory);\n        }\n\n        try (Stream<Path> pathStream = Files.list(directory);) {\n            pathStream.filter(Files::isRegularFile)\n                    .map(path -> path.getFileName().toString())\n                    .forEach(file -> System.out.printf(\".... %s%n\".formatted(file)));\n        }\n    }\n\n    private static boolean isQuitCommand(String input) {\n        if (input.equalsIgnoreCase(\"q\")) {\n            LOGGER.log(Level.INFO, BACK_TO_MENU_TEXT);\n            return true;\n        }\n        return false;\n    }\n}   public class Main {\n    private static final Logger LOGGER = Logger.getLogger(Main.class.getName());\n    private static final Scanner SCANNER = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        runApplication();\n    }\n\n    public static void runApplication() {\n        final FileOperationsService operationsService = new FileOperationsService(SCANNER);\n        boolean keepLooping = true;\n\n        while (keepLooping) {\n            try {\n                displayMenu();\n                final String choice = SCANNER.next().trim().toLowerCase();\n                SCANNER.nextLine();\n\n                switch (choice) {\n                    case \"show\" -> {\n                        LOGGER.log(Level.INFO, \"The show method\");\n                        operationsService.showFiles();\n                    }\n\n                    case \"read\" -> {\n                        LOGGER.log(Level.INFO, \"The read method\");\n                        operationsService.readFile();\n                    }\n                    case \"copy\" -> {\n                        LOGGER.log(Level.INFO, \"The copy method \");\n                        operationsService.copyFile();\n                    }\n\n                    case \"rename\" -> {\n                        LOGGER.log(Level.INFO, \"The rename method\");\n                        operationsService.renameFile();\n                    }\n\n                    case \"delete\" -> {\n                        LOGGER.log(Level.INFO, \"The delete method \");\n                        operationsService.deleteFile();\n                    }\n                    case \"exit\" -> {\n                        LOGGER.log(Level.INFO, \"The exit method\");\n                        keepLooping = false;\n                    }\n                    default -> LOGGER.log(Level.INFO, \"{0} not a valid option ❌\", choice);\n                }\n            } catch (IllegalArgumentException | ArithmeticException exception) {\n                LOGGER.warning(exception.getMessage());\n            }\n        }\n    }\n\n    private static void displayMenu() {\n        System.out.println(\"\"\"\n                You need to write the name of the action:\n                \n                1\uFE0F⃣. show:     Show files in directory.\n                2\uFE0F⃣. read:     Read source file.\n                3\uFE0F⃣. copy:     Copy content of the source file to the destination file.\n                4\uFE0F⃣. rename:   Rename the source file to a new name provided by the use.\n                5\uFE0F⃣. delete:   Delete file.\n                6\uFE0F⃣. exit:     Exit\n                \n                \"\"\");\n    }\n}"
    }
  },
  {
    "title": "Basic E-commerce Shopping Cart",
    "body": "Design a console application that simulates a simple e-commerce shopping cart. The application should allow users to: \n 1. View available products (each product having an ID, name, price, and perhaps a category). \n 2. Add products to the cart by product ID and quantity. \n 3. View items in the cart with their quantities and subtotal for each. \n  4. Remove items from the cart by product ID. \n  5. Calculate the total cost of all items in the cart.",
    "example": "You'll need a Product class and a ShoppingCart class. The ShoppingCart should manage a collection of products (e.g., using a Map where the key is product ID and the value is the quantity, or a custom CartItem class).",
    "level": "easy",
    "solution": {
      "content": ""
    }
  },
  {
    "title": "Concurrent Web Scraper",
    "body": "Develop a Java application that concurrently scrapes data from a list of predefined URLs. For each URL, your application should download the HTML content and extract specific information, such as all links (<a> tags) and their href attributes.",
    "example": "Concurrency: Implement this using Java's Concurrency API. A good approach would be to use an ExecutorService to manage a pool of threads. Each thread should be a Callable that scrapes a single URL and returns the extracted links. \n Data Handling: The results from all threads should be collected into a single, thread-safe data structure (e.g., ConcurrentHashMap, CopyOnWriteArrayList). \n  Error Handling: The application must handle network-related issues gracefully, such as connection timeouts or IOExceptions. \n Implementation: Consider using a library like Jsoup to parse the HTML content, as it simplifies the process of traversing the DOM and extracting data.",
    "level": "medium",
    "solution": {
      "content": "public class Main {\n    private static final Logger logger = Logger.getLogger(Main.class.getName());\n\n    public static void main(String[] args) throws InterruptedException {\n        final ConcurrentHashMap<String, List<String>> results = new ConcurrentHashMap<>();\n\n        final List<String> stringList = new ArrayList<>(List.of(\n                \"https://www.google.com/\",\n                \"https://www.wikipedia.org/\"\n        ));\n\n        try (final ExecutorService executorService = Executors.newCachedThreadPool()) {\n            final List<Callable<Void>> tasks = stringList\n                    .stream().map(url -> (Callable<Void>) () -> {\n                        final List<String> links = scrapHtml(url);\n                        results.put(url, links);\n                        return null;\n                    }).toList();\n\n            executorService.invokeAll(tasks);\n\n            results.forEach((key, value) -> logger.log(Level.INFO, \" %s : %s\".formatted(key, value)));\n        }\n    }\n\n    private static List<String> scrapHtml(final String destinationUrl) throws IOException, InterruptedException {\n        if (!destinationUrl.startsWith(\"http\")) {\n            throw new IllegalArgumentException(\"The destination url, must contain URI shema\");\n        }\n\n        try (final HttpClient client = HttpClient.newBuilder().followRedirects(HttpClient.Redirect.ALWAYS).build()) {\n            final HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(destinationUrl))\n                    .build();\n\n            final HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n            final Document doc = Jsoup.parse(response.body());\n            final Elements links = doc.select(\"a\");\n            return links.stream()\n                    .map(link -> link.attr(\"abs:href\"))\n                    .filter(href -> !href.isEmpty())\n                    .toList();\n        }\n    }\n}"
    }
  },
  {
    "title": "The shortest path",
    "body": "A string consisting of the letters 'X', 'Y' and '0' is given.\nIt is necessary to find the shortest distance between the letters 'X' and 'y' to get the value 0 if 'X' or 'Y' are missing.",
    "example": "\"үү\" -> Ө\n\"XX\" -> Ө\n\"XY\" -> 1\n\"YOX\" -> 2\n\"000XOOYOXO\" -> 2\n\"000X0OY\" -> 2",
    "level": "medium"
  },
  {
    "title": "Binary Tree Right Side View",
    "body": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
    "example": "Input: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4];   Input: root = [1,null,3]\nOutput: [1,3];    Input: root = []\nOutput: []",
    "level": "medium"
  },
  {
    "title": "House Robber",
    "body": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "example": "Input: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4;   Input: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.",
    "level": "medium"
  },
  {
    "title": "Rotate Array",
    "body": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\n",
    "example": "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n; Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]",
    "level": "medium"
  },
  {
    "title": "Repeated DNA Sequences",
    "body": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\n\nFor example, \"ACGAATTCCG\" is a DNA sequence.\nWhen studying DNA, it is useful to identify repeated sequences within the DNA.\n\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.",
    "example": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]; Input: s = \"AAAAAAAAAAAAA\"\nOutput: [\"AAAAAAAAAA\"]",
    "level": "medium"
  },
  {
    "title": "Daily Temperatures",
    "body": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
    "example": "Input: temperatures = [73,74,75,71,69,72,76,73], Output: [1,1,4,2,1,1,0,0] \n Input: temperatures = [30,40,50,60], Output: [1,1,1,0] \n Input: temperatures = [30,60,90], Output: [1,1,0]",
    "level": "medium",
    "solution": {
      "content": "public static int[] dailyTemperatures(final int[] temps) {\n        Objects.requireNonNull(temps, \"The array cannot be null\");\n\n        int[] result = new int[temps.length];\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for (int i = 0; i < temps.length; i++) {\n\n            while (!stack.isEmpty() && temps[i] > temps[stack.peek()]) {\n                final int index = stack.pop();\n                result[index] = i - index;\n            }\n            stack.push(i);\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Longest Word in Dictionary",
    "body": "Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words.\n If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.\n Note that the word should be built from left to right with each additional character being added to the end of a previous word. \n",
    "example": "Input: words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"], Output: \"world\", Explanation: The word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\". \n Input: words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"], Output: \"apple\", Explanation: Both \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\". \n",
    "level": "medium"
  },
  {
    "title": "Reverse Words in a String",
    "body": "Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
    "example": "Input: s = \"the sky is blue\", Output: \"blue is sky the\";\n Input: s = \"  hello world  \", Output: \"world hello\", Explanation: Your reversed string should not contain leading or trailing spaces.;\n Input: s = \"a good   example\", Output: \"example good a\", Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.",
    "level": "medium"
  },
  {
    "title": "The Truck problem",
    "body": "You need to write three classes:\n 1st class car, the car has a default maximum speed of 100 km/h, the name and condition are empty/ loaded\n2 - The car's heir is a passenger car. By default, any passenger car is not loaded. However, this state can only change after the car is created (not during creation). \n3 - The car's heir is a cargo truck. By default, any truck is loaded. However, this state can change both during the creation of the car and after. \nAt the same time, the maximum speed of this car depends on the workload. If it is loaded, then its speed drops by half.\nAs well: \nIt is necessary to implement the ability to compare trucks by name and current maximum speed.\n It is necessary to write code that verifies the correctness of the implementation of tasks (speed versus workload, truck comparisons)",
    "example": "Nothing",
    "level": "medium",
    "solution": {
      "content": "class Car {\n    protected String name;\n    protected boolean condition; // true = loaded, false = empty\n    protected int maxSpeed;\n\n    public Car(String name, boolean condition) {\n        this.name = name;\n        this.condition = condition;\n        this.maxSpeed = 100;\n    }\n\n    @Override\n    public String toString() {\n        return \"Car(name=\" + name + \", condition=\" + (condition ? \"Loaded\" : \"Empty\") + \", maxSpeed=\" + maxSpeed + \" km/h)\";\n    }\n}\n\nclass PassengerCar extends Car {\n    public PassengerCar(String name) {\n        super(name, false); // Always starts as empty\n    }\n\n    public void load(boolean condition) {\n        this.condition = condition; // Can change after creation\n    }\n}\n\nclass CargoTruck extends Car implements Comparable<CargoTruck> {\n    public CargoTruck(String name, boolean condition) {\n        super(name, condition);\n        updateSpeed();\n    }\n\n    private void updateSpeed() {\n        this.maxSpeed = condition ? 50 : 100; // Speed is halved when loaded\n    }\n\n    public void load(boolean condition) {\n        this.condition = condition;\n        updateSpeed();\n    }\n\n    @Override\n    public int compareTo(CargoTruck other) {\n        int nameComparison = this.name.compareTo(other.name);\n        if (nameComparison == 0) {\n            return Integer.compare(this.maxSpeed, other.maxSpeed);\n        }\n        return nameComparison;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        CargoTruck truck = (CargoTruck) obj;\n        return name.equals(truck.name) && maxSpeed == truck.maxSpeed;\n    }\n\n    @Override\n    public String toString() {\n        return \"CargoTruck(name=\" + name + \", condition=\" + (condition ? \"Loaded\" : \"Empty\") + \", maxSpeed=\" + maxSpeed + \" km/h)\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"--- Creating Vehicles ---\");\n        Car car1 = new Car(\"GenericCar\", true);\n        System.out.println(car1);\n\n        PassengerCar pcar = new PassengerCar(\"Passenger1\");\n        System.out.println(pcar);\n        pcar.load(true);\n        System.out.println(\"After loading passenger car: \" + pcar);\n\n        CargoTruck truck1 = new CargoTruck(\"TruckA\", true);\n        CargoTruck truck2 = new CargoTruck(\"TruckB\", false);\n        System.out.println(truck1);\n        System.out.println(truck2);\n\n        System.out.println(\"--- Changing Load States ---\");\n        truck1.load(false);\n        truck2.load(true);\n        System.out.println(truck1);\n        System.out.println(truck2);\n\n        System.out.println(\"--- Comparing Trucks ---\");\n        CargoTruck truck3 = new CargoTruck(\"TruckA\", false);\n        System.out.println(\"Truck1 == Truck3? \" + truck1.equals(truck3));\n        System.out.println(\"Truck1 < Truck2? \" + (truck1.compareTo(truck2) < 0));\n        System.out.println(\"Truck2 < Truck3? \" + (truck2.compareTo(truck3) < 0));\n    }"
    }
  },
  {
    "title": "Validate IP Address",
    "body": "Write a method that takes a string and determines whether it is a valid IPv4 or IPv6 address. Return \"IPv4\" if valid IPv4, \"IPv6\" if valid IPv6, or \"Neither\" if invalid.",
    "example": "\"172.16.254.1\" → \"IPv4\", \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" → \"IPv6, \"256.256.256.256\" → \"Neither\"",
    "level": "medium",
    "solution": {
      "content": "public class ValidateIPAddress {\n    public String validateIPAddress(final String ipAddress) {\n        Objects.requireNonNull(ipAddress, \"The sentence cannot be null\");\n        final String trimmed = ipAddress.trim().toLowerCase();\n\n        if (trimmed.isEmpty()) return \"Neither\";\n\n        if (isIpV4Valid(trimmed)) return \"IPv4\";\n        if (isIpV6Valid(trimmed)) return \"IPv6\";\n\n        return \"Neither\";\n    }\n\n    private boolean isIpV4Valid(final String text) {\n        String[] items = text.split(\"\\\\.\", -1);\n        if (items.length != 4) return false;\n\n        for (String item : items) {\n            if (item.isEmpty() || (item.length() > 1 && item.startsWith(\"0\"))) return false;\n            try {\n                int value = Integer.parseInt(item);\n                if (value < 0 || value > 255) return false;\n            } catch (NumberFormatException exception) {\n                return false;\n            }\n\n        }\n        return true;\n    }\n\n    private boolean isIpV6Valid(final String text) {\n        String[] items = text.split(\":\", -1);\n        if (items.length != 8) return false;\n\n        for (String item : items) {\n            if (item.isEmpty() || item.length() > 4) return false;\n\n            for (char symbol : item.toCharArray()) {\n                if ((!Character.isDigit(symbol) && ((Character.toLowerCase(symbol) < 'a') || (Character.toLowerCase(symbol) > 'f')))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}"
    }
  },
  {
    "title": "Implement a Custom Stack with Min Function",
    "body": "Design and implement a CustomStack class that supports push(int), pop(), peek(), and getMin() — all in constant time.\nThe getMin() method should return the smallest element in the stack.",
    "example": "Concepts Tested:\n\nStack implementation\n\nConstant-time algorithms\n\nAuxiliary data structures",
    "level": "medium"
  },
  {
    "title": "Group Anagrams",
    "body": "Given a list of strings, group them by anagrams. Return a list of grouped anagrams, where each group contains strings that are anagrams of each other.",
    "example": "Example Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Expected Output Format: [\n  [\"eat\", \"tea\", \"ate\"],\n  [\"tan\", \"nat\"],\n  [\"bat\"]\n]; Concepts Tested:\n\nString manipulation\n\nHashing and grouping\n\nWorking with Map and List collections",
    "level": "medium"
  },
  {
    "title": "Implement a Thread-Safe Singleton Logger",
    "body": "Create a singleton Logger class that ensures only one instance is used throughout the application. The logger should be thread-safe and lazily initialized. Add a method to write messages to a log file with timestamps.",
    "example": "",
    "level": "medium",
    "solution": {
      "content": "public class SingletonLogger {\n    private static final Logger logger = Logger.getLogger(SingletonLogger.class.getName());\n\n    private static SingletonLogger log;\n\n    private static final String LOG_FILE = \"singleton_log.txt\";\n\n    private SingletonLogger() {\n        try {\n            FileHandler fileHandler = new FileHandler(LOG_FILE, true);\n            fileHandler.setFormatter(new SimpleFormatter());\n            if (logger.getHandlers().length == 0) {\n                logger.addHandler(fileHandler);\n            }\n        } catch (IOException exception) {\n            logger.log(Level.WARNING, \"Failed to set up file handler: {0}\", exception.getMessage());\n        }\n    }\n\n    public static synchronized SingletonLogger getLog() {\n        if (log == null) {\n            log = new SingletonLogger();\n        }\n        return log;\n    }\n\n    public void log(Level level, String message) {\n        logger.log(level, message);\n    }\n}"
    }
  },
  {
    "title": "Create a Custom HashMap Implementation",
    "body": "Implement a simplified version of HashMap<K, V> using an array of buckets and linked lists for collision handling. Provide support for basic operations: put(), get(), remove(), and containsKey()",
    "example": "",
    "level": "medium"
  },
  {
    "title": "Implement an Event Scheduler System",
    "body": "Design and implement a class EventScheduler that allows scheduling tasks to run at a specified future time. Each task should be a Runnable. Provide functionality to cancel scheduled tasks.",
    "example": "",
    "level": "medium"
  },
  {
    "title": "Build a File Search Utility",
    "body": "Develop a program that recursively searches through a directory and its subdirectories to find all files matching a given filename pattern (e.g., all .txt files containing a certain keyword).",
    "example": "",
    "level": "medium",
    "solution": {
      "content": "public class SearchFile {\n    private static final Logger logger = Logger.getLogger(SearchFile.class.getName());\n\n    public List<String> searchWithWc(final Path rootDir, final String pattern) {\n        Objects.requireNonNull(rootDir, \"The rootDir variable cannot be null\");\n        Objects.requireNonNull(pattern, \"The pattern variable cannot be null\");\n\n        List<String> matchesList = new ArrayList<>();\n\n        final FileVisitor<Path> matcherVisitor = new SimpleFileVisitor<>() {\n            @Override\n            public @NotNull FileVisitResult visitFile(Path file, final @NotNull BasicFileAttributes attribs) {\n                final PathMatcher matcher = FileSystems.getDefault().getPathMatcher(pattern);\n                if (matcher.matches(file.getFileName())) {\n                    matchesList.add(file.toAbsolutePath().toString());\n                }\n                return FileVisitResult.CONTINUE;\n            }\n        };\n        try {\n            Files.walkFileTree(rootDir, matcherVisitor);\n        } catch (IOException exception) {\n            logger.log(Level.WARNING, \"Error during file traversal: {0}\", exception.getMessage());\n        }\n        return matchesList;\n    }\n}"
    }
  },
  {
    "title": "Implement of a thread-safe singleton logger",
    "body": "Create a singleton Logger class that ensures only one instance is used throughout the application. The logger should be thread-safe and lazily initialized. Add a method to write messages to a log file with timestamps.",
    "example": "",
    "level": "medium",
    "solution": {
      "content": "public class SingletonLogger {\n    private static final Logger logger = Logger.getLogger(SingletonLogger.class.getName());\n\n    private static SingletonLogger log;\n\n    private static final String LOG_FILE = \"singleton_log.txt\";\n\n    private SingletonLogger() {\n        try {\n            FileHandler fileHandler = new FileHandler(LOG_FILE, true);\n            fileHandler.setFormatter(new SimpleFormatter());\n            if (logger.getHandlers().length == 0) {\n                logger.addHandler(fileHandler);\n            }\n        } catch (IOException exception) {\n            logger.log(Level.WARNING, \"Failed to set up file handler: {0}\", exception.getMessage());\n        }\n    }\n\n    public static synchronized SingletonLogger getLog() {\n        if (log == null) {\n            log = new SingletonLogger();\n        }\n        return log;\n    }\n\n    public void log(Level level, String message) {\n        logger.log(level, message);\n    }\n}"
    }
  },
  {
    "title": "Create a Custom HashMap Implementation",
    "body": "Implement a simplified version of HashMap<K, V> using an array of buckets and linked lists for collision handling. Provide support for basic operations: put(), get() and remove()",
    "example": "",
    "level": "medium",
    "solution": {
      "content": "public class HashMapCustom<K, V> {\n    static class Entry<K, V> {\n        K key;\n        V value;\n        HashMapCustom.Entry<K, V> next;\n\n        public Entry(K key, V value, HashMapCustom.Entry<K, V> next) {\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n    }\n\n    private static final float LOAD_FACTOR = 0.75f;\n    private int size;\n    private int capacity = 4;\n    @SuppressWarnings(\"unchecked\")\n    private HashMapCustom.Entry<K, V>[] bucket = new HashMapCustom.Entry[capacity];\n\n    public HashMapCustom() {\n        capacity = 4;\n        bucket = (HashMapCustom.Entry<K, V>[]) new HashMapCustom.Entry[capacity];\n    }\n\n    public void put(K key, V value) {\n        if (key == null) return;\n\n        if ((float) size / capacity >= LOAD_FACTOR) {\n            resize();\n        }\n\n        int hash = hash(key);\n        HashMapCustom.Entry<K, V> current = bucket[hash];\n\n        if (current == null) {\n            bucket[hash] = new HashMapCustom.Entry<>(key, value, null);\n            size++;\n            return;\n        }\n\n        while (current != null) {\n            if (current.key.equals(key)) {\n                current.value = value;\n                return;\n            }\n            if (current.next == null) {\n                current.next = new HashMapCustom.Entry<>(key, value, null);\n                size++;\n                return;\n            }\n            current = current.next;\n        }\n    }\n\n    public V get(K key) {\n        if (key == null) return null;\n        int hash = hash(key);\n        HashMapCustom.Entry<K, V> current = bucket[hash];\n        while (current != null) {\n            if (current.key.equals(key)) return current.value;\n            current = current.next;\n        }\n        return null;\n    }\n\n    public boolean remove(K key) {\n        if (key == null) return false;\n        int hash = hash(key);\n        HashMapCustom.Entry<K, V> current = bucket[hash];\n        HashMapCustom.Entry<K, V> prev = null;\n\n        while (current != null) {\n            if (current.key.equals(key)) {\n                if (prev == null) {\n                    bucket[hash] = current.next;\n                } else {\n                    prev.next = current.next;\n                }\n                size--;\n                return true;\n            }\n            prev = current;\n            current = current.next;\n        }\n\n        return false;\n    }\n\n    private int hash(K key) {\n        return Math.abs(key.hashCode()) % capacity;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void resize() {\n        int newCapacity = capacity * 2;\n        HashMapCustom.Entry<K, V>[] oldBucket = bucket;\n        bucket = (HashMapCustom.Entry<K, V>[]) new HashMapCustom.Entry[newCapacity];\n        capacity = newCapacity;\n        size = 0;\n\n        for (HashMapCustom.Entry<K, V> head : oldBucket) {\n            while (head != null) {\n                put(head.key, head.value);\n                head = head.next;\n            }\n        }\n    }\n\n    public int size() {\n        return size;\n    }"
    }
  },
  {
    "title": "Build a File Search Utility",
    "body": "Develop a program that recursively searches through a directory and its subdirectories to find all files matching a given filename pattern (e.g., all .txt files containing a certain keyword).",
    "example": "",
    "level": "medium",
    "solution": {
      "content": "public class SearchFile {\n    private static final Logger logger = Logger.getLogger(SearchFile.class.getName());\n\n    public List<String> searchWithWc(final Path rootDir, final String pattern) {\n        Objects.requireNonNull(rootDir, \"The rootDir variable cannot be null\");\n        Objects.requireNonNull(pattern, \"The pattern variable cannot be null\");\n\n        List<String> matchesList = new ArrayList<>();\n\n        final FileVisitor<Path> matcherVisitor = new SimpleFileVisitor<>() {\n            @Override\n            public @NotNull FileVisitResult visitFile(Path file, final @NotNull BasicFileAttributes attribs) {\n                final PathMatcher matcher = FileSystems.getDefault().getPathMatcher(pattern);\n                if (matcher.matches(file.getFileName())) {\n                    matchesList.add(file.toAbsolutePath().toString());\n                }\n                return FileVisitResult.CONTINUE;\n            }\n        };\n        try {\n            Files.walkFileTree(rootDir, matcherVisitor);\n        } catch (IOException exception) {\n            logger.log(Level.WARNING, \"Error during file traversal: {0}\", exception.getMessage());\n        }\n        return matchesList;\n    }\n}"
    }
  },
  {
    "title": "RESTful API Client",
    "body": "Create a Java application that interacts with a third-party RESTful API. A good choice would be the GitHub API to retrieve information about a user's repositories or the OpenWeatherMap API to get weather data for a city.",
    "example": "HTTP Communication: Use a modern HTTP client library like OkHttp or java.net.http.HttpClient (from Java 11+) to make GET requests to the API endpoints. \n JSON Parsing: The API responses will be in JSON format. Use a library such as Jackson or Gson to deserialize the JSON into custom Java objects (POJOs or records). \n Object-Oriented Design: Create a dedicated class for each resource you're retrieving (e.g., a Repository class or a Weather class). \n  Error Handling: Implement robust error handling for different HTTP status codes (e.g., 404 Not Found, 401 Unauthorized, 500 Internal Server Error).",
    "level": "medium",
    "solution": {
      "content": ""
    }
  },
  {
    "title": "Top K Frequent Elements",
    "body": "Given an integer array and an integer k, return the k most frequent elements. Optimize for time complexity better than O(n log n)",
    "example": "Input: nums = [1,1,1,2,2,3], k = 2, Output: [1,2]",
    "level": "hard",
    "solution": {
      "content": "public int[] topFrequentElements(final int[] inputArray, final int k) {\n        Objects.requireNonNull(inputArray, \"Input array cannot be null\");\n\n        if (inputArray.length == 0 || k <= 0) {\n            throw new IllegalArgumentException(\"Array must not be empty and k must be > 0\");\n        }\n\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : inputArray) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        PriorityQueue<Map.Entry<Integer, Integer>> maxHeap =\n                new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n\n        maxHeap.addAll(frequencyMap.entrySet());\n\n        int[] result = new int[k];\n        for (int i = 0; i < k; i++) {\n            result[i] = Objects.requireNonNull(maxHeap.poll()).getKey();\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "Best Time to Buy and Sell Stock IV",
    "body": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\n\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "example": "Input: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2; Input: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.",
    "level": "hard"
  },
  {
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "body": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.\n\nImplement the RandomizedCollection class:\n\nRandomizedCollection() Initializes the empty RandomizedCollection object.\nbool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.\nbool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.\nint getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of the same values the multiset contains.\nYou must implement the functions of the class such that each function works on average O(1) time complexity.\n\nNote: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.\n\n",
    "example": "Input\n[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"]\n[[], [1], [1], [2], [], [1], []]\nOutput\n[null, true, false, true, 2, true, 1]",
    "level": "hard"
  },
  {
    "title": "Longest Increasing Path in a Matrix",
    "body": "Given an m x n integers matrix, return the length of the longest increasing path in matrix., From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\n",
    "example": "Input: matrix = [[9,9,4],[6,6,8],[2,1,1]], Output: 4, Explanation: The longest increasing path is [1, 2, 6, 9]; Input: matrix = [[3,4,5],[3,2,6],[2,2,1]], Output: 4, Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.; Input: matrix = [[1]], Output: 1",
    "level": "hard"
  },
  {
    "title": "Concatenated Words",
    "body": "Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.",
    "example": "Input: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"], Output: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"], Explanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n\"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\"; Input: words = [\"cat\",\"dog\",\"catdog\"], Output: [\"catdog\"]",
    "level": "hard"
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "body": "Given a string, find the length of the longest substring without repeating characters.",
    "example": "Input: \"abcabcbb\", Output: 3 (substring is \"abc\")",
    "level": "hard"
  },
  {
    "title": "Word Ladder (Transform Words with Dictionary)",
    "body": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
    "example": "Example 1:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long \n Example 2:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.",
    "level": "hard"
  }
]