[
  {
    "title": "Convert Sorted Array to Binary Search Tree",
    "body": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
    "example": "Example 1:\n\n\nInput: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: [0,-10,5,null,-3,null,9] is also accepted:\n\nExample 2:\n\n\nInput: nums = [1,3]\nOutput: [3,1]\nExplanation: [1,null,3] and [3,1] are both height-balanced BSTs.",
    "level": "easy",
    "solution": {
      "content": "public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode() {\n        }\n\n        TreeNode(int val) {\n            this.val = val;\n        }\n\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }  public TreeNode sortedArrayToBST(int[] nums) {\n        this.nums = nums;\n        return createNode(0, nums.length - 1);\n    }\n\n    private TreeNode createNode(int left, int right) {\n        if (left > right) {\n            return null;\n        }\n\n        final int middle = (left + right) / 2;\n\n        return new TreeNode(nums[middle], createNode(left, middle - 1), createNode(middle + 1, right));\n    }"
    }
  },
  {
    "title": "Binary Tree Level Order Traversal",
    "body": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "example": "Example 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\nExample 2:\n\nInput: root = [1]\nOutput: [[1]]\nExample 3:\n\nInput: root = []\nOutput: []",
    "level": "easy",
    "solution": {
      "content": "public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode() {\n        }\n\n        TreeNode(int val) {\n            this.val = val;\n        }\n\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }  public List<List<Integer>> levelOrder(TreeNode root) {\n        final List<List<Integer>> result = new ArrayList<>();\n        if (Objects.isNull(root)) {\n            return result;\n        }\n\n        final Deque<TreeNode> treeNodeDeque = new ArrayDeque<>();\n        treeNodeDeque.offer(root);\n\n        while (!treeNodeDeque.isEmpty()) {\n            final List<Integer> currentLevel = new ArrayList<>();\n            int levelSize = treeNodeDeque.size();\n\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode currentNode = treeNodeDeque.poll();\n\n                if (Objects.nonNull(currentNode)) {\n                    currentLevel.add(currentNode.val);\n\n                    if (currentNode.left != null) {\n                        treeNodeDeque.add(currentNode.left);\n                    }\n\n                    if (currentNode.right != null) {\n                        treeNodeDeque.add(currentNode.right);\n                    }\n                }\n            }\n            result.add(currentLevel);\n        }\n        return result;"
    }
  },
  {
    "title": "Symmetric Tree",
    "body": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
    "example": "Example 1:\n\n\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\nExample 2:\n\n\nInput: root = [1,2,2,null,3,null,3]\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode() {\n        }\n\n        TreeNode(int val) {\n            this.val = val;\n        }\n\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    } public boolean isSymmetric(TreeNode root) {\n        return isSymmetric(root.left, root.right);\n    }\n\n    private boolean isSymmetric(TreeNode left, TreeNode right) {\n        if (left == right) return true;\n\n        if (left == null || right == null || left.val != right.val) {\n            return false;\n        }\n\n        return isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\n    }"
    }
  },
  {
    "title": "Validate Binary Search Tree",
    "body": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys strictly less than the node's key.\nThe right subtree of a node contains only nodes with keys strictly greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.",
    "example": "Example 1:\n\n\nInput: root = [2,1,3]\nOutput: true\nExample 2:\n\n\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.",
    "level": "easy",
    "solution": {
      "content": "public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode() {\n        }\n\n        TreeNode(int val) {\n            this.val = val;\n        }\n\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }  public boolean isValidBST(TreeNode root) {\n         return isValidBST(root, null, null);\n    }\n\n    private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\n        if (Objects.isNull(root)) return true;\n\n        if (Objects.nonNull(min) && root.val <= min.val) {\n            return false;\n        }\n\n        if (Objects.nonNull(max) && root.val >= max.val) {\n            return false;\n        }\n\n        return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);\n    }"
    }
  },
  {
    "title": "Maximum Depth of Binary Tree",
    "body": "Given the root of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "example": "Example 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\nExample 2:\n\nInput: root = [1,null,2]\nOutput: 2",
    "level": "easy",
    "solution": {
      "content": "static class NodeDepth {\n        TreeNode node;\n        int depth;\n\n        public NodeDepth(TreeNode node, int depth) {\n            this.node = node;\n            this.depth = depth;\n        }\n    }\n\n    public int maxDepth(TreeNode root) {\n    if (Objects.isNull(root)) {\n            return 0;\n        }\n\n        int maxDepth = 0;\n\n        final Deque<NodeDepth> deque = new ArrayDeque<>();\n\n        deque.push(new NodeDepth(root, 1));\n\n        while (!deque.isEmpty()) {\n            NodeDepth current = deque.pop();\n\n            TreeNode currentNode = current.node;\n            int currentDepth = current.depth;\n\n            maxDepth = Math.max(maxDepth, currentDepth);\n\n            if (Objects.nonNull(currentNode.left)) {\n                deque.push(new NodeDepth(currentNode.left, currentDepth + 1));\n            }\n\n            if (Objects.nonNull(currentNode.right)) {\n                deque.push(new NodeDepth(currentNode.right, currentDepth + 1));\n            }\n        }\n\n        return maxDepth;\n    }"
    }
  },
  {
    "title": "Linked List Cycle",
    "body": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.",
    "example": "Example 1:\n\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\nExample 2:\n\n\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\nExample 3:\n\n\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.",
    "level": "easy",
    "solution": {
      "content": "public boolean hasCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n\n            if (fast == slow) {\n                return true;\n            }\n        }\n        return false;\n    }"
    }
  },
  {
    "title": "Palindrome Linked List",
    "body": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.\n\n",
    "example": "Example 1:\n\n\nInput: head = [1,2,2,1]\nOutput: true\nExample 2:\n\n\nInput: head = [1,2]\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "public boolean isPalindrome(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head.next;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        ListNode current = slow.next;\n        slow.next = null;\n\n        ListNode previous = null;\n\n        while (current != null) {\n            ListNode temp = current.next;\n            current.next = previous;\n            previous = current;\n            current = temp;\n        }\n\n        while (previous != null) {\n            if (previous.val != head.val) {\n                return false;\n            }\n            previous = previous.next;\n            head = head.next;\n        }\n\n        return true;\n    }"
    }
  },
  {
    "title": "Merge Two Sorted Lists",
    "body": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
    "example": "Example 1:\n\n\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\nExample 2:\n\nInput: list1 = [], list2 = []\nOutput: []\nExample 3:\n\nInput: list1 = [], list2 = [0]\nOutput: [0]",
    "level": "easy",
    "solution": {
      "content": "public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        final ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n\n        while (list1 != null && list2 != null) {\n            if (list1.val > list2.val) {\n                current.next = list2;\n                list2 = list2.next;\n            } else {\n                current.next = list1;\n                list1 = list1.next;\n            }\n            current = current.next;\n        }\n\n        current.next = list1 != null ? list1 : list2;\n\n        return dummy.next;\n    }"
    }
  },
  {
    "title": "Reverse Linked List",
    "body": "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\n",
    "example": "Example 1:\n\n\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\nExample 2:\n\n\nInput: head = [1,2]\nOutput: [2,1]\nExample 3:\n\nInput: head = []\nOutput: []",
    "level": "easy",
    "solution": {
      "content": "public ListNode reverseList(ListNode head) {\n        final ListNode dummy = new ListNode();\n\n        ListNode current = head;\n\n        while (current != null) {\n            ListNode next = current.next;\n\n            current.next = dummy.next;\n            dummy.next = current;\n            current = next;\n\n        }\n\n        return dummy.next;\n    }"
    }
  },
  {
    "title": "Remove Nth Node From End of List",
    "body": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n",
    "example": "Example 1:\n\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\nExample 2:\n\nInput: head = [1], n = 1\nOutput: []\nExample 3:\n\nInput: head = [1,2], n = 1\nOutput: [1]",
    "level": "easy",
    "solution": {
      "content": "public ListNode removeNthFromEnd(ListNode head, int n) {\n        final ListNode dummy = new ListNode(0, head);\n\n        ListNode fastPointer = dummy;\n        \n        ListNode slowPointer = dummy;\n\n        while (n > 0) {\n            fastPointer = fastPointer.next;\n            n--;\n        }\n\n        while (fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next;\n        }\n\n        slowPointer.next = slowPointer.next.next;\n\n        return dummy.next;\n    }"
    }
  },
  {
    "title": "Delete Node in a Linked List",
    "body": "There is a singly-linked list head and we want to delete a node node in it.\n\nYou are given the node to be deleted node. You will not be given access to the first node of head.\n\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\n\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n\nThe value of the given node should not exist in the linked list.\nThe number of nodes in the linked list should decrease by one.\nAll the values before node should be in the same order.\nAll the values after node should be in the same order.\nCustom testing:\n\nFor the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.\nWe will build the linked list and pass the node to your function.\nThe output will be the entire list after calling your function.",
    "example": "Input: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n  Input: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.",
    "level": "easy",
    "solution": {
      "content": "public class ListNode {\n        int val;\n        ListNode next;\n\n        public ListNode() {\n        }\n\n        ListNode(int val) {\n            this.val = val;\n        }\n\n        ListNode(int val, ListNode next) {\n            this.val = val;\n            this.next = next;\n        }\n    }\n\n    public void deleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }"
    }
  },
  {
    "title": "Implement strStr()",
    "body": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
    "example": "Input: haystack = \"sadbutsad\", needle = \"sad\"\nOutput: 0\nExplanation: \"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.  \n Input: haystack = \"leetcode\", needle = \"leeto\"\nOutput: -1\nExplanation: \"leeto\" did not occur in \"leetcode\", so we return -1.",
    "level": "easy",
    "solution": {
      "content": "public int strStr(String haystack, String needle) {\n        if (needle.isEmpty()) {\n            return 0;\n        }\n\n        int haystackLength = haystack.length();\n        int needleLength = needle.length();\n\n        for (int i = 0; i < haystackLength - needleLength + 1; i++) {\n            if (haystack.substring(i, i + needleLength).equals(needle)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }"
    }
  },
  {
    "title": "Contains Duplicate",
    "body": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
    "example": "Example 1:\n\nInput: nums = [1,2,3,1]\n\nOutput: true\n\nExplanation:\n\nThe element 1 occurs at the indices 0 and 3.\n\nExample 2:\n\nInput: nums = [1,2,3,4]\n\nOutput: false\n\nExplanation:\n\nAll elements are distinct.\n\nExample 3:\n\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\n\nOutput: true",
    "level": "easy",
    "solution": {
      "content": "public boolean containsDuplicate(int[] nums) {\n        final Set<Integer> hashSet = new HashSet<>();\n        \n        Objects.requireNonNull(nums, \"The array cannot be null\");\n\n        for (int number : nums) {\n            if (!hashSet.add(number)) {\n                return true;\n            }\n\n        }\n        return false;\n    }"
    }
  },
  {
    "title": "Remove Duplicates from Sorted Array",
    "body": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\nConsider the number of unique elements in nums to be k\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B. After removing duplicates, return the number of unique elements k.\n\nThe first k elements of nums should contain the unique numbers in sorted order. The remaining elements beyond index k - 1 can be ignored.",
    "example": "Example 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
    "level": "easy",
    "solution": {
      "content": "public int removeDuplicates(int[] nums) {\n        Objects.requireNonNull(nums, \"The array cannot be null\");\n\n        if (nums.length == 0) return 0;\n\n        int index = 1;\n\n        for (int number : nums) {\n            if (number != nums[index - 1]) {\n                nums[index] = number;\n                index++;\n            }\n        }\n\n        return index;\n    }"
    }
  },
  {
    "title": "Best Time to Buy and Sell Stock II",
    "body": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can sell and buy the stock multiple times on the same day, ensuring you never hold more than one share of the stock.\n\nFind and return the maximum profit you can achieve.",
    "example": "Example 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.",
    "level": "easy",
    "solution": {
      "content": "public int maxProfit(int[] prices) {\n        Objects.requireNonNull(prices, \"The array cannot be null\");\n\n        if (prices.length < 1) {\n            throw new IllegalArgumentException(\"The array must contain at least one price.\");\n        }\n\n        int maxProfit = 0;\n\n        for (int i = 0; i < prices.length - 1; i++) {\n            final int a = prices[i];\n            final int b = prices[i + 1];\n            maxProfit += Math.max(0, (b - a));\n        }\n\n        return maxProfit;\n    }"
    }
  },
  {
    "title": "Remove Duplicates from Sorted Array",
    "body": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\nConsider the number of unique elements in nums to be k\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B. After removing duplicates, return the number of unique elements k.\n\nThe first k elements of nums should contain the unique numbers in sorted order. The remaining elements beyond index k - 1 can be ignored.",
    "example": "Example 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
    "level": "easy",
    "solution": {
      "content": "public int removeDuplicates(int[] nums) {\n        Objects.requireNonNull(nums, \"The array cannot be null\");\n\n        if (nums.length == 0) return 0;\n\n        int index = 1;\n\n        for (int number : nums) {\n            if (number != nums[index - 1]) {\n                nums[index] = number;\n                index++;\n            }\n        }\n\n        return index;\n    }"
    }
  },
  {
    "title": "Substrings of Size Three with Distinct Characters",
    "body": "A string is good if there are no repeated characters.\n\nGiven a string s\u200B\u200B\u200B\u200B\u200B, return the number of good substrings of length three in s\u200B\u200B\u200B\u200B\u200B\u200B.\n\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\n\nA substring is a contiguous sequence of characters in a string.",
    "example": "Example 1:\n\nInput: s = \"xyzzaz\"\nOutput: 1\nExplanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \nThe only good substring of length 3 is \"xyz\".\nExample 2:\n\nInput: s = \"aababcabc\"\nOutput: 4\nExplanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\nThe good substrings are \"abc\", \"bca\", \"cab\", and \"abc\".\n",
    "level": "easy",
    "solution": {
      "content": "public int countGoodSubstrings(String s) {\n        int count = 0;\n        for (int i = 0; i <= s.length() - 3; i++) {\n\n            if ((s.charAt(i) != s.charAt(i + 1)\n                    && s.charAt(i + 1) != s.charAt(i + 2)\n                    && s.charAt(i) != s.charAt(i + 2))) {\n                count++;\n            }\n        }\n        return count;\n    }"
    }
  },
  {
    "title": "Number of Different Integers in a String",
    "body": "You are given a string word that consists of digits and lowercase English letters.\n\nYou will replace every non-digit character with a space. For example, \"a123bc34d8ef34\" will become \" 123  34 8  34\". Notice that you are left with some integers that are separated by at least one space: \"123\", \"34\", \"8\", and \"34\".\n\nReturn the number of different integers after performing the replacement operations on word.\n\nTwo integers are considered different if their decimal representations without any leading zeros are different.",
    "example": "Example 1:\n\nInput: word = \"a123bc34d8ef34\"\nOutput: 3\nExplanation: The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once.\nExample 2:\n\nInput: word = \"leet1234code234\"\nOutput: 2\nExample 3:\n\nInput: word = \"a1b01c001\"\nOutput: 1\nExplanation: The three integers \"1\", \"01\", and \"001\" all represent the same integer because\nthe leading zeros are ignored when comparing their decimal values.",
    "level": "easy",
    "solution": {
      "content": "public int numDifferentIntegers(String word) {\n        final Set<String> frequency = new HashSet<>();\n        final String[] digits = word.replaceAll(\"\\\\p{Alpha}\", \" \")\n                .trim()\n                .split(\"\\\\s+\");\n\n        for (String item : digits) {\n            if (!item.isEmpty()) {\n                frequency.add(item.replaceAll(\"^0*\", \"\"));\n            }\n        }\n        return frequency.size();\n    }"
    }
  },
  {
    "title": "Check if the Sentence Is Pangram",
    "body": "A pangram is a sentence where every letter of the English alphabet appears at least once.\n\nGiven a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.",
    "example": "Example 1:\n\nInput: sentence = \"thequickbrownfoxjumpsoverthelazydog\"\nOutput: true\nExplanation: sentence contains at least one of every letter of the English alphabet.\nExample 2:\n\nInput: sentence = \"leetcode\"\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "ublic boolean checkIfPangram(String sentence) {\n        Objects.requireNonNull(sentence, \"The sentence cannot be null\");\n\n        if (sentence.length() < 26) {\n            return false;\n        }\n\n        for (char ch = 'a'; ch <= 'z'; ch++) {\n            if (sentence.indexOf(ch) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }"
    }
  },
  {
    "title": "Second Largest Digit in a String",
    "body": "Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist.\n\nAn alphanumeric string is a string consisting of lowercase English letters and digits.",
    "example": "Example 1:\n\nInput: s = \"dfa12321afd\"\nOutput: 2\nExplanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2.\nExample 2:\n\nInput: s = \"abc1111\"\nOutput: -1\nExplanation: The digits that appear in s are [1]. There is no second largest digit. ",
    "level": "easy",
    "solution": {
      "content": "public int secondHighest(String s) {\n        int a = -1;\n        int b = -1;\n        for (char symbol : s.toCharArray()) {\n            if (Character.isDigit(symbol)) {\n\n                int v = symbol - '0';\n\n                if (v > a) {\n                    b = a;\n                    a = v;\n                } else if (v > b && v < a) {\n                    b = v;\n                }\n            }\n        }\n        return b;\n    }"
    }
  },
  {
    "title": "Check if One String Swap Can Make Strings Equal",
    "body": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\n\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.",
    "example": "Example 1:\n\nInput: s1 = \"bank\", s2 = \"kanb\"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make \"bank\".\nExample 2:\n\nInput: s1 = \"attack\", s2 = \"defend\"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.\nExample 3:\n\nInput: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required.",
    "level": "easy",
    "solution": {
      "content": "public boolean areAlmostEqual(String s1, String s2) {\n      int differCount = 0;\n\n        int firstStringChar = 0;\n        int secondStringChar = 0;\n\n        for (int i = 0; i < s1.length(); i++) {\n            final char currentCharacterForFirstString = s1.charAt(i);\n            final char currentCharacterForSecondString = s2.charAt(i);\n\n            if (currentCharacterForFirstString != currentCharacterForSecondString) {\n                differCount++;\n\n                if (differCount > 2) {\n                    return false;\n                }\n\n                if (differCount == 2 && (currentCharacterForFirstString != secondStringChar || currentCharacterForSecondString != firstStringChar)) {\n                        return false;\n                    }\n\n\n                if (differCount == 1) {\n                    firstStringChar = currentCharacterForFirstString;\n                    secondStringChar = currentCharacterForSecondString;\n                }\n            }\n        }\n        return differCount != 1;\n    }"
    }
  },
  {
    "title": "Second Largest Digit in a String",
    "body": "Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist.\n\nAn alphanumeric string is a string consisting of lowercase English letters and digits.",
    "example": "Example 1:\n\nInput: s = \"dfa12321afd\"\nOutput: 2\nExplanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2.\nExample 2:\n\nInput: s = \"abc1111\"\nOutput: -1\nExplanation: The digits that appear in s are [1]. There is no second largest digit. ",
    "level": "easy",
    "solution": {
      "content": "public int secondHighest(String s) {\n        int a = -1;\n        int b = -1;\n        for (char symbol : s.toCharArray()) {\n            if (Character.isDigit(symbol)) {\n\n                int v = symbol - '0';\n\n                if (v > a) {\n                    b = a;\n                    a = v;\n                } else if (v > b && v < a) {\n                    b = v;\n                }\n            }\n        }\n        return b;\n    }"
    }
  },
  {
    "title": "Longest Nice Substring",
    "body": "A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. For example, \"abABB\" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, \"abA\" is not because 'b' appears, but 'B' does not.\n\nGiven a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. If there are none, return an empty string.",
    "example": "Example 1:\n\nInput: s = \"YazaAay\"\nOutput: \"aAa\"\nExplanation: \"aAa\" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.\n\"aAa\" is the longest nice substring.\nExample 2:\n\nInput: s = \"Bb\"\nOutput: \"Bb\"\nExplanation: \"Bb\" is a nice string because both 'B' and 'b' appear. The whole string is a substring.\nExample 3:\n\nInput: s = \"c\"\nOutput: \"\"\nExplanation: There are no nice substrings.\n",
    "level": "easy",
    "solution": {
      "content": "public String longestNiceSubstring(String s) {\n        final Set<Character> set = new HashSet<>();\n\n        for (char letter : s.toCharArray()) set.add(letter);\n\n        for (int i = 0; i < s.length(); i++) {\n            if (!set.contains(toggleCase(s.charAt(i)))) {\n                final String prefix = longestNiceSubstring(s.substring(0, i));\n                final String suffix = longestNiceSubstring(s.substring(i + 1));\n                return prefix.length() >= suffix.length() ? prefix : suffix;\n            }\n        }\n        return s;\n    }\n\n    private static char toggleCase(final char letter) {\n        return Character.isLowerCase(letter) ? Character.toUpperCase(letter) : Character.toLowerCase(letter);\n    }"
    }
  },
  {
    "title": "Maximum Number of Balls in a Box",
    "body": "You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), and an infinite number of boxes numbered from 1 to infinity.\n\nYour job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. For example, the ball number 321 will be put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in the box number 1 + 0 = 1.\n\nGiven two integers lowLimit and highLimit, return the number of balls in the box with the most balls.",
    "example": "Example 1:\n\nInput: lowLimit = 1, highLimit = 10\nOutput: 2\nExplanation:\nBox Number:  1 2 3 4 5 6 7 8 9 10 11 ...\nBall Count:  2 1 1 1 1 1 1 1 1 0  0  ...\nBox 1 has the most number of balls with 2 balls.\nExample 2:\n\nInput: lowLimit = 5, highLimit = 15\nOutput: 2\nExplanation:\nBox Number:  1 2 3 4 5 6 7 8 9 10 11 ...\nBall Count:  1 1 1 1 2 2 1 1 1 0  0  ...\nBoxes 5 and 6 have the most number of balls with 2 balls in each.\nExample 3:\n\nInput: lowLimit = 19, highLimit = 28\nOutput: 2\nExplanation:\nBox Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...\nBall Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...\nBox 10 has the most number of balls with 2 balls.",
    "level": "easy",
    "solution": {
      "content": "public int countBalls(int lowLimit, int highLimit) {\n        final Map<Integer, Integer> map = new HashMap<>();\n\n        int counter = Integer.MIN_VALUE;\n\n        for (int i = lowLimit; i <= highLimit; i++) {\n\n            int index = 0;\n\n            int tempNumber = i;\n\n            while (tempNumber != 0) {\n                index += tempNumber % 10;\n                tempNumber /= 10;\n            }\n\n            map.merge(index, 1, Integer::sum);\n\n            counter = map.get(index) > counter ? map.get(index) : counter;\n        }\n\n        return counter;\n    }"
    }
  },
  {
    "title": "Sum of Unique Elements",
    "body": "You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array.\n\nReturn the sum of all the unique elements of nums.",
    "example": "Example 1:\n\nInput: nums = [1,2,3,2]\nOutput: 4\nExplanation: The unique elements are [1,3], and the sum is 4.\nExample 2:\n\nInput: nums = [1,1,1,1,1]\nOutput: 0\nExplanation: There are no unique elements, and the sum is 0.\nExample 3:\n\nInput: nums = [1,2,3,4,5]\nOutput: 15\nExplanation: The unique elements are [1,2,3,4,5], and the sum is 15.",
    "level": "easy",
    "solution": {
      "content": "public int sumOfUnique(int[] nums) {\n        Objects.requireNonNull(nums, \"The array cannot be null\");\n        final int[] numbers = new int[101];\n        int sum = 0;\n\n        for (int number : nums) numbers[number]++;\n\n        for (int i = 0; i < 101; i++) {\n            if (numbers[i] == 1) {\n                sum += i;\n            }\n        }\n\n        return sum;\n    }"
    }
  },
  {
    "title": "Count the Number of Consistent Strings",
    "body": "You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.\n\nReturn the number of consistent strings in the array words.",
    "example": "Example 1:\n\nInput: allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\nOutput: 2\nExplanation: Strings \"aaab\" and \"baa\" are consistent since they only contain characters 'a' and 'b'.\nExample 2:\n\nInput: allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]\nOutput: 7\nExplanation: All strings are consistent.\nExample 3:\n\nInput: allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\nOutput: 4\nExplanation: Strings \"cc\", \"acd\", \"ac\", and \"d\" are consistent.",
    "level": "easy",
    "solution": {
      "content": "public int countConsistentStrings(String allowed, String[] words) {\n        final Set<Character> setAllowed = new HashSet<>();\n\n        for (char word : allowed.toCharArray()) setAllowed.add(word);\n\n        int count = 0;\n\n        for (String s : words) {\n            for (int i = 0; i < s.length(); i++) {\n                if (!setAllowed.contains(s.charAt(i))) {\n                    break;\n                }\n\n                if (i == s.length() - 1) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }"
    }
  },
  {
    "title": "Check Array Formation Through Concatenation",
    "body": "You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].\n\nReturn true if it is possible to form the array arr from pieces. Otherwise, return false.",
    "example": "Example 1:\n\nInput: arr = [15,88], pieces = [[88],[15]]\nOutput: true\nExplanation: Concatenate [15] then [88]\nExample 2:\n\nInput: arr = [49,18,16], pieces = [[16,18,49]]\nOutput: false\nExplanation: Even though the numbers match, we cannot reorder pieces[0].\nExample 3:\n\nInput: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]\nOutput: true\nExplanation: Concatenate [91] then [4,64] then [78]",
    "level": "easy",
    "solution": {
      "content": "public boolean canFormArray(int[] arr, int[][] pieces) {\n       for (int i = 0; i < arr.length;) {\n            int index = 0;\n            while (index < pieces.length && pieces[index][0] != arr[i]) {\n                index++;\n            }\n\n            if (index == pieces.length) {\n                return false;\n            }\n\n            int elementIndex = 0;\n\n            while (elementIndex < pieces[index].length && i < arr.length && arr[i] == pieces[index][elementIndex]) {\n                i++;\n                elementIndex++;\n            }\n\n            if (elementIndex != pieces[index].length) {\n                return false;\n            }\n        }\n\n        return true;\n    }"
    }
  },
  {
    "title": "Sort Array by Increasing Frequency",
    "body": "Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.\n\nReturn the sorted array.",
    "example": "Example 1:\n\nInput: nums = [1,1,2,2,2,3]\nOutput: [3,1,1,2,2,2]\nExplanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.\nExample 2:\n\nInput: nums = [2,3,1,3,2]\nOutput: [1,3,3,2,2]\nExplanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.\nExample 3:\n\nInput: nums = [-1,1,-6,4,5,-6,1,4,1]\nOutput: [5,-1,4,4,-6,-6,1,1,1]\n",
    "level": "easy",
    "solution": {
      "content": "public int[] frequencySort(int[] nums) {\n        Objects.requireNonNull(nums, \"The array cannot be null\");\n        \n        final Map<Integer, Integer> frequency = new HashMap<>();\n\n        for (int num : nums) frequency.merge(num, 1, Integer::sum);\n\n        return Arrays.stream(nums)\n                .boxed()\n                .sorted((a, b) -> frequency.get(a).equals(frequency.get(b)) ? b - a : frequency.get(a) - frequency.get(b))\n                .mapToInt(n -> n)\n                .toArray();\n    }"
    }
  },
  {
    "title": "Largest Substring Between Two Equal Characters",
    "body": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\n\nA substring is a contiguous sequence of characters within a string.",
    "example": "Example 1:\n\nInput: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.\nExample 2:\n\nInput: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".\nExample 3:\n\nInput: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s.",
    "level": "easy",
    "solution": {
      "content": "public int maxLengthBetweenEqualCharacters(String s) {\n        Objects.requireNonNull(s, \"The sentence cannot be null\");\n\n        final int[] characters = new int[26];\n        \n        Arrays.fill(characters, -1);\n\n        int maxLength = -1;\n\n        for (int i = 0; i < s.length(); i++) {\n            final int charIndex = s.charAt(i) - 'a';\n\n            if (characters[charIndex] == -1) {\n                characters[charIndex] = i;\n            } else {\n                maxLength = Math.max(maxLength, i - characters[charIndex] - 1);\n            }\n        }\n\n        return maxLength;\n    }"
    }
  },
  {
    "title": "Number of Good Pairs",
    "body": "Given an array of integers nums, return the number of good pairs.\n\nA pair (i, j) is called good if nums[i] == nums[j] and i < j.",
    "example": "Example 1:\n\nInput: nums = [1,2,3,1,1,3]\nOutput: 4\nExplanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\nExample 2:\n\nInput: nums = [1,1,1,1]\nOutput: 6\nExplanation: Each pair in the array are good.\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 0",
    "level": "easy",
    "solution": {
      "content": "public int numIdenticalPairs(int[] nums) {\n        Objects.requireNonNull(nums, \"The array cannot be null\");\n        \n        if (nums.length < 1) {\n            throw new IllegalArgumentException(\"The array must contain minimum one element\");\n        }\n\n        final Map<Integer, Integer> frequency = new HashMap<>();\n\n        int pairs = 0;\n\n        for (int number : nums) {\n            pairs += frequency.getOrDefault(number, 0);\n            frequency.put(number, frequency.getOrDefault(number, 0) + 1);\n        }\n\n        return pairs;\n    }"
    }
  },
  {
    "title": "Destination City",
    "body": "You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.\n\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.",
    "example": "Example 1:\n\nInput: paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\nOutput: \"Sao Paulo\" \nExplanation: Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\".\nExample 2:\n\nInput: paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\nOutput: \"A\"\nExplanation: All possible trips are: \n\"D\" -> \"B\" -> \"C\" -> \"A\". \n\"B\" -> \"C\" -> \"A\". \n\"C\" -> \"A\". \n\"A\". \nClearly the destination city is \"A\".\nExample 3:\n\nInput: paths = [[\"A\",\"Z\"]]\nOutput: \"Z\"",
    "level": "easy",
    "solution": {
      "content": "public String destCity(List<List<String>> paths) {\n        final Set<String> cities = new HashSet<>();\n\n        for (List<String> path : paths) {\n            cities.add(path.getFirst());\n        }\n\n        for (int i = 0; ; i++) {\n            String destinationCity = paths.get(i).get(1);\n\n            if (!cities.contains(destinationCity)) {\n                return destinationCity;\n            }\n        }\n    }"
    }
  },
  {
    "title": "Make Two Arrays Equal by Reversing Subarrays",
    "body": "You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty subarray of arr and reverse it. You are allowed to make any number of steps.\n\nReturn true if you can make arr equal to target or false otherwise.",
    "example": "Example 1:\n\nInput: target = [1,2,3,4], arr = [2,4,1,3]\nOutput: true\nExplanation: You can follow the next steps to convert arr to target:\n1- Reverse subarray [2,4,1], arr becomes [1,4,2,3]\n2- Reverse subarray [4,2], arr becomes [1,2,4,3]\n3- Reverse subarray [4,3], arr becomes [1,2,3,4]\nThere are multiple ways to convert arr to target, this is not the only way to do so.\nExample 2:\n\nInput: target = [7], arr = [7]\nOutput: true\nExplanation: arr is equal to target without any reverses.\nExample 3:\n\nInput: target = [3,7,9], arr = [3,7,11]\nOutput: false\nExplanation: arr does not have value 9 and it can never be converted to target.\n",
    "level": "easy",
    "solution": {
      "content": "public boolean canBeEqual(int[] target, int[] arr) {\n        Arrays.sort(target);\n        Arrays.sort(arr);\n        return Arrays.equals(target, arr);\n    }"
    }
  },
  {
    "title": "Count Largest Group",
    "body": "You are given an integer n.\n\nWe need to group the numbers from 1 to n according to the sum of its digits. For example, the numbers 14 and 5 belong to the same group, whereas 13 and 3 belong to different groups.\n\nReturn the number of groups that have the largest size, i.e. the maximum number of elements.",
    "example": "Example 1:\n\nInput: n = 13\nOutput: 4\nExplanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].\nThere are 4 groups with largest size.\nExample 2:\n\nInput: n = 2\nOutput: 2\nExplanation: There are 2 groups [1], [2] of size 1.",
    "level": "easy",
    "solution": {
      "content": "public int countLargestGroup(int n) {\n        final int[] count = new int[40];\n        int max = 0;\n        int ans = 0;\n\n\n        for (int i = 1; i <= n; i++) {\n            int sum = 0;\n            int temp = i;\n\n            while (temp > 0) {\n                sum += temp % 10;\n                temp /= 10;\n            }\n            count[sum]++;\n\n            if (max < count[sum]) {\n                max = count[sum];\n                ans = 1;\n            } else if (max == count[sum]) {\n                ans++;\n            }\n        }\n        return ans;\n    }"
    }
  },
  {
    "title": "Find Lucky Integer in an Array",
    "body": "Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value.\n\nReturn the largest lucky integer in the array. If there is no lucky integer return -1.",
    "example": "Example 1:\n\nInput: arr = [2,2,3,4]\nOutput: 2\nExplanation: The only lucky number in the array is 2 because frequency[2] == 2.\nExample 2:\n\nInput: arr = [1,2,2,3,3,3]\nOutput: 3\nExplanation: 1, 2 and 3 are all lucky numbers, return the largest of them.\nExample 3:\n\nInput: arr = [2,2,2,3,3]\nOutput: -1\nExplanation: There are no lucky numbers in the array.",
    "level": "easy",
    "solution": {
      "content": "public int findLucky(int[] arr) {\n        Objects.requireNonNull(arr, \"The array cannot be null\");\n\n        if (arr.length < 1) {\n            throw new IllegalArgumentException(\"The array mus contain one element\");\n        }\n\n        final Map<Integer, Integer> frequency = new HashMap<>();\n\n        int luckyInteger = -1;\n\n        for (int number : arr) frequency.merge(number, 1, Integer::sum);\n\n        for (var bucket : frequency.entrySet()) {\n            final int key = bucket.getKey();\n            final int value = bucket.getValue();\n\n            if (key == value && key > luckyInteger) {\n                luckyInteger = key;\n            }\n        }\n\n        return luckyInteger;\n    }"
    }
  },
  {
    "title": "Increasing Decreasing String",
    "body": "You are given a string s. Reorder the string using the following algorithm:\n\nRemove the smallest character from s and append it to the result.\nRemove the smallest character from s that is greater than the last appended character, and append it to the result.\nRepeat step 2 until no more characters can be removed.\nRemove the largest character from s and append it to the result.\nRemove the largest character from s that is smaller than the last appended character, and append it to the result.\nRepeat step 5 until no more characters can be removed.\nRepeat steps 1 through 6 until all characters from s have been removed.\nIf the smallest or largest character appears more than once, you may choose any occurrence to append to the result.\n\nReturn the resulting string after reordering s using this algorithm.",
    "example": "Example 1:\n\nInput: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"\nExample 2:\n\nInput: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm.",
    "level": "easy",
    "solution": {
      "content": "public String sortString(String s) {\n        final int[] frequency = new int[26];\n\n        for (int i = 0; i < s.length(); i++) {\n            frequency[s.charAt(i) - 'a']++;\n        }\n\n        final StringBuilder result = new StringBuilder();\n\n        while (result.length() < s.length()) {\n\n            for (int i = 0; i < 26; i++) {\n                if (frequency[i] > 0) {\n                    result.append((char) ('a' + i));\n                    frequency[i]--;\n                }\n            }\n\n            for (int i = 25; i >= 0; i--) {\n                if (frequency[i] > 0) {\n                    result.append((char) ('a' + i));\n                    frequency[i]--;\n                }\n\n            }\n        }\n\n        return result.toString();\n    }"
    }
  },
  {
    "title": "Check If N and Its Double Exist",
    "body": "Given an array arr of integers, check if there exist two indices i and j such that :\n\ni != j\n0 <= i, j < arr.length\narr[i] == 2 * arr[j]",
    "example": "Example 1:\n\nInput: arr = [10,2,5,3]\nOutput: true\nExplanation: For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]\nExample 2:\n\nInput: arr = [3,1,7,11]\nOutput: false\nExplanation: There is no i and j that satisfy the conditions.",
    "level": "easy",
    "solution": {
      "content": "public boolean checkIfExist(int[] arr) {\n        final Set<Integer> set = new HashSet<>();\n\n        for (int number : arr) {\n            if (set.contains(number * 2) || (number % 2 == 0 && set.contains(number / 2))) {\n                return true;\n            }\n            set.add(number);\n        }\n        return false;\n    }"
    }
  },
  {
    "title": "How Many Numbers Are Smaller Than the Current Number",
    "body": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].\n\nReturn the answer in an array.",
    "example": "Example 1:\n\nInput: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2). \n Example 2:\n\nInput: nums = [6,5,4,8]\nOutput: [2,1,0,3]\nExample 3:\n\nInput: nums = [7,7,7,7]\nOutput: [0,0,0,0]",
    "level": "easy",
    "solution": {
      "content": "public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] cloneArray = nums.clone();\n\n        Arrays.sort(cloneArray);\n\n        for (int i = 0; i < cloneArray.length; i++) {\n            nums[i] = binarySearch(cloneArray, nums[i]);\n        }\n        return nums;\n    }\n\n    private int binarySearch(final int[] array, final int target) {\n        int left = 0;\n        int right = array.length;\n        int result = -1;\n        while (left < right) {\n            int middle = (left + right) / 2;\n            if (array[middle] >= target) {\n                result = middle;\n                right = middle;\n            } else if (array[middle] < target) {\n                left = middle + 1;\n            } else {\n                right = middle - 1;\n            }\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Maximum Number of Balloons",
    "body": "Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\n\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.",
    "example": "Input: text = \"nlaebolko\"\nOutput: 1 \n Input: text = \"loonbalxballpoon\"\nOutput: 2 \n Input: text = \"leetcode\"\nOutput: 0",
    "level": "easy",
    "solution": {
      "content": "public int maxNumberOfBalloons(String text) {\n        final int[] frequency = new int[26];\n        for (int i = 0; i < text.length(); i++) {\n            frequency[text.charAt(i) - 'a']++;\n        }\n\n        frequency['l' - 'a'] /= 2;\n        frequency['o' - 'a'] /= 2;\n\n        int maxNumber = Integer.MAX_VALUE;\n\n        for (char symbol : \"balon\".toCharArray()) {\n            maxNumber = Math.min(maxNumber, frequency[symbol - 'a']);\n        }\n\n        return maxNumber;\n    }"
    }
  },
  {
    "title": "Unique Number of Occurrences",
    "body": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.\n\n",
    "example": "Example 1:\n\nInput: arr = [1,2,2,1,1,3]\nOutput: true\nExplanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.\nExample 2:\n\nInput: arr = [1,2]\nOutput: false\nExample 3:\n\nInput: arr = [-3,0,1,-3,1,1,1,-3,10,0]\nOutput: true\n",
    "level": "easy",
    "solution": {
      "content": "public boolean uniqueOccurrences(int[] arr) {\n        final Map<Integer, Integer> frequencyNumbers = new HashMap<>();\n        final Set<Integer> uniqueElements = new HashSet<>();\n\n        for (int number : arr) frequencyNumbers.merge(number, 1, Integer::sum);\n\n        for (var bucket : frequencyNumbers.entrySet()) uniqueElements.add(bucket.getValue());\n\n        return frequencyNumbers.size() == uniqueElements.size();\n    }"
    }
  },
  {
    "title": "Rank Transform of an Array",
    "body": "Given an array of integers arr, replace each element with its rank.\n\nThe rank represents how large the element is. The rank has the following rules:\n\nRank is an integer starting from 1.\nThe larger the element, the larger the rank. If two elements are equal, their rank must be the same.\nRank should be as small as possible.",
    "example": "Example 1:\n\nInput: arr = [40,10,20,30]\nOutput: [4,1,2,3]\nExplanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.\nExample 2:\n\nInput: arr = [100,100,100]\nOutput: [1,1,1]\nExplanation: Same elements share the same rank.\nExample 3:\n\nInput: arr = [37,12,28,9,100,56,80,5,12]\nOutput: [5,3,4,2,8,6,7,1,3]",
    "level": "easy",
    "solution": {
      "content": "public int[] arrayRankTransform(int[] arr) {\n        final int[] cloneArray = arr.clone();\n\n        Arrays.sort(cloneArray);\n\n        int count = 0;\n\n        for (int i = 0; i < arr.length; i++) {\n            if (i == 0 || cloneArray[i] != cloneArray[i - 1]) {\n                cloneArray[count++] = cloneArray[i];\n            }\n        }\n\n        final int[] result = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            result[i] = Arrays.binarySearch(cloneArray, 0, count, arr[i]) + 1;\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "Relative Sort Array",
    "body": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\n\nSort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.",
    "example": "Example 1:\n\nInput: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\nOutput: [2,2,2,1,4,3,3,9,6,7,19]\nExample 2:\n\nInput: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]\nOutput: [22,28,8,6,17,44]\n",
    "level": "easy",
    "solution": {
      "content": "public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        final Map<Integer, Integer> hasMap = new HashMap<>();\n\n        for (int i = 0; i < arr2.length; i++) {\n            hasMap.put(arr2[i], i);\n        }\n\n        final int[][] elementsArray = new int[arr1.length][2];\n\n        for (int i = 0; i < arr1.length; i++) {\n            elementsArray[i] = new int[]{\n                    arr1[i],\n                    hasMap.getOrDefault(arr1[i], arr2.length + arr1[i])\n            };\n        }\n\n        Arrays.sort(elementsArray, (a, b) -> a[1] - b[1]);\n\n        for (int i = 0; i < elementsArray.length; i++) {\n            arr1[i] = elementsArray[i][0];\n        }\n\n        return arr1;\n    }"
    }
  },
  {
    "title": "Find Words That Can Be Formed by Characters",
    "body": "You are given an array of strings words and a string chars.\n\nA string is good if it can be formed by characters from chars (each character can only be used once for each word in words).\n\nReturn the sum of lengths of all good strings in words.",
    "example": "Example 1:\n\nInput: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.\nExample 2:\n\nInput: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10.",
    "level": "easy",
    "solution": {
      "content": "public int countCharacters(String[] words, String chars) {\n      int[] frequencyLetters = new int[26];\n        for (int i = 0; i < chars.length(); i++) {\n            frequencyLetters[chars.charAt(i) - 'a']++;\n        }\n\n        int total = 0;\n\n        for (String word : words) {\n            int[] count = new int[26];\n            boolean canFormWord = true;\n\n            for (int i = 0; i < word.length(); i++) {\n                final int index = word.charAt(i) - 'a';\n                count[index]++;\n\n                if (count[index] > frequencyLetters[index]) {\n                    canFormWord = false;\n                    break;\n                }\n            }\n            if (canFormWord) {\n                total += word.length();\n            }\n        }\n\n        return total;  \n    }"
    }
  },
  {
    "title": "Distribute Candies",
    "body": "Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.\n\nThe doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\n\nGiven the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.\n\n",
    "example": "Example 1:\n\nInput: candyType = [1,1,2,2,3,3]\nOutput: 3\nExplanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.\nExample 2:\n\nInput: candyType = [1,1,2,3]\nOutput: 2\nExplanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.\nExample 3:\n\nInput: candyType = [6,6,6,6]\nOutput: 1\nExplanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.",
    "level": "easy",
    "solution": {
      "content": "public int distributeCandies(int[] candyType) {\n        Objects.requireNonNull(candyType, \"The array cannot be null\");\n\n        if (candyType.length < 2) {\n            throw new IllegalArgumentException(\"The array must contain at least two elements.\");\n        }\n\n        final Set<Integer> uniqCandyType = new HashSet<>();\n\n        for (int candy : candyType) uniqCandyType.add(candy);\n\n        int doctorLimit = candyType.length / 2;\n\n        return Math.min(uniqCandyType.size(), doctorLimit);\n    }"
    }
  },
  {
    "title": "Intersection of Two Linked Lists",
    "body": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. The test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\nNote that the linked lists must retain their original structure after the function returns.\n\nCustom Judge:\n\nThe inputs to the judge are given as follows (your program is not given these inputs):\n\nintersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.\nlistA - The first linked list.\nlistB - The second linked list.\nskipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.\nskipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.\nThe judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.",
    "example": "Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\nOutput: Intersected at '8'\nExplanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory. \n Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\nOutput: Intersected at '2'\nExplanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.",
    "level": "easy",
    "solution": {
      "content": "public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode left = headA;\n        ListNode right = headB;\n\n        while (left != right) {\n            left = (left == null) ? headB : left.next;\n            right = (right == null) ? headA : right.next;\n        }\n\n        return left;\n    }"
    }
  },
  {
    "title": "Delete Columns to Make Sorted",
    "body": "You are given an array of n strings strs, all of the same length.\n\nThe strings can be arranged such that there is one on each line, making a grid.\n\nFor example, strs = [\"abc\", \"bce\", \"cae\"] can be arranged as follows:\nabc\nbce\ncae\nYou want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1.\n\nReturn the number of columns that you will delete.",
    "example": "Example 1:\n\nInput: strs = [\"cba\",\"daf\",\"ghi\"]\nOutput: 1\nExplanation: The grid looks as follows:\n  cba\n  daf\n  ghi\nColumns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.\nExample 2:\n\nInput: strs = [\"a\",\"b\"]\nOutput: 0\nExplanation: The grid looks as follows:\n  a\n  b\nColumn 0 is the only column and is sorted, so you will not delete any columns.\nExample 3:\n\nInput: strs = [\"zyx\",\"wvu\",\"tsr\"]\nOutput: 3\nExplanation: The grid looks as follows:\n  zyx\n  wvu\n  tsr\nAll 3 columns are not sorted, so you will delete all 3.",
    "level": "easy",
    "solution": {
      "content": "public int minDeletionSize(String[] strs) {\n        final int columnCount = strs[0].length();\n        final int rowCount = strs.length;\n        int deleteCount = 0;\n        for (int i = 0; i < columnCount; i++) {\n            for (int j = 1; j < rowCount; j++) {\n                if (strs[j].charAt(i) < strs[j - 1].charAt(i)) {\n                    deleteCount++;\n                    break;\n                }\n            }\n        }\n        return deleteCount;\n    }"
    }
  },
  {
    "title": "Verifying an Alien Dictionary",
    "body": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\n\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.\n\n",
    "example": "Example 1:\n\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\nOutput: true\nExplanation: As 'h' comes before 'l' in this language, then the sequence is sorted.\nExample 2:\n\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\nOutput: false\nExplanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.\nExample 3:\n\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\nOutput: false\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '', where '' is defined as the blank character which is less than any other character (More info).",
    "level": "easy",
    "solution": {
      "content": "public boolean isAlienSorted(String[] words, String order) {\n       final int[] frequency = new int[26];\n\n        for (int i = 0; i < 26; i++) {\n            frequency[order.charAt(i) - 'a'] = i;\n        }\n\n        for (int j = 0; j < 20; j++) {\n            int previousChar = -1;\n            boolean charsDifferent = true;\n\n            for (String word : words) {\n                final int current = j >= word.length() ? -1 : frequency[word.charAt(j) - 'a'];\n\n                if (previousChar > current) {\n                    return false;\n                }\n\n                if (previousChar == current) {\n                    charsDifferent = false;\n                }\n\n                previousChar = current;\n            }\n\n            if (charsDifferent) {\n                break;\n            }\n        }\n\n        return true; \n    }"
    }
  },
  {
    "title": "Find Common Characters",
    "body": "Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.",
    "example": "Example 1:\n\nInput: words = [\"bella\",\"label\",\"roller\"]\nOutput: [\"e\",\"l\",\"l\"]\nExample 2:\n\nInput: words = [\"cool\",\"lock\",\"cook\"]\nOutput: [\"c\",\"o\"]",
    "level": "easy",
    "solution": {
      "content": "public List<String> commonChars(String[] words) {\n        final int[] frequency = new int[26];\n        Arrays.fill(frequency, Integer.MAX_VALUE);\n        final List<String> list = new ArrayList<>();\n\n        for (String word : words) {\n            final int[] currentWordFrequency = new int[26];\n\n            for (int i = 0; i < word.length(); i++) {\n                currentWordFrequency[word.charAt(i) - 'a']++;\n            }\n\n            for (int i = 0; i < 26; i++) {\n                frequency[i] = Math.min(currentWordFrequency[i], frequency[i]);\n            }\n        }\n\n        for (int i = 0; i < 26; i++) {\n            list.addAll(Collections.nCopies(frequency[i], String.valueOf((char)('a' + i))));\n        }\n\n        return list;\n    }"
    }
  },
  {
    "title": "Happy Number",
    "body": "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the following process:\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\nRepeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\nThose numbers for which this process ends in 1 are happy.\nReturn true if n is a happy number, and false if not.",
    "example": "Example 1:\n\nInput: n = 19\nOutput: true\nExplanation:\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\nExample 2:\n\nInput: n = 2\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "public boolean isHappy(int n) {\n        final Set<Integer> set = new HashSet<>();\n\n        while (n != 1 && !set.contains(n)) {\n            set.add(n);\n\n            int sum = 0;\n\n            while (n != 0) {\n                int digit = n % 10;\n\n                sum += (int) Math.pow(digit, 2);\n\n                n /= 10;\n            }\n            n = sum;\n        }\n        return n == 1;\n    }"
    }
  },
  {
    "title": "Buddy Strings",
    "body": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\n\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".",
    "example": "Example 1:\n\nInput: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.\nExample 2:\n\nInput: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.\nExample 3:\n\nInput: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal.",
    "level": "easy",
    "solution": {
      "content": "public boolean buddyStrings(String s, String goal) {\n       if (s.length() != goal.length()) {\n            return false;\n        }\n\n        int differentCount = 0;\n        int[] frequencyS = new int[26];\n        int[] frequencyGoal = new int[26];\n\n        for (int i = 0; i < s.length(); ++i) {\n            final char currentCharacter = s.charAt(i);\n            final char goalCharacter = goal.charAt(i);\n            ++frequencyS[currentCharacter - 'a'];\n            ++frequencyGoal[goalCharacter - 'a'];\n\n            if (currentCharacter != goalCharacter) {\n                differentCount++;\n            }\n        }\n\n        boolean hasDuplicates = false;\n\n        for (int i = 0; i < 26; ++i) {\n            if (frequencyS[i] != frequencyGoal[i]) {\n                return false;\n            }\n\n            if (frequencyS[i] > 1) {\n                hasDuplicates = true;\n            }\n        }\n\n        return differentCount == 2 || (differentCount == 0 && hasDuplicates);\n    }"
    }
  },
  {
    "title": " Unique Email Addresses",
    "body": "Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'.\n\nFor example, in \"alice@leetcode.com\", \"alice\" is the local name, and \"leetcode.com\" is the domain name.\nIf you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.\n\nFor example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\nIf you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.\n\nFor example, \"m.y+name@email.com\" will be forwarded to \"my@email.com\".\nIt is possible to use both of these rules at the same time.\n\nGiven an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.",
    "example": "Example 1:\n\nInput: emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\nOutput: 2\nExplanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails.\nExample 2:\n\nInput: emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]\nOutput: 3",
    "level": "easy",
    "solution": {
      "content": "public int numUniqueEmails(String[] emails) {\n        final Set<String> uniqEmails = new HashSet<>();\n\n        for (String email : emails) {\n            final String[] split = email.split(\"@\");\n            final String localName = split[0];\n            final String domainName = split[1];\n\n            final StringBuilder localNameAfterParse = new StringBuilder();\n            for (char name : localName.toCharArray()) {\n                if (name == '.') {\n                    continue;\n                } else if (name == '+') {\n                    break;\n                }\n\n                localNameAfterParse.append(name);\n            }\n            final String normalEmail = localNameAfterParse + \"@\" + domainName;\n            uniqEmails.add(normalEmail);\n\n        }\n        return uniqEmails.size();\n    }"
    }
  },
  {
    "title": "DI String Match",
    "body": "A permutation perm of n + 1 integers of all the integers in the range [0, n] can be represented as a string s of length n where:\n\ns[i] == 'I' if perm[i] < perm[i + 1], and\ns[i] == 'D' if perm[i] > perm[i + 1].\nGiven a string s, reconstruct the permutation perm and return it. If there are multiple valid permutations perm, return any of them.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public int[] diStringMatch(String s) {\n        final int length = s.length();\n        int smallestNumber = 0;\n        int largestNumber = length;\n\n        final int[] result = new int[length + 1];\n        for (int i = 0; i < length; i++) {\n            if (s.charAt(i) == 'I') {\n                result[i] = smallestNumber;\n                smallestNumber++;\n            } else {\n                result[i] = largestNumber;\n                largestNumber--;\n            }\n        }\n        result[length] = smallestNumber;\n        return result;\n    }"
    }
  },
  {
    "title": "Uncommon Words from Two Sentences",
    "body": "A sentence is a string of single-space separated words where each word consists only of lowercase letters.\n\nA word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.\n\nGiven two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.",
    "example": "Example 1:\n\nInput: s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n\nOutput: [\"sweet\",\"sour\"]\n\nExplanation:\n\nThe word \"sweet\" appears only in s1, while the word \"sour\" appears only in s2.\n\nExample 2:\n\nInput: s1 = \"apple apple\", s2 = \"banana\"\n\nOutput: [\"banana\"]",
    "level": "easy",
    "solution": {
      "content": "public String[] uncommonFromSentences(String s1, String s2) {\n        final Map<String, Integer> frequencyWordsFirstString = new HashMap<>();\n\n        Objects.requireNonNull(s1, \"The sentence cannot be null\");\n\n        Objects.requireNonNull(s2, \"The sentence cannot be null\");\n\n        final String firstTrimmed = trimmed(s1);\n        final String secondTrimmed = trimmed(s2);\n\n        checkSentence(firstTrimmed);\n\n        checkSentence(secondTrimmed);\n\n        lettersCheck(firstTrimmed);\n\n        lettersCheck(secondTrimmed);\n\n         for (final String word : (firstTrimmed + \" \" + secondTrimmed).split(\"\\\\s+\"))\n            frequencyWordsFirstString.merge(word, 1, Integer::sum);\n            \n        final List<String> uncommonWords = new ArrayList<>();\n\n        for (Map.Entry<String, Integer> item : frequencyWordsFirstString.entrySet()) {\n            if (item.getValue() == 1) {\n                uncommonWords.add(item.getKey());\n            }\n        }\n\n        return uncommonWords.toArray(new String[0]);\n    }\n\n    private static String trimmed(final String text) {\n        return text.trim();\n    }\n\n    private static void checkSentence(final String text) {\n        if (text.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence is empty or contains only whitespace.\");\n        }\n    }\n\n    private static void lettersCheck(final String text) {\n        boolean hasLetter = text.chars().anyMatch(Character::isAlphabetic);\n\n        if (!hasLetter) {\n            throw new IllegalArgumentException(\"The sentence contains no letters\");\n        }\n    }"
    }
  },
  {
    "title": "Reverse Only Letters",
    "body": "Given a string s, reverse the string according to the following rules:\n\nAll the characters that are not English letters remain in the same position.\nAll the English letters (lowercase or uppercase) should be reversed.\nReturn s after reversing it.",
    "example": "Example 1:\n\nInput: s = \"ab-cd\"\nOutput: \"dc-ba\"\nExample 2:\n\nInput: s = \"a-bC-dEf-ghIj\"\nOutput: \"j-Ih-gfE-dCba\"\nExample 3:\n\nInput: s = \"Test1ng-Leet=code-Q!\"\nOutput: \"Qedo1ct-eeLg=ntse-T!\"",
    "level": "easy",
    "solution": {
      "content": "public String reverseOnlyLetters(String s) {\n        char[] chars = s.toCharArray();\n        int left = 0;\n        int right = chars.length - 1;\n\n        while (left < right) {\n            while (left < right && !Character.isLetter(chars[left])) {\n                left++;\n            }\n\n            while (left < right && !Character.isLetter(chars[right])) {\n                right--;\n            }\n            if (left < right) {\n                char temp = chars[left];\n                chars[left] = chars[right];\n                chars[right] = temp;\n            }\n            left++;\n            right--;\n        }\n        return new String(chars);\n    }"
    }
  },
  {
    "title": "Long Pressed Name",
    "body": "Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.\n\nYou examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.",
    "example": "Example 1:\n\nInput: name = \"alex\", typed = \"aaleex\"\nOutput: true\nExplanation: 'a' and 'e' in 'alex' were long pressed.\nExample 2:\n\nInput: name = \"saeed\", typed = \"ssaaedd\"\nOutput: false\nExplanation: 'e' must have been pressed twice, but it was not in the typed output.",
    "level": "easy",
    "solution": {
      "content": "public boolean isLongPressedName(String name, String typed) {\n        int i = 0;\n        int j = 0;\n        int n = name.length();\n        int t = typed.length();\n\n        while (i < n && j < t) {\n            if (name.charAt(i) != typed.charAt(j)) {\n                return false;\n            }\n\n            int x = i + 1;\n            while (x < n && name.charAt(x) == name.charAt(i)) {\n                x++;\n            }\n\n            int y = j + 1;\n\n            while (y < t && typed.charAt(y) == typed.charAt(j)) {\n                y++;\n            }\n\n            int sizeX = x - i;\n            int sizeY = y - j;\n\n            if (sizeX > sizeY) {\n                return false;\n            }\n            i = x;\n            j = y;\n        }\n\n        return i == name.length() && j == typed.length();\n    }"
    }
  },
  {
    "title": "Shortest Distance to a Character",
    "body": "Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\n\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.",
    "example": "Example 1:\n\nInput: s = \"loveleetcode\", c = \"e\"\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2.\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\nExample 2:\n\nInput: s = \"aaab\", c = \"b\"\nOutput: [3,2,1,0]",
    "level": "easy",
    "solution": {
      "content": "public int[] shortestToChar(String s, char c) {\n        final int len = s.length();\n\n        final int[] ans = new int[len];\n\n        ans[0] = s.charAt(0) == c ? 0 : 10001;\n\n        for (int i = 1; i < len; i++)\n            ans[i] = s.charAt(i) == c ? 0 : ans[i - 1] + 1;\n\n        for (int i = len - 2; i >= 0; i--)\n            ans[i] = Math.min(ans[i], ans[i + 1] + 1);\n\n        return ans;\n    }"
    }
  },
  {
    "title": "Backspace String Compare",
    "body": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty.",
    "example": "Example 1:\n\nInput: s = \"ab#c\", t = \"ad#c\"\nOutput: true\nExplanation: Both s and t become \"ac\".\nExample 2:\n\nInput: s = \"ab##\", t = \"c#d#\"\nOutput: true\nExplanation: Both s and t become \"\".\nExample 3:\n\nInput: s = \"a#c\", t = \"b\"\nOutput: false\nExplanation: s becomes \"c\" while t becomes \"b\".\n",
    "level": "easy",
    "solution": {
      "content": "public boolean backspaceCompare(String s, String t) {\n        int i = s.length() - 1;\n        int j = t.length() - 1;\n\n        int skip1 = 0;\n        int skip2 = 0;\n\n        while (i >= 0 || j >= 0) {\n            while (i >= 0) {\n                if (s.charAt(i) == '#') {\n                    skip1++;\n                    i--;\n                } else if (skip1 > 0) {\n                    skip1--;\n                    i--;\n                } else {\n                    break;\n                }\n            }\n\n            while (j >= 0) {\n                if (t.charAt(j) == '#') {\n                    skip2++;\n                    j--;\n                } else if (skip2 > 0) {\n                    skip2--;\n                    j--;\n                } else {\n                    break;\n                }\n            }\n\n            if (i >= 0 && j >= 0) {\n                if (s.charAt(i) != t.charAt(j)) {\n                    return false;\n                }\n            } else if (i >= 0 || j >= 0) {\n                return false;\n            }\n\n            i--;\n            j--;\n        }\n        return true;\n    }"
    }
  },
  {
    "title": "Move values A and B",
    "body": "There are 2 variables and you need to swap the values in different ways",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class A {\n    public static void main(String[] args) {\n        int a = 5;\n        int b = 10;\n}"
    }
  },
  {
    "title": "Remove a smile",
    "body": "There are messages from the social network, for example:\n\"I work at Google :-)))\"",
    "example": "I want to remove emoticons from messages that fall under the regular schedule \":-\\)+|:-\\(+\" in linear time.  That is, to do so:  \"I work at Google :-)))\" -> \"I work at Google \"\n\"lucky :-) and I failed the interview there:-((\" -> \"lucky and I\nfailed the interview there\"\n\"lol:)\" - >\"lol:)\"\n\"Aaaaa!!!!! :-))(())\" -> \" Aaaaa!!!!! (())\"\"",
    "level": "easy",
    "solution": {
      "content": ""
    }
  },
  {
    "title": "Most Common Word",
    "body": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\n\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\n\nNote that words can not contain punctuation symbols.",
    "example": "Example 1:\n\nInput: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation: \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.\nExample 2:\n\nInput: paragraph = \"a.\", banned = []\nOutput: \"a\"",
    "level": "easy",
    "solution": {
      "content": "public String mostCommonWord(String paragraph, String[] banned) {\n        Objects.requireNonNull(paragraph, \"The sentence cannot be null\");\n\n        Objects.requireNonNull(banned, \"The array cannot be null\");\n\n\n        final Map<String, Integer> frequency = new TreeMap<>();\n\n        final Set<String> set = new HashSet<>(Arrays.asList(banned));\n\n        for (String word : paragraph.toLowerCase().split(\"\\\\W+\")) {\n            if (!set.contains(word)) {\n                frequency.merge(word, 1, Integer::sum);\n            }\n        }\n\n        int maxFrequency = Integer.MIN_VALUE;\n        String mostCommonWord = null;\n\n        for (Map.Entry<String, Integer> frequencyWord : frequency.entrySet()) {\n            if (frequencyWord.getValue() > maxFrequency) {\n                maxFrequency = frequencyWord.getValue();\n                mostCommonWord = frequencyWord.getKey();\n            }\n        }\n\n        return mostCommonWord;\n    }"
    }
  },
  {
    "title": "Uniq Number",
    "body": "An array of numbers is given in which all numbers except one have a pair (occur twice). \n Find a number that occurs only once",
    "example": "[1, 0, 3, -2, 9, 9, 1, -2, 0]  => 3",
    "level": "easy",
    "solution": {
      "content": "int find(int[] arr) {}"
    }
  },
  {
    "title": "The team leader's problem",
    "body": "Write a function that, based on a given set of meeting intervals, returns whether it is possible to attend all meetings without intersections.",
    "example": "Input: [[1,4], [2,5], [7,9]]   Output: false",
    "level": "easy",
    "solution": {
      "content": "public class TeamLeadTask {\n    public static boolean canAttendAllMeetings(int[][] intervals) {\n  return false;\n    }\n}"
    }
  },
  {
    "title": "To Lower Case",
    "body": "Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.\n\n",
    "example": "Example 1:\n\nInput: s = \"Hello\"\nOutput: \"hello\"\nExample 2:\n\nInput: s = \"here\"\nOutput: \"here\"\nExample 3:\n\nInput: s = \"LOVELY\"\nOutput: \"lovely\"",
    "level": "easy",
    "solution": {
      "content": "public String toLowerCase(String s) {\n         return s.toLowerCase();\n    }"
    }
  },
  {
    "title": "Shortest Completing Word",
    "body": "Given a string licensePlate and an array of strings words, find the shortest completing word in words.\n\nA completing word is a word that contains all the letters in licensePlate. Ignore numbers and spaces in licensePlate, and treat letters as case insensitive. If a letter appears more than once in licensePlate, then it must appear in the word the same number of times or more.\n\nFor example, if licensePlate = \"aBc 12c\", then it contains letters 'a', 'b' (ignoring case), and 'c' twice. Possible completing words are \"abccdef\", \"caaacab\", and \"cbca\".\n\nReturn the shortest completing word in words. It is guaranteed an answer exists. If there are multiple shortest completing words, return the first one that occurs in words.\n\n",
    "example": "Example 1:\n\nInput: licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]\nOutput: \"steps\"\nExplanation: licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'.\n\"step\" contains 't' and 'p', but only contains 1 's'.\n\"steps\" contains 't', 'p', and both 's' characters.\n\"stripe\" is missing an 's'.\n\"stepple\" is missing an 's'.\nSince \"steps\" is the only word containing all the letters, that is the answer.\nExample 2:\n\nInput: licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]\nOutput: \"pest\"\nExplanation: licensePlate only contains the letter 's'. All the words contain 's', but among these \"pest\", \"stew\", and \"show\" are shortest. The answer is \"pest\" because it is the word that appears earliest of the 3.",
    "level": "easy",
    "solution": {
      "content": "public String shortestCompletingWord(String licensePlate, String[] words) {\n        Objects.requireNonNull(licensePlate, \"The sentence cannot be null\");\n        Objects.requireNonNull(words, \"The array cannot be null\");\n\n        if (licensePlate.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence cannot be is empty\");\n        }\n\n        final String trimmed = licensePlate.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains spaces only\");\n        }\n\n        final int[] frequencyLettersInLicensePLate = new int[26];\n\n        for (int i = 0; i < trimmed.length(); i++) {\n            final char currentCharacter = trimmed.charAt(i);\n            if (Character.isLetter(currentCharacter)) {\n                frequencyLettersInLicensePLate[Character.toLowerCase(currentCharacter) - 'a']++;\n            }\n        }\n\n        String shortestWord = \"\";\n\n        for (String word : words) {\n            if (!shortestWord.isEmpty() && word.length() >= shortestWord.length()) {\n                continue;\n            }\n\n            final int[] frequencyLettersInWord = new int[26];\n\n            for (int i = 0; i < word.length(); i++) {\n                frequencyLettersInWord[word.charAt(i) - 'a']++;\n            }\n\n            boolean isCompletingWord = true;\n\n            for (int i = 0; i < 26; i++) {\n                if (frequencyLettersInWord[i] < frequencyLettersInLicensePLate[i]) {\n                    isCompletingWord = false;\n                    break;\n                }\n            }\n            if (isCompletingWord) {\n                shortestWord = word;\n            }\n        }\n\n\n        return shortestWord;\n    }"
    }
  },
  {
    "title": "Jewels and Stones",
    "body": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\n\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".",
    "example": "Example 1:\n\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\nOutput: 3\nExample 2:\n\nInput: jewels = \"z\", stones = \"ZZ\"\nOutput: 0",
    "level": "easy",
    "solution": {
      "content": "public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n        for (int i = 0; i < jewels.length(); i++) {\n            final char currentStone = jewels.charAt(i);\n\n            for (int j = 0; j < stones.length(); j++) {\n                final char currentCharacter = stones.charAt(j);\n\n                if (currentStone == currentCharacter) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }"
    }
  },
  {
    "title": "Rotate String",
    "body": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\n\nA shift on s consists of moving the leftmost character of s to the rightmost position.\n\nFor example, if s = \"abcde\", then it will be \"bcdea\" after one shift.",
    "example": "Example 1:\n\nInput: s = \"abcde\", goal = \"cdeab\"\nOutput: true\nExample 2:\n\nInput: s = \"abcde\", goal = \"abced\"\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "public boolean rotateString(String s, String goal) {\n        return s.length() == goal.length() && (s + s).contains(goal);\n    }"
    }
  },
  {
    "title": "Count Binary Substrings",
    "body": "Given a binary string s, return the number of non-empty substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.",
    "example": "Example 1:\n\nInput: s = \"00110011\"\nOutput: 6\nExplanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\nExample 2:\n\nInput: s = \"10101\"\nOutput: 4\nExplanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.",
    "level": "easy",
    "solution": {
      "content": "public int countBinarySubstrings(String s) {\n        Objects.requireNonNull(s, \"The sentence cannot be null\");\n\n        if (s.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence cannot be is empty\");\n        }\n\n        final String trimmed = s.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains spaces only\");\n        }\n\n        final boolean hasDigits = trimmed.chars().anyMatch(Character::isDigit);\n\n        if (!hasDigits) {\n            throw new IllegalArgumentException(\"The sentence contains no digits\");\n        }\n\n        int i = 0;\n        int j = s.length();\n        List<Integer> list = new ArrayList<>();\n\n        while (i < j) {\n            int count = 1;\n\n            while (i + 1 < j && s.charAt(i + 1) == s.charAt(i)) {\n                count++;\n                i++;\n            }\n            list.add(count);\n            i++;\n        }\n\n        int result = 0;\n\n        for (int k = 1; k < list.size(); k++) {\n            result += Math.min(list.get(k - 1), list.get(k));\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "Reverse String II",
    "body": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\n\nIf there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.",
    "example": "Example 1:\n\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\nExample 2:\n\nInput: s = \"abcd\", k = 2\nOutput: \"bacd\"",
    "level": "easy",
    "solution": {
      "content": "public String reverseStr(String s, int k) {\n        final char[] charArray = s.toCharArray();\n\n        for (int start = 0; start < charArray.length; start += k * 2) {\n            int left = start;\n            int right = Math.min(start + k - 1, s.length() - 1);\n\n            while (left < right) {\n                final char temp = charArray[left];\n                charArray[left] = charArray[right];\n                charArray[right] = temp;\n\n                left++;\n                right--;\n            }\n        }\n\n        return new String(charArray);\n    }"
    }
  },
  {
    "title": "Student Attendance Record I",
    "body": "You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n'A': Absent.\n'L': Late.\n'P': Present.\nThe student is eligible for an attendance award if they meet both of the following criteria:\n\nThe student was absent ('A') for strictly fewer than 2 days total.\nThe student was never late ('L') for 3 or more consecutive days.\nReturn true if the student is eligible for an attendance award, or false otherwise.",
    "example": "Example 1:\n\nInput: s = \"PPALLP\"\nOutput: true\nExplanation: The student has fewer than 2 absences and was never late 3 or more consecutive days.\nExample 2:\n\nInput: s = \"PPALLL\"\nOutput: false\nExplanation: The student was late 3 consecutive days in the last 3 days, so is not eligible for the award.",
    "level": "easy",
    "solution": {
      "content": "public boolean checkRecord(String s) {\n       if (s.length() < 1) {\n            throw new IllegalArgumentException(\"The sentence must contain at least two words.\");\n        }\n\n        final var trimmed = s.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        boolean hasLetter = trimmed.chars().anyMatch(Character::isAlphabetic);\n\n        if (!hasLetter) {\n            throw new IllegalArgumentException(\"The sentence contains no letters\");\n        }\n\n        final boolean isAbsent = s.indexOf('A') == s.lastIndexOf('A');\n        final boolean isLate = !s.contains(\"LLL\");\n\n        return isAbsent && isLate; \n    }"
    }
  },
  {
    "title": "Reverse Words in a String III",
    "body": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.",
    "example": "Example 1:\n\nInput: s = \"Let's take LeetCode contest\"\nOutput: \"s'teL ekat edoCteeL tsetnoc\"\nExample 2:\n\nInput: s = \"Mr Ding\"\nOutput: \"rM gniD\"",
    "level": "easy",
    "solution": {
      "content": "public String reverseWords(String s) {\n        if (s.length() < 2) {\n            throw new IllegalArgumentException(\"The sentence must contain at least two words.\");\n        }\n\n        final var trimmed = s.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n        \n        final String[] splittedString = s.split(\" \");\n\n        for (int i = 0; i < splittedString.length; i++) {\n            splittedString[i] = new StringBuilder(splittedString[i]).reverse().toString();\n        }\n\n        return String.join(\" \", splittedString);\n    }"
    }
  },
  {
    "title": "Longest Uncommon Subsequence",
    "body": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If no such uncommon subsequence exists, return -1.\n\nAn uncommon subsequence between two strings is a string that is a subsequence of exactly one of them.\n\n",
    "example": "Example 1:\n\nInput: a = \"aba\", b = \"cdc\"\nOutput: 3\nExplanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".\nNote that \"cdc\" is also a longest uncommon subsequence.\nExample 2:\n\nInput: a = \"aaa\", b = \"bbb\"\nOutput: 3\nExplanation: The longest uncommon subsequences are \"aaa\" and \"bbb\".\nExample 3:\n\nInput: a = \"aaa\", b = \"aaa\"\nOutput: -1\nExplanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. So the answer would be -1.",
    "level": "easy",
    "solution": {
      "content": "public int findLUSlength(String a, String b) {\n        return Objects.equals(a, b) ? -1 : Math.max(a.length(), b.length());\n    }"
    }
  },
  {
    "title": "Reverse String II",
    "body": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\n\nIf there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.",
    "example": "Example 1:\n\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\nExample 2:\n\nInput: s = \"abcd\", k = 2\nOutput: \"bacd\"",
    "level": "easy",
    "solution": {
      "content": "public String reverseStr(String s, int k) {\n        final char[] charArray = s.toCharArray();\n\n        for (int start = 0; start < charArray.length; start += k * 2) {\n            int left = start;\n            int right = Math.min(start + k - 1, s.length() - 1);\n\n            while (left < right) {\n                final char temp = charArray[left];\n                charArray[left] = charArray[right];\n                charArray[right] = temp;\n\n                left++;\n                right--;\n            }\n        }\n\n        return new String(charArray);\n    }"
    }
  },
  {
    "title": "Detect Capital",
    "body": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll letters in this word are capitals, like \"USA\".\nAll letters in this word are not capitals, like \"leetcode\".\nOnly the first letter in this word is capital, like \"Google\".\nGiven a string word, return true if the usage of capitals in it is right.",
    "example": "Example 1:\n\nInput: word = \"USA\"\nOutput: true\nExample 2:\n\nInput: word = \"FlaG\"\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "public boolean detectCapitalUse(String word) {\n        if (word.length() == 1 || word.length() == 0) {\n            return true;\n        }\n        \n        int upperCase = 0;\n\n        int lowerCase = 0;\n\n        for (int i = 0; i < word.length(); i++) {\n            char currentCharacter = word.charAt(i);\n            if (Character.isUpperCase(currentCharacter)) {\n                upperCase++;\n            } else if (!Character.isUpperCase(currentCharacter)) {\n                lowerCase++;\n            }\n        }\n\n        if (Character.isUpperCase(word.charAt(0)) && lowerCase == word.length() - 1) {\n            return true;\n        }\n\n        return upperCase == word.length() || lowerCase == word.length();\n    }"
    }
  },
  {
    "title": "License Key Formatting",
    "body": "You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.\n\nWe want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\n\nReturn the reformatted license key.",
    "example": "Example 1:\n\nInput: s = \"5F3Z-2e-9-w\", k = 4\nOutput: \"5F3Z-2E9W\"\nExplanation: The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\nExample 2:\n\nInput: s = \"2-5g-3-J\", k = 2\nOutput: \"2-5G-3J\"\nExplanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.",
    "level": "easy",
    "solution": {
      "content": "public String licenseKeyFormatting(String s, int k) {\n        final int length = s.length();\n        final int dashCount = (int) s.chars().filter(ch -> ch == '-').count();\n        final int alphaNumeric = length - dashCount;\n\n        int firstGroup = alphaNumeric % k;\n\n        if (firstGroup == 0) {\n            firstGroup = k;\n        }\n\n        StringBuilder result = new StringBuilder();\n        int currentGroup = firstGroup;\n\n        for (int i = 0; i < s.length(); i++) {\n            final char currentCharacter = s.charAt(i);\n\n            if (currentCharacter == '-') {\n                continue;\n            }\n\n            result.append(Character.toUpperCase(currentCharacter));\n            currentGroup--;\n\n            if (currentGroup == 0) {\n                currentGroup = k;\n\n                if (i != length - 1) {\n                    result.append('-');\n                }\n            }\n        }\n\n        if (!result.isEmpty() && result.charAt(result.length() - 1) == '-') {\n            result.deleteCharAt(result.length() - 1);\n        }\n        return result.toString();\n    }"
    }
  },
  {
    "title": "Repeated Substring Pattern",
    "body": "Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\n\n",
    "example": "Example 1:\n\nInput: s = \"abab\"\nOutput: true\nExplanation: It is the substring \"ab\" twice.\nExample 2:\n\nInput: s = \"aba\"\nOutput: false\nExample 3:\n\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.",
    "level": "easy",
    "solution": {
      "content": "public boolean repeatedSubstringPattern(String s) {\n        final String concatStrings = s + s;\n\n        return concatStrings.substring(1, concatStrings.length() - 1).contains(s);\n    }"
    }
  },
  {
    "title": "Add Strings",
    "body": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\n\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
    "example": "Example 1:\n\nInput: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"\nExample 2:\n\nInput: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"\nExample 3:\n\nInput: num1 = \"0\", num2 = \"0\"\nOutput: \"0\"",
    "level": "easy",
    "solution": {
      "content": "public String addStrings(String num1, String num2) {\n        int i = num1.length() - 1;\n        int j = num2.length() - 1;\n        int carry = 0;\n        final StringBuilder result = new StringBuilder();\n        while (i >= 0 || j >= 0 || carry > 0) {\n            if (i >= 0) carry += num1.charAt(i--) - '0';\n            if (j >= 0) carry += num2.charAt(j--) - '0';\n\n            result.append(carry % 10);\n            carry /= 10;\n        }\n        return result.reverse().toString();\n    }"
    }
  },
  {
    "title": "Number of Segments in a String",
    "body": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contiguous sequence of non-space characters.",
    "example": "Example 1:\n\nInput: s = \"Hello, my name is John\"\nOutput: 5\nExplanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"]\nExample 2:\n\nInput: s = \"Hello\"\nOutput: 1",
    "level": "easy",
    "solution": {
      "content": "public int countSegments(String s) {\n       int segments = 0;\n\n        final String[] tokens = s.split(\" \");\n        for (String token : tokens) {\n            if (!token.isEmpty()) {\n                segments++;\n            }\n        }\n\n        return segments;\n    }"
    }
  },
  {
    "title": "Is Subsequence",
    "body": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).",
    "example": "Example 1:\n\nInput: s = \"abc\", t = \"ahbgdc\"\nOutput: true\nExample 2:\n\nInput: s = \"axc\", t = \"ahbgdc\"\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "public boolean isSubsequence(String s, String t) {\n    int i = 0;\n        int j = 0;\n        while (i < s.length() && j < t.length()) {\n            if (s.charAt(i) == t.charAt(j)) {\n                i++;\n            }\n            j++;\n        }\n        return i == s.length();\n    }"
    }
  },
  {
    "title": "Longest Palindrome",
    "body": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.\n\nLetters are case sensitive, for example, \"Aa\" is not considered a palindrome.",
    "example": "Example 1:\n\nInput: s = \"abccccdd\"\nOutput: 7\nExplanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7.\nExample 2:\n\nInput: s = \"a\"\nOutput: 1\nExplanation: The longest palindrome that can be built is \"a\", whose length is 1.",
    "level": "easy",
    "solution": {
      "content": "public int longestPalindrome(String s) {\n        final Map<Character, Integer> map = new HashMap<>();\n        int count = 0;\n        int odd = 0;\n\n        if (s.isEmpty()) return 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            final char currentCharacter = s.charAt(i);\n            map.merge(currentCharacter, 1, Integer::sum);\n        }\n\n        for (int item : map.values()) {\n            if (item % 2 == 0) {\n                count += item;\n            } else {\n                count += item - 1;\n                odd = 1;\n            }\n        }\n        return count + odd;\n    }"
    }
  },
  {
    "title": "Find the Difference",
    "body": "You are given two strings s and t.\n\nString t is generated by random shuffling string s and then add one more letter at a random position.\n\nReturn the letter that was added to t.",
    "example": "Example 1:\n\nInput: s = \"abcd\", t = \"abcde\"\nOutput: \"e\"\nExplanation: 'e' is the letter that was added.\nExample 2:\n\nInput: s = \"\", t = \"y\"\nOutput: \"y\"",
    "level": "easy",
    "solution": {
      "content": "public char findTheDifference(String s, String t) {\n        int firstSum = 0;\n        int secondSum = 0;\n\n        for (int i = 0; i < s.length(); i++) firstSum += s.charAt(i);\n        for (int i = 0; i < t.length(); i++) secondSum += t.charAt(i);\n\n        return (char) (secondSum - firstSum);\n    }"
    }
  },
  {
    "title": "First Unique Character in a String",
    "body": "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.",
    "example": "Example 1:\n\nInput: s = \"leetcode\"\n\nOutput: 0\n\nExplanation:\n\nThe character 'l' at index 0 is the first character that does not occur at any other index.\n\n  Example 2:\n\nInput: s = \"loveleetcode\"\n\nOutput: 2\n\nExample 3:\n\nInput: s = \"aabb\"\n\nOutput: -1",
    "level": "easy",
    "solution": {
      "content": "public int firstUniqChar(String s) {\n        final Map<Character, Integer> frequencyLetter = new HashMap<>();\n\n        for (char letter : s.toCharArray()) {\n            frequencyLetter.merge(letter, 1, Integer::sum);\n        }\n\n        for (int i = 0; i < s.length(); i++) {\n            final char currentCharacter = s.charAt(i);\n            if (frequencyLetter.get(currentCharacter) == 1) {\n                return i;\n            }\n        }\n\n        return -1;\n    }"
    }
  },
  {
    "title": "Reverse String",
    "body": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.",
    "example": "Example 1:\n\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n Example 2:\n\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n",
    "level": "easy",
    "solution": {
      "content": "public static void reverseString(char[] s) {\n        int left = 0;\n        int right = s.length - 1;\n        while (left < right) {\n            char temp = s[left];\n            s[left] = s[right];\n            s[right] = temp;\n\n            left++;\n            right--;\n        }\n    }"
    }
  },
  {
    "title": "Reverse Vowels of a String",
    "body": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.",
    "example": "Example 1:\n\nInput: s = \"IceCreAm\"\n\nOutput: \"AceCreIm\"\n\nExplanation:\n\nThe vowels in s are ['I', 'e', 'e', 'A']. On reversing the vowels, s becomes \"AceCreIm\". \n Example 2:\n\nInput: s = \"leetcode\"\n\nOutput: \"leotcede\"",
    "level": "easy",
    "solution": {
      "content": "public String reverseVowels(String s) {\n        Objects.requireNonNull(s, \"The string cannot be null\");\n\n        final boolean[] isVowel = new boolean[128];\n\n        final char[] vowels = \"aeiouAEIOU\".toCharArray();\n\n        for (char vowel : vowels) {\n            isVowel[vowel] = true;\n        }\n\n        final char[] charArray = s.toCharArray();\n\n        int left = 0;\n        int right = charArray.length - 1;\n\n        while (left < right) {\n            while (left < right && !isVowel[charArray[left]]) {\n                left++;\n            }\n\n            while (left < right && !isVowel[charArray[right]]) {\n                right--;\n            }\n\n            if (left < right) {\n                char temp = charArray[left];\n                charArray[left] = charArray[right];\n                charArray[right] = temp;\n\n                left++;\n                right--;\n            }\n        }\n\n        return String.valueOf(charArray);\n    }"
    }
  },
  {
    "title": "Word Pattern",
    "body": "Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:\n\nEach letter in pattern maps to exactly one unique word in s.\nEach unique word in s maps to exactly one letter in pattern.\nNo two letters map to the same word, and no two words map to the same letter.",
    "example": "Example 1:\n\nInput: pattern = \"abba\", s = \"dog cat cat dog\"\n\nOutput: true\n\nExplanation:\n\nThe bijection can be established as:\n\n'a' maps to \"dog\".\n'b' maps to \"cat\". \n Example 2:\n\nInput: pattern = \"abba\", s = \"dog cat cat fish\"\n\nOutput: false\n\nExample 3:\n\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\n\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "public boolean wordPattern(String pattern, String s) {\n        final String[] words = s.split(\"\\\\s+\");\n        final Map<Character, String> characterStringMap = new HashMap<>();\n        final Map<String, Character> stringCharacterMap = new HashMap<>();\n\n        if (pattern.length() != words.length) {\n            return false;\n        }\n\n        for (int i = 0; i < words.length; i++) {\n            final Character patternCharacter = pattern.charAt(i);\n            String word = words[i];\n\n            if (!characterStringMap.getOrDefault(patternCharacter, word).equals(word) ||\n                    !stringCharacterMap.getOrDefault(word, patternCharacter).equals(patternCharacter)) {\n                return false;\n            }\n\n\n            characterStringMap.put(patternCharacter, word);\n            stringCharacterMap.put(word, patternCharacter);\n        }\n        return true;\n    }"
    }
  },
  {
    "title": "Binary Tree Paths",
    "body": "Given the root of a binary tree, return all root-to-leaf paths in any order.\n\nA leaf is a node with no children.",
    "example": "Input: root = [1,2,3,null,5]\nOutput: [\"1->2->5\",\"1->3\"] \n Input: root = [1]\nOutput: [\"1\"]",
    "level": "easy",
    "solution": {
      "content": "final List<String> allPaths = new ArrayList<>();\n    final List<String> currentPath = new ArrayList<>();\n\n    public List<String> binaryTreePaths(final TreeNode root) {\n        depthFirstSearch(root);\n        return allPaths;\n    }\n\n    private void depthFirstSearch(final TreeNode treeNode) {\n        if (treeNode == null) {\n            return;\n        }\n\n        currentPath.add(String.valueOf(treeNode.value));\n\n        if (treeNode.left == null && treeNode.right == null) {\n            allPaths.add(String.join(\"->\", currentPath));\n        } else {\n            depthFirstSearch(treeNode.left);\n            depthFirstSearch(treeNode.right);\n        }\n        currentPath.removeLast();\n    }\n\n\n    private class TreeNode {\n        int value;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode() {\n        }\n\n        TreeNode(int value) {\n            this.value = value;\n        }\n\n        TreeNode(int value, TreeNode left, TreeNode right) {\n            this.value = value;\n            this.left = left;\n            this.right = right;\n        }\n    }"
    }
  },
  {
    "title": "Isomorphic Strings",
    "body": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
    "example": "Example 1:\n\nInput: s = \"egg\", t = \"add\"\n\nOutput: true\n\nExplanation:\n\nThe strings s and t can be made identical by:\n\nMapping 'e' to 'a'.\nMapping 'g' to 'd'. \n Example 2:\n\nInput: s = \"foo\", t = \"bar\"\n\nOutput: false\n\nExplanation:\n\nThe strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.\n\n  Example 3:\n\nInput: s = \"paper\", t = \"title\"\n\nOutput: true",
    "level": "easy",
    "solution": {
      "content": "public boolean isIsomorphic(String s, String t) {\n        final Map<Character, Character> mapFromFirstToSecond = new HashMap<>();\n        final Map<Character, Character> mapFromSecondToFirst = new HashMap<>();\n        \n        if (s.isEmpty() && t.isEmpty()) {\n            throw new IllegalArgumentException(\"The input texts cannot be empty\");\n        }\n\n        if (s.length() != t.length()) {\n            return false;\n        }\n\n        for (int i = 0; i < s.length(); i++) {\n            final char charFromS = s.charAt(i);\n            final char charFromT = t.charAt(i);\n\n            if (mapFromFirstToSecond.containsKey(charFromS) && mapFromFirstToSecond.get(charFromS) != charFromT) {\n                return false;\n            }\n\n            if (mapFromSecondToFirst.containsKey(charFromT) && mapFromSecondToFirst.get(charFromT) != charFromS) {\n                return false;\n            }\n\n            mapFromFirstToSecond.put(charFromS, charFromT);\n            mapFromSecondToFirst.put(charFromT, charFromS);\n        }\n        return true;\n    }"
    }
  },
  {
    "title": "Find Pivot Index",
    "body": "Given an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.\n\nIf the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\n\nReturn the leftmost pivot index. If no such index exists, return -1.\n\n",
    "example": "Input: nums = [1,7,3,6,5,6]\nOutput: 3\nExplanation:\nThe pivot index is 3.\nLeft sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\nRight sum = nums[4] + nums[5] = 5 + 6 = 11 \n Input: nums = [1,2,3]\nOutput: -1\nExplanation:\nThere is no index that satisfies the conditions in the problem statement. \n Input: nums = [2,1,-1]\nOutput: 0\nExplanation:\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums[1] + nums[2] = 1 + -1 = 0",
    "level": "easy",
    "solution": {
      "content": "public int pivotIndex(int[] nums) {\n        Objects.requireNonNull(nums, \"The array cannot be null\");\n\n        if (nums.length < 2) {\n            throw new IllegalArgumentException(\"The array must contain at least two elements.\");\n        }\n\n        int leftSum = 0;\n        int rightSum = 0;\n\n        for (int number : nums) {\n            rightSum += number;\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            rightSum -= nums[i];\n\n            if (leftSum == rightSum) {\n                return i;\n            }\n\n            leftSum += nums[i];\n        }\n\n        return -1;\n    }"
    }
  },
  {
    "title": "1-bit and 2-bit Characters",
    "body": "We have two special characters:\n\nThe first character can be represented by one bit 0.\nThe second character can be represented by two bits (10 or 11).\nGiven a binary array bits that ends with 0, return true if the last character must be a one-bit character.\n\n",
    "example": "Input: bits = [1,0,0]\nOutput: true\nExplanation: The only way to decode it is two-bit character and one-bit character.\nSo the last character is one-bit character. \n Input: bits = [1,1,1,0]\nOutput: false\nExplanation: The only way to decode it is two-bit character and two-bit character.\nSo the last character is not one-bit character.",
    "level": "easy",
    "solution": {
      "content": "public boolean isOneBitCharacter(int[] bits) {\n        Objects.requireNonNull(bits, \"The array cannot be null\");\n\n        if (bits.length < 2) {\n            throw new IllegalArgumentException(\"The sentence must contain at least two elements.\");\n        }\n\n        int left = 0;\n        final int right = bits.length - 1;\n\n        while (left < right) {\n            left += bits[left] + 1;\n        }\n\n        return left == right;\n    }"
    }
  },
  {
    "title": "Summary Ranges",
    "body": "You are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a to b (inclusive).\n\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\n\nEach range [a,b] in the list should be output as:\n\n\"a->b\" if a != b\n\"a\" if a == b",
    "example": "Input: nums = [0,1,2,4,5,7]\nOutput: [\"0->2\",\"4->5\",\"7\"]\nExplanation: The ranges are:\n[0,2] --> \"0->2\"\n[4,5] --> \"4->5\"\n[7,7] --> \"7\" \n Input: nums = [0,2,3,4,6,8,9]\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\nExplanation: The ranges are:\n[0,0] --> \"0\"\n[2,4] --> \"2->4\"\n[6,6] --> \"6\"\n[8,9] --> \"8->9\"",
    "level": "easy",
    "solution": {
      "content": "public List<String> summaryRanges(int[] nums) {\n        final List<String> result = new ArrayList<>();\n        if (nums.length == 0) return result;\n\n        int start = nums[0];\n        for (int i = 1; i <= nums.length; i++) {\n            if (i == nums.length || nums[i] != nums[i - 1] + 1) {\n                if (start == nums[i - 1]) {\n                    result.add(Integer.toString(start));\n                } else {\n                    result.add(start + \"->\" + nums[i - 1]);\n                }\n                if (i < nums.length) {\n                    start = nums[i];\n                }\n            }\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Find Smallest Letter Greater Than Target",
    "body": "You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.\n\nReturn the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.",
    "example": "Input: letters = [\"c\",\"f\",\"j\"], target = \"a\"\nOutput: \"c\"\nExplanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.",
    "level": "easy",
    "solution": {
      "content": ""
    }
  },
  {
    "title": "Maximum unloaded of truck",
    "body": "At the truck loading station, it is necessary to implement an algorithm for distributing the load to the truck. It is necessary to load cargo onto trucks and then output the maximum amount of underloading.",
    "example": "private int calcTrucks(int[] weights, int trucksCount, int truckMaxCapacity), Params:\n- weights - an array of loads\n- trucksCount - number of trucks\n- truckMaxCapacity - maximum load capacity \n Example:\nInput - [10, 100, 20, 30, 40, 10], 4, 100\nOutput - 90\n\nInput - [10, 100, 20, 30, 40], 4, 100\nOutput - 0",
    "level": "easy",
    "solution": {
      "content": ""
    }
  },
  {
    "title": "Number Frequency Counter",
    "body": "There is a list of integers at the input (it can contain null numbers  we ignore them).\n It is necessary to return a list of the k most frequently occurring numbers, sorted:\n        1. descending frequency;\n        2. If the frequency is equal, the number itself increases.\n If numbers == null or an empty list, then return an empty list.\n If k <= 0, return an empty list.\n If the unique numbers are less than k, return all of them.",
    "example": "List.of(\"1\", \"2\", \"1\", \"2\", \"3\", \"3\", \"3\", \"3\");, return => Map.of(3, 4, 2, 2, 1, 1);",
    "level": "easy",
    "solution": {
      "content": "public Map<Integer, Integer> counterNumberFrequency(final List<Integer> sentence, final int k) {}"
    }
  },
  {
    "title": "Maximum Average Subarray",
    "body": "You are given an integer array nums consisting of n elements, and an integer k.\n\nFind a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.",
    "example": "Input: nums = [1,12,-5,-6,50,3], k = 4\nOutput: 12.75000\nExplanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75 \n Input: nums = [5], k = 1\nOutput: 5.00000",
    "level": "easy",
    "solution": {
      "content": "public double findMaxAverage(int[] nums, int k) {\n        Objects.requireNonNull(nums, \"The array cannot be null\");\n\n        if (k < 1) {\n            throw new IllegalArgumentException(\"less than 1\");\n        }\n\n        if (k > nums.length) {\n            throw new IllegalArgumentException(\"k cannot be larger than the array length\");\n        }\n\n        int windowSum = 0;\n        for (int i = 0; i < k; i++) {\n            windowSum += nums[i];\n        }\n\n        int maxSum = windowSum;\n\n        for (int i = k; i < nums.length; i++) {\n            windowSum += nums[i] - nums[i - k];\n\n            maxSum = Math.max(maxSum, windowSum);\n        }\n        return (double) maxSum / k;\n    }"
    }
  },
  {
    "title": "Degree of an Array",
    "body": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.\n\nYour task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.\n\n",
    "example": "Input: nums = [1,2,2,3,1]\nOutput: 2\nExplanation: \nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\nOf the subarrays that have the same degree:\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\nThe shortest length is 2. So return 2.  \n Input: nums = [1,2,2,3,1,4,2]\nOutput: 6\nExplanation: \nThe degree is 3 because the element 2 is repeated 3 times.\nSo [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.",
    "level": "easy",
    "solution": {
      "content": "public int findShortestSubArray(int[] nums) {\n        Objects.requireNonNull(nums, \"The array cannot be null\");\n\n        final Map<Integer, Integer> frequencyElement = new HashMap<>();\n        final Map<Integer, Integer> firstIndexMap = new HashMap<>();\n        final Map<Integer, Integer> lastIndexMap = new HashMap<>();\n\n        int maxFrequency = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int currentItem = nums[i];\n            frequencyElement.merge(currentItem, 1, Integer::sum);\n            maxFrequency = Math.max(maxFrequency, frequencyElement.get(currentItem));\n\n            int elementIndex = i;\n\n            firstIndexMap.computeIfAbsent(currentItem, key -> elementIndex);\n\n            lastIndexMap.put(currentItem, elementIndex);\n        }\n\n        int theMostMinLength = Integer.MAX_VALUE;\n\n        for (final int num : nums) {\n            if (frequencyElement.get(num) == maxFrequency) {\n                final int subArrayLength = lastIndexMap.get(num) - firstIndexMap.get(num) + 1;\n\n                if (subArrayLength < theMostMinLength) {\n                    theMostMinLength = subArrayLength;\n                }\n            }\n        }\n\n        return theMostMinLength;\n    }"
    }
  },
  {
    "title": "Sorting on planet Twisted-3-7",
    "body": "There is a planet... in a galaxy far far away. It is exactly like our planet, but it has one difference:  the values of the digits 3 and 7 are twisted. Our 3 means 7 on the planet Twisted-3-7. And 7 means 3.\n\nYour task is to create a method, that can sort an array the way it would be sorted on Twisted-3-7.",
    "example": "1,2,3,4,5,6,7,8,9] -> [1,2,7,4,5,6,3,8,9]\n[12,13,14] -> [12,14,13]\n[9,2,4,7,3] -> [2,7,4,3,9] \n There is no need for a precheck. The array will always be not null and will always contain at least one number.\n\nYou should not modify the input array!",
    "level": "easy",
    "solution": {
      "content": "public static Integer[] sortTwisted(Integer[] array) {\n        if (Objects.isNull(array)) {\n            throw new IllegalArgumentException(\"The array cannot be null\");\n        }\n\n        if (array.length < 2) {\n            throw new IllegalArgumentException(\"he array must contain at least two elements.\");\n        }\n        final Integer[] resultArray = Arrays.copyOf(array, array.length);\n\n        Arrays.sort(resultArray, Comparator.comparing((o1, o2) -> {\n            String s1 = String.valueOf(o1);\n            String s2 = String.valueOf(o2);\n\n            s1 = s1.replaceAll(\"7\", \"X\");\n            s1 = s1.replaceAll(\"3\", \"7\");\n            s1 = s1.replaceAll(\"X\", \"3\");\n            s2 = s2.replaceAll(\"7\", \"X\");\n            s2 = s2.replaceAll(\"3\", \"7\");\n            s2 = s2.replaceAll(\"X\", \"3\");\n\n            return Integer.valueOf(s1).compareTo(Integer.valueOf(s2));\n        }));\n\n        return resultArray;\n    }"
    }
  },
  {
    "title": "Can Place Flowers",
    "body": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\n\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
    "example": "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true \n Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        int left = 0;\n        int right = flowerbed.length;\n\n        Objects.requireNonNull(flowerbed, \"The array cannot be null\");\n\n        if (n < 0) {\n            throw new IllegalArgumentException(\"The plot count should be zero or more\");\n        }\n\n        while (left < right) {\n            int leftPlot = (left == 0) ? 0 : flowerbed[left - 1];\n            int rightPlot = (left == flowerbed.length - 1) ? 0 : flowerbed[left + 1];\n\n            if (leftPlot + flowerbed[left] + rightPlot == 0) {\n                flowerbed[left] = 1;\n                --n;\n            }\n            left++;\n        }\n\n        return n <= 0;\n    }"
    }
  },
  {
    "title": "Longest Harmonious Subsequence",
    "body": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\n\nGiven an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.",
    "example": "Input: nums = [1,3,2,2,5,2,3,7]\n\nOutput: 5\n\nExplanation:\n\nThe longest harmonious subsequence is [3,2,2,2,3] \n Input: nums = [1,2,3,4]\n\nOutput: 2\n\nExplanation:\n\nThe longest harmonious subsequences are [1,2], [2,3], and [3,4], all of which have a length of 2. \n Input: nums = [1,1,1,1]\n\nOutput: 0\n\nExplanation:\n\nNo harmonic subsequence exists.",
    "level": "easy",
    "solution": {
      "content": "public int findLHS(int[] nums) {\n        if (Objects.isNull(nums)) {\n            throw new IllegalStateException(\"The array cannot be null\");\n        }\n\n        final Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n        for (int number : nums) {\n            frequencyMap.merge(number, 1, Integer::sum);\n        }\n\n        int maxLength = 0;\n\n        for (var items : frequencyMap.entrySet()) {\n            int currentKey = items.getKey();\n            int currentValue = items.getValue();\n\n            if (frequencyMap.containsKey(currentKey + 1)) {\n                final int harmonic = currentValue + frequencyMap.getOrDefault(currentKey + 1, 1);\n                maxLength = Math.max(maxLength, harmonic);\n            }\n        }\n        return maxLength;\n    }"
    }
  },
  {
    "title": "Keyboard Row",
    "body": "Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.\n\nNote that the strings are case-insensitive, both lowercased and uppercased of the same letter are treated as if they are at the same row.\n\nIn the American keyboard:\n\nthe first row consists of the characters \"qwertyuiop\",\nthe second row consists of the characters \"asdfghjkl\", and\nthe third row consists of the characters \"zxcvbnm\".\n",
    "example": "Input: words = [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]\n\nOutput: [\"Alaska\",\"Dad\"]\n\nExplanation:\n\nBoth \"a\" and \"A\" are in the 2nd row of the American keyboard due to case insensitivity.  Input: words = [\"omk\"]\n\nOutput: [] \n Input: words = [\"adsdf\",\"sfd\"]\n\nOutput: [\"adsdf\",\"sfd\"]",
    "level": "easy",
    "solution": {
      "content": "public String[] findWords(String[] words) {\n        final List<String> tempResultList = new ArrayList<>();\n\n        if (Objects.isNull(words)) {\n            throw new IllegalArgumentException(\"The array cannot be a null\");\n        }\n\n        for (final String word : words) {\n\n            final String wordLowerCase = word.toLowerCase();\n\n            if (wordLowerCase.matches(\"^[qwertyuiop]+$\")\n                    || wordLowerCase.matches(\"^[asdfghjkl]+$\")\n                    || wordLowerCase.matches(\"^[zxcvbnm]+$\")) {\n\n                tempResultList.add(word);\n            }\n        }\n\n        final String[] result = new String[tempResultList.size()];\n        for (int i = 0; i < tempResultList.size(); i++) {\n            result[i] = tempResultList.get(i);\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Big Diff",
    "body": "Given an array of numbers, find the largest difference between elements in the array. For example, for the array [1,2,3], the following differences can be calculated: 2-1 = 1, 3-2 = 1, 3-1 = 2.\n\nThe largest difference between elements in this array is 2.\n\nThe solution will be checked for performance, so think about efficiency.",
    "example": "bigDiff([10, 3, 5, 6]) = 7 \n bigDiff([7, 2, 10, 9]) = 8",
    "level": "easy",
    "solution": {
      "content": "public int bigDiff(int[] inputArray) {\n        if (Objects.isNull(inputArray)) {\n            throw new IllegalArgumentException(\"The input array cannot be null\");\n        }\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"The input array must contain at least two elements.\");\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int maxValue = Integer.MIN_VALUE;\n\n        for (int element : inputArray) {\n            minValue = Math.min(element, minValue);\n            maxValue = Math.max(element, maxValue);\n        }\n        return (maxValue - minValue);\n    }"
    }
  },
  {
    "title": "Make Middle",
    "body": "Given an array of ints of even length, return a new array length 2 containing the middle two elements from the original array. The original array will be length 2 or more.",
    "example": "makeMiddle([1, 2, 3, 4])  [2, 3] \n  makeMiddle([7, 1, 2, 3, 4, 9])  [2, 3] \n makeMiddle([1, 2])  [1, 2]",
    "level": "easy",
    "solution": {
      "content": "public int[] makeMiddle(int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"The array must contain at least two elements.\");\n        }\n\n        final int middleIndex = inputArray.length / 2;\n        return new int[]{inputArray[middleIndex - 1], inputArray[middleIndex]};\n    }"
    }
  },
  {
    "title": "Same Ends",
    "body": "Return true if the group of N numbers at the start and end of the array are the same. For example, with {5, 6, 45, 99, 13, 5, 6}, the ends are the same for n=0 and n=2, and false for n=1 and n=3. You may assume that n is in the range 0..nums.length inclusive.",
    "example": "sameEnds([5, 6, 45, 99, 13, 5, 6], 1)  false \n sameEnds([5, 6, 45, 99, 13, 5, 6], 2)  true \n sameEnds([5, 6, 45, 99, 13, 5, 6], 3)  false",
    "level": "easy",
    "solution": {
      "content": "public boolean sameEnds(int[] inputArray, final int len) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (len < 1) {\n            throw new IllegalArgumentException(\"The len variable cannot be less than one\");\n        }\n        if (inputArray.length < len) {\n            throw new IllegalArgumentException(\"The array length cannot be less than the len variable\");\n        }\n\n        for (int i = 0; i < len; i++) {\n            if (inputArray[i] != inputArray[inputArray.length - len + i]) {\n                return false;\n            }\n        }\n        \n        return true;\n    }"
    }
  },
  {
    "title": "The zero max",
    "body": "Return a version of the given array where each zero value in the array is replaced by the\n    largest odd value to the right of the zero in the array.\n    If there is no odd value to the right of the zero, leave the zero as a zero.",
    "example": "zeroMax([0, 5, 0, 3])  [5, 5, 3, 3] \n zeroMax([0, 4, 0, 3])  [3, 4, 3, 3] \n zeroMax([0, 1, 0])  [1, 1, 0]",
    "level": "easy",
    "solution": {
      "content": "public int[] zeroMax(final int[] inputArray) {\n        int maxValue = Integer.MIN_VALUE;\n\n        int[] result = Arrays.copyOf(inputArray, inputArray.length);\n\n        Objects.requireNonNull(inputArray, \"Input array must not be null\");\n\n        if (inputArray.length < 2) {\n            return new int[0];\n        }\n\n        for (int i = result.length - 1; i >= 0; i--) {\n            if (result[i] % 2 != 0) {\n                maxValue = Math.max(maxValue, result[i]);\n            }\n\n            if (result[i] == 0 && maxValue != Integer.MIN_VALUE) {\n                result[i] = maxValue;\n            }\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "The Reverse integer",
    "body": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.",
    "example": "Input: x = 123, Output: 321; Input: x = -123, Output: -321; Input: x = 120, Output: 21",
    "level": "medium",
    "solution": {
      "content": "public Integer reverseNumbers(Integer number) {\n        var reverse = 0L;\n        var digit = 0;\n\n        while (number != 0) {\n            digit = number % 10;\n            reverse = reverse * 10 + digit;\n            number /= 10;\n        }\n\n        if (reverse > Integer.MAX_VALUE || reverse < Integer.MIN_VALUE) {\n            return 0;\n        }\n\n        return (int) reverse;\n    }"
    }
  },
  {
    "title": "The two sum",
    "body": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n You may assume that each input would have exactly one solution, and you may not use the same element twice.\n You can return the answer in any order.",
    "example": "Input: nums = [2,7,11,15], target = 9, Output: [0,1], Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]; Input: nums = [3,2,4], target = 6, Output: [1,2]; Input: nums = [3,3], target = 6, Output: [0,1]",
    "level": "easy",
    "solution": {
      "content": "public int[] findTwoSum(final int[] inputArray, final int target) {\n        Objects.requireNonNull(inputArray, \"Input array must not be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"Input array must contain at least two elements\");\n        }\n\n        HashMap<Integer, Integer> lookup = new HashMap<>();\n\n        for (int i = 0; i < inputArray.length; i++) {\n            int complement = target - inputArray[i];\n            if (lookup.containsKey(complement)) {\n                return new int[]{lookup.get(complement), i};\n            }\n\n            lookup.put(inputArray[i], i);\n\n        }\n        throw new IllegalArgumentException(\"No two elements sum up to the target\");\n    }"
    }
  },
  {
    "title": "Palindrome Number",
    "body": "Given an integer x, return true if x is a \npalindrome\n, and false otherwise. Input: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.",
    "example": "Input: x = 121, Output: true, Explanation: 121 reads as 121 from left to right and from right to left; Input: x = -121, Output: false, Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.",
    "level": "easy",
    "solution": {
      "content": "public boolean checkPalindromeNumber(final int number) {\n        if (number < 0 || (number != 0 && number % 10 == 0)) {\n            return false;\n        }\n\n        int reversed = 0;\n        int n = number;\n\n        while (n != 0) {\n            int digit = n % 10;\n            reversed = reversed * 10 + digit;\n            n /= 10;\n        }\n\n        return reversed == number;\n    }"
    }
  },
  {
    "title": "Longest Common Prefix",
    "body": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\"",
    "example": "Input: strs = [\"flower\",\"flow\",\"flight\"], Output: \"fl\"; Input: strs = [\"dog\",\"racecar\",\"car\"], Output: \"\", Explanation: There is no common prefix among the input strings.",
    "level": "easy",
    "solution": {
      "content": "public String findLongestSubstringWithoutRepeatingCharacters(final String inputText) {\n        Objects.requireNonNull(inputText, \"The sentence cannot be null\");\n\n        final String trimmed = inputText.toLowerCase().trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        boolean hasLetter = trimmed.chars().anyMatch(Character::isAlphabetic);\n\n        if (!hasLetter) {\n            throw new IllegalArgumentException(\"The sentence contains no letters\");\n        }\n\n        final String[] inputStringArray = trimmed.split(\"\\\\s+\");\n\n        if (inputStringArray.length < 2) {\n            throw new IllegalArgumentException(\"The sentence must contain at least two words.\");\n        }\n\n        String prefix = inputStringArray[0];\n\n        for (String item : inputStringArray) {\n            while (item.indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty()) {\n                    return \"\";\n                }\n            }\n        }\n        return prefix;\n    }"
    }
  },
  {
    "title": "Valid Parentheses",
    "body": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. ",
    "example": "Input: s = \"()\", Output: true; Input: s = \"()[]{}\", Output: true; Input: s = \"(]\", Output: false",
    "level": "easy",
    "solution": {
      "content": "Objects.requireNonNull(text, \"The sentence cannot be null\");\n\n        String trimmed = text.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only white spaces\");\n        }\n\n        Deque<Character> deque = new ArrayDeque<>();\n\n        for (char symbol : trimmed.toCharArray()) {\n            switch (symbol) {\n                case '(', '{', '[' -> {\n                    deque.push(switch (symbol) {\n                        case '(' -> ')';\n                        case '{' -> '}';\n                        case '[' -> ']';\n                        default -> throw new IllegalStateException(\"Unexpected opening bracket: \" + symbol);\n                    });\n                }\n                case ')', '}', ']' -> {\n                    if (deque.isEmpty() || deque.pop() != symbol) {\n                        return false;\n                    }\n                }\n                default -> {\n                    // Skip non-bracket characters\n                }\n            }\n        }\n\n        return deque.isEmpty();\n    }"
    }
  },
  {
    "title": "Find the Index of the First Occurrence in a String",
    "body": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
    "example": "Input: haystack = \"sadbutsad\", needle = \"sad\", Output: 0, Explanation: \"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0; Input: haystack = \"leetcode\", needle = \"leeto\", Output: -1, Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1",
    "level": "easy"
  },
  {
    "title": "Search Insert Position",
    "body": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.",
    "example": "Input: nums = [1,3,5,6], target = 5, Output: 2; Input: nums = [1,3,5,6], target = 2, Output: 1; Input: nums = [1,3,5,6], target = 7, Output: 4",
    "level": "easy",
    "solution": {
      "content": "public static int binarySearch(int[] sortedArray, int target) {\n        int left = 0;\n        int right = sortedArray.length - 1;\n        int result = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (sortedArray[mid] == target) {\n                result = mid;\n                right = mid - 1;\n            } else if (sortedArray[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "Plus One",
    "body": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's. \n Increment the large integer by one and return the resulting array of digits.",
    "example": "Input: digits = [1,2,3], Output: [1,2,4], Explanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\n Thus, the result should be [1,2,4]; Input: digits = [4,3,2,1], Output: [4,3,2,2], Explanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\n Thus, the result should be [4,3,2,2]",
    "level": "easy",
    "solution": {
      "content": "public int[] plusOne(final int[] digits) {\n        Objects.requireNonNull(digits, \"The array cannot be null\");\n\n        for (int i = digits.length - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n\n        int[] result = new int[digits.length + 1];\n        result[0] = 1;\n        return result;\n    }"
    }
  },
  {
    "title": "Concatenate two arrays in Java",
    "body": "Concatenate two arrays  with the standard Java API",
    "example": "String[] strArray1 = {\"element 1\", \"element 2\", \"element 3\"}; String[] strArray2 = {\"element 4\", \"element 5\"}; result = String[] expectedStringArray = {\"element 1\", \"element 2\", \"element 3\", \"element 4\", \"element 5\"}; int[] intArray1 = { 0, 1, 2, 3 };\nint[] intArray2 = { 4, 5, 6, 7 };\nint[] expectedIntArray = { 0, 1, 2, 3, 4, 5, 6, 7 };",
    "level": "easy",
    "solution": {
      "content": "public static void additionOfArrays(final int[] firstArray, final int[] secondArray) {\n        IntStream\n                .concat(Arrays.stream(firstArray), Arrays.stream(secondArray))\n                .distinct()\n                .sorted()\n                .forEach(System.out::print);\n    }"
    }
  },
  {
    "title": "Count Character Frequencies",
    "body": "Write a method that takes a string and returns a Map<Character, Integer> representing the frequency of each character (ignore spaces and case sensitivity).",
    "example": "Input: \"Programming\"\nOutput: {r=2, o=1, g=2, a=1, m=2, i=1, n=1, p=1}",
    "level": "easy",
    "solution": {
      "content": "public Map<Character, Integer> countCharacterFrequencies(final String sentence) {\n        final Map<Character, Integer> frequencyMap = new HashMap<>();\n\n        Objects.requireNonNull(sentence, \"The sentence cannot be null\");\n\n        final String trimmed = sentence.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        boolean hasLetter = trimmed.chars().anyMatch(Character::isAlphabetic);\n\n        if (!hasLetter) {\n            throw new IllegalArgumentException(\"The sentence contains no letters\");\n        }\n\n        for (final char symbol : trimmed.toCharArray()) {\n            if (Character.isAlphabetic(symbol)) {\n                char c = Character.toLowerCase(symbol);\n                frequencyMap.merge(c, 1, Integer::sum);\n            }\n        }\n        return frequencyMap;\n    }"
    }
  },
  {
    "title": "Word Frequency Counter",
    "body": "Write a program that takes a block of text input (as a single String) and calculates how many times each word appears. Words should be treated as case-insensitive. The output should display each word along with its frequency in descending order.",
    "example": "Input: Hello word word and word \n, Output: {word=3, and=1, hello=1}",
    "level": "easy",
    "solution": {
      "content": "public Map<String, Integer> counterWordFrequency(final String inputWords) {\n        Objects.requireNonNull(inputWords, \"The sentence cannot be null\");\n\n        final Map<String, Integer> frequencyMap = new HashMap<>();\n\n        final String trimmed = inputWords.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        final boolean hasLetter = trimmed.chars().anyMatch(Character::isAlphabetic);\n\n        if (!hasLetter) {\n            throw new IllegalArgumentException(\"The sentence contains no letters\");\n        }\n\n        final String[] words = trimmed.split(\"\\\\s+\");\n\n        for (final String word : words) {\n            final String cleanWord = word.toLowerCase().replaceAll(\"[^a-z]\", \"\");\n\n            frequencyMap.merge(cleanWord, 1, Integer::sum);\n        }\n\n        return frequencyMap.entrySet().stream().sorted(Map.Entry.<String, Integer>comparingByValue().reversed())\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));\n    }"
    }
  },
  {
    "title": "Binary Search",
    "body": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.\n\n",
    "example": "Input: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4; Input: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1",
    "level": "easy",
    "solution": {
      "content": "public static int binarySearch(int[] sortedArray, int target) {\n        int left = 0;\n        int right = sortedArray.length - 1;\n        int result = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (sortedArray[mid] == target) {\n                result = mid;\n                right = mid - 1;\n            } else if (sortedArray[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "Check Bubble Sort",
    "body": "Take 10 numbers and shuffle them into a random order.  Your goal is to sort the numbers into ascending numerical order as shown below, using a bubble sort.\n",
    "example": "[7, 12, 9, 11, 3] => [3, 7, 9, 11, 12]",
    "level": "easy",
    "solution": {
      "content": "public int[] bubbleSort(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"The array should contain min 2 elements\");\n        }\n\n        boolean swaped = true;\n\n        final int length = inputArray.length;\n\n        for (int i = 0; i < length - 1 && swaped; i++) {\n            swaped = false;\n\n            for (int j = 0; j < length - i - 1; j++) {\n                if (inputArray[j] > inputArray[j + 1]) {\n                    int temp = inputArray[j];\n                    inputArray[j] = inputArray[j + 1];\n                    inputArray[j + 1] = temp;\n                    swaped = true;\n                }\n            }\n        }\n\n        return inputArray;\n    }"
    }
  },
  {
    "title": "Calculate Character",
    "body": "Count the number of occurrences of a char in a String in Java",
    "example": "test => {t-2, e-1, s-1}",
    "level": "easy",
    "solution": {
      "content": "public Map<Character, Long> countCharsStream(final String text) {\n        return text.chars()\n                .mapToObj(i -> (char) i)\n                .collect(Collectors.groupingBy(Function.identity(),\n                        Collectors.counting()));\n    }"
    }
  },
  {
    "title": "Compare Version Numbers",
    "body": "Given two version strings, version1 and version2, compare them. A version string consists of revisions separated by dots '.'. The value of the revision is its integer conversion ignoring leading zeros.\n\nTo compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0. \n Return the following:\n\nIf version1 < version2, return -1.\nIf version1 > version2, return 1.\nOtherwise, return 0.",
    "example": "Input: version1 = \"1.2\", version2 = \"1.10\"\n\nOutput: -1\n\nExplanation:\n\nversion1's second revision is \"2\" and version2's second revision is \"10\": 2 < 10, so version1 < version2.   Input: version1 = \"1.01\", version2 = \"1.001\"\n\nOutput: 0\n\nExplanation:\n\nIgnoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".  Input: version1 = \"1.0\", version2 = \"1.0.0.0\"\n\nOutput: 0\n\nExplanation:\n\nversion1 has less revisions, which means every missing revision are treated as \"0\".",
    "level": "easy",
    "solution": {
      "content": "public int compareVersions(final String version1, final String version2) {\n        Objects.requireNonNull(version1, \"Version1 cannot be null\");\n        Objects.requireNonNull(version2, \"Version2 cannot be null\");\n\n        if (version1.isEmpty() || version2.isEmpty()) {\n            throw new IllegalArgumentException(\"Version strings cannot be empty\");\n        }\n\n        final String[] v1Parts = version1.split(\"\\\\.\");\n        final String[] v2Parts = version2.split(\"\\\\.\");\n\n        final int maxLength = Math.max(v1Parts.length, v2Parts.length);\n\n        for (int i = 0; i < maxLength; i++) {\n            int v1 = i < v1Parts.length ? Integer.parseInt(v1Parts[i]) : 0;\n            int v2 = i < v2Parts.length ? Integer.parseInt(v2Parts[i]) : 0;\n\n            if (v1 != v2) {\n                return Integer.compare(v1, v2);\n            }\n        }\n\n        return 0;\n    }"
    }
  },
  {
    "title": "Duplicate elements array and remove",
    "body": "Find all duplicates elements in array and remove them. Return a new array",
    "example": "{1,1,2,2,3,4,5,6} => result = {1,2,3,4,5,6}",
    "level": "easy",
    "solution": {
      "content": "public Integer[] findDuplicatesAndRemove(final Integer[] inputArray) {\n        Objects.requireNonNull(inputArray, \"Input array must not be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"Input array must contain at least two elements\");\n        }\n\n        Set<Integer> uniqElements = new LinkedHashSet<>(Arrays.asList(inputArray));\n\n\n        return uniqElements.toArray(new Integer[0]);\n    }"
    }
  },
  {
    "title": "Factorial",
    "body": "Create a function for the finding the factorial",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public int factorial(final int number) {\n        if (number < 0) throw new IllegalArgumentException(\"Factorial is undefined for negative numbers\");\n        if (number >= 20)\n            throw new IllegalArgumentException(\"Factorial result overflows int. Use a smaller number or BigInteger.\");\n\n        return IntStream.rangeClosed(2, number).reduce(1, Math::multiplyExact);\n    }"
    }
  },
  {
    "title": "Fibonacci Series Generator",
    "body": "Create a Java method that prints the first n numbers of the Fibonacci sequence, where n is a positive integer parameter passed to the method.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public long getFibonacciNumber(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"The number must be non-negative\");\n        }\n\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n\n        long prev2 = 0;\n        long prev1 = 1;\n\n        for (int i = 2; i <= n; i++) {\n            long current = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = current;\n        }\n\n        return prev1;\n    }"
    }
  },
  {
    "title": "Find duplicates in array",
    "body": "Find all duplicates in array an return them in the a new array",
    "example": "{1,1,2,2,3} => result = {1,2}",
    "level": "easy",
    "solution": {
      "content": "public int[] findDuplicates(final int[] inputArray) {\n        Set<Integer> duplicates = new HashSet<>();\n        Set<Integer> actual = new HashSet<>();\n\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"The array cannot have less than two elements.\");\n        }\n\n        for (int item : inputArray) {\n            if (!actual.add(item)) {\n                duplicates.add(item);\n            }\n        }\n        return duplicates.stream().mapToInt(Integer::intValue).toArray();\n    }"
    }
  },
  {
    "title": "Find duplicates In arrays",
    "body": "Find all duplicates in arrays an return them in the a new array",
    "example": "array1 = {1,2,3,4}, array1 = {1,2,3,5} => result =  {1,2,3}",
    "level": "easy",
    "solution": {
      "content": "public int[] findDuplicatesInArrays(final Integer[] firstArray, final Integer[] secondArray) {\n        Objects.requireNonNull(firstArray, \"The firstArray cannot be null\");\n        Objects.requireNonNull(secondArray, \"The secondArray cannot be null\");\n\n        if (firstArray.length == 0 || secondArray.length == 0) {\n            throw new IllegalArgumentException(\"Neither input array can be empty\");\n        }\n\n        Set<Integer> actual = new HashSet<>(Arrays.asList(firstArray));\n        Set<Integer> duplicates = new HashSet<>();\n\n        for (int item : secondArray) {\n            if (actual.contains(item)) {\n                duplicates.add(item);\n            }\n        }\n\n        return duplicates.stream().mapToInt(Integer::intValue).toArray();\n    }"
    }
  },
  {
    "title": "Find sum of elements in array",
    "body": "Calculate all elements in the array and return a result",
    "example": "{1,2,3} => result = 6",
    "level": "easy",
    "solution": {
      "content": "public static int findNumberOfPair(final int[] inputNumber, final int sumElements) {\n        if (inputNumber.length < sumElements) {\n            return inputNumber.length;\n        }\n        int count = 0;\n        for (int i = 0; i < inputNumber.length; i++) {\n            for (int j = i + 1; j < inputNumber.length; j++) {\n                if ((inputNumber[i] + inputNumber[j]) == sumElements) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }"
    }
  },
  {
    "title": "FizzBuzz. Loop and Stream.",
    "body": "Given an integer n, return a string array answer (1-indexed) where: answer[i] == \"FizzBuzz\" if i is divisible by 3 and 5 \n, answer[i] == \"Fizz\" if i is divisible by 3 \n, answer[i] == \"Buzz\" if i is divisible by 5 \n, answer[i] == i (as a string) if none of the above conditions are true \n",
    "example": "Input: n = 3, Output: [\"1\",\"2\",\"Fizz\"] \n; Input: n = 5, Output: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n; Input: n = 15, Output: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n;",
    "level": "easy",
    "solution": {
      "content": "public static void getFizzBuzz() {\n        PrintStream printStream = System.out;\n        for (int i = 1; i < 100; i++) {\n            if (i % 15 == 0) {\n                printStream.println(\" Fizz Buzz \" + i);\n            } else if (i % 3 == 0) {\n                printStream.println(\" Fizz \" + i);\n            } else if (i % 5 == 0) {\n                printStream.println(\" Buzz \" + i);\n            } else {\n                printStream.println(\" \" + i);\n            }\n        }\n    } \n  private static void streamFizBuzz() {\n        IntStream.rangeClosed(1, 100)\n                .mapToObj(i -> i % 3 == 0 ? (i % 5 == 0 ? \"Fizz Buzz \" : \"Fizz \") : (i % 5 == 0 ? \"Buzz \" : i + \" \"))\n                .forEach(System.out::println);\n    }"
    }
  },
  {
    "title": "Flip array",
    "body": "Returns an array in flip order",
    "example": "{1,2,3,4} => {4,3,2,1}",
    "level": "easy",
    "solution": {
      "content": "public int[] flipArrayDeclarativeApproach(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"Input array must not be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"Input array must contain at least two elements\");\n        }\n\n\n        return IntStream.range(0, inputArray.length)\n                .map(i -> inputArray[inputArray.length - 1 - i])\n                .toArray();\n\n    }"
    }
  },
  {
    "title": "Length in array",
    "body": "Count a length array",
    "example": " {1,2,3,4}  result = 4",
    "level": "easy",
    "solution": {
      "content": " public static int countArrayLength(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n        \n        return inputArray.length;\n    }"
    }
  },
  {
    "title": "LuckyTicket. With arguments string and numeric",
    "body": "Bus ticket numbers consist of 6 decimal digits. It is considered lucky when the sum of the first three digits equals the sum of the last three digits. ",
    "example": "123321 = > is lucky, 123322 => is not lucky",
    "level": "easy",
    "solution": {
      "content": "public boolean isLuckyTicket1(final String text) {\n        Objects.requireNonNull(text, \"The sentence cannot be null\");\n\n        final String trimmed = text.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only space\");\n        }\n\n        if (trimmed.length() != 6 && !trimmed.matches(\"\\\\d{6}\")) {\n            throw new IllegalArgumentException(\"Ticket must contain exactly 6 digits\");\n        }\n\n        int firstSum = 0;\n\n        int secondSum = 0;\n\n        for (int i = 0; i < 3; i++) {\n            firstSum += Character.getNumericValue(text.charAt(i));\n            secondSum += Character.getNumericValue(text.charAt(i + 3));\n        }\n        return firstSum == secondSum;\n    }"
    }
  },
  {
    "title": "Matrix diagonal sum",
    "body": "Given a square matrix mat, return the sum of the matrix diagonals.\n\nOnly include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.",
    "example": "Input: mat = [[1,2,3],\n              [4,5,6],\n              [7,8,9]], Output: 25\nExplanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25; Input: mat = [[1,1,1,1],\n              [1,1,1,1],\n              [1,1,1,1],\n              [1,1,1,1]], Output: 8; Input: mat = [[5]], Output: 5",
    "level": "easy",
    "solution": {
      "content": "public int matrixDiagonalSum(final int[][] inputMatrixData) {\n        int result = 0;\n\n        Objects.requireNonNull(inputMatrixData, \"The matrix data cannot be null\");\n\n        for (int[] row : inputMatrixData) {\n            if (row.length != inputMatrixData.length) {\n                throw new IllegalArgumentException(\"Matrix must be square\");\n            }\n        }\n\n        for (int i = 0; i < inputMatrixData.length; i++) {\n            result += inputMatrixData[i][i];\n\n            if (i != inputMatrixData.length - 1 - i) {\n                result += inputMatrixData[i][inputMatrixData.length - 1 - i];\n            }\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Merge arrays",
    "body": "The merge two arrays",
    "example": "array1 = {1,2,3}, array2= {4,5,6}, result = {1,2,3,4,5,6}",
    "level": "easy",
    "solution": {
      "content": "public String[] mergeArrays(final String[] first, final String... second) {\n        Objects.requireNonNull(first, \"The first array cannot be null\");\n        Objects.requireNonNull(second, \"The second array cannot be null\");\n\n        List<String> mergedList = new ArrayList<>(first.length + second.length);\n\n        Collections.addAll(mergedList, first);\n        Collections.addAll(mergedList, second);\n        return mergedList.toArray(new String[0]);\n    }"
    }
  },
  {
    "title": "Find min and max values in array",
    "body": "Given an array of size N. The task is to find the maximum and the minimum element of the array using the minimum number of comparisons.",
    "example": "Input: arr[] = {3, 5, 4, 1, 9}\nOutput: Minimum element is: 1\n              Maximum element is: 9; Input: arr[] = {22, 14, 8, 17, 35, 3}\nOutput:  Minimum element is: 3\n              Maximum element is: 35",
    "level": "easy",
    "solution": {
      "content": "public static int[] findMinMax(int[] array) {\n        Objects.requireNonNull(array, \"An array must not be null\");\n\n        Integer min = null; \n        Integer max = null;\n        \n        for (Integer value : array) {\n            if (value == null) continue;\n            if (min == null || value < min) min = value;\n            if (max == null || value > max) max = value;\n        }\n\n        if (min == null || max == null) {\n            return new int[]{};\n        }\n\n        return new int[]{min, max};\n    }"
    }
  },
  {
    "title": "Find min and max values in list",
    "body": "Given a list of size N. The task is to find the maximum and the minimum element of the array using the minimum number of comparisons.",
    "example": "Input: List<Integer> = List.of(3, 5, 4, 1, 9)\nOutput: Minimum element is: 1\n              Maximum element is: 9; \n Input: List<Integer> = List.of(22, 14, 8, 17, 35, 3)\nOutput:  Maximum element is: 35 \n, Minimum element is: 3\n              Maximum element is: 35",
    "level": "easy",
    "solution": {
      "content": "public record MinMax(Integer min, Integer max) {}\n\npublic static MinMax findMinMax(List<Integer> list) {\n    Objects.requireNonNull(list, \"List must not be null\");\n\n    Integer min = null, max = null;\n    for (Integer val : list) {\n        if (val == null) continue;\n        if (min == null || val < min) min = val;\n        if (max == null || val > max) max = val;\n    }\n\n    if (min == null || max == null) {\n        throw new IllegalArgumentException(\"List contains only nulls or is empty\");\n    }\n\n    return new MinMax(min, max);\n}"
    }
  },
  {
    "title": "Missing Number",
    "body": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
    "example": "Example 1:\n\nInput: nums = [3,0,1]\n\nOutput: 2\n\nExplanation:\n\nn = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.; Example 2:\n\nInput: nums = [0,1]\n\nOutput: 2\n\nExplanation:\n\nn = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.Example 3:\n\nInput: nums = [9,6,4,2,3,5,7,0,1]\n\nOutput: 8\n\nExplanation:\n\nn = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.",
    "level": "easy",
    "solution": {
      "content": "public int[] missingNumber(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"An array cannot be null\");\n\n        List<Integer> missing = new ArrayList<>();\n\n        int[] array = Arrays.stream(inputArray).distinct().sorted().toArray();\n\n        for (int i = 0; i < array.length - 1; i++) {\n            int current = array[i];\n            int next = array[i + 1];\n            if (next - current > 1) {\n                for (int j = current + 1; j < next; j++) {\n                    missing.add(j);\n                }\n            }\n        }\n        return missing.stream().mapToInt(Integer::intValue).toArray();\n    }"
    }
  },
  {
    "title": "Move zeroes",
    "body": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.",
    "example": "Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]; Input: nums = [0]\nOutput: [0]",
    "level": "easy",
    "solution": {
      "content": "public int[] moveZeroes(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"The array must contain at least two elements.\");\n        }\n\n        int nonZeroPos = 0;\n        for (int i = 0; i < inputArray.length; i++) {\n            if (inputArray[i] != 0) {\n                inputArray[nonZeroPos++] = inputArray[i];\n            }\n        }\n\n        while (nonZeroPos < inputArray.length) {\n            inputArray[nonZeroPos++] = 0;\n        }\n\n        return inputArray;\n    }"
    }
  },
  {
    "title": "Find Number of Element. Line Method.",
    "body": "Need to find index element in the array",
    "example": "{10,20,30,40} => target = 30, result = 2, because this is a index of element 30",
    "level": "easy",
    "solution": {
      "content": "public static int binarySearch(int[] sortedArray, int target) {\n        int left = 0;\n        int right = sortedArray.length - 1;\n        int result = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (sortedArray[mid] == target) {\n                result = mid;\n                right = mid - 1;\n            } else if (sortedArray[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "ParseString. Full version",
    "body": "Parse the string and get all numbers from the string. Divide elements into two arrays. In the first array, only even numbers and in the second, only odd numbers. In the first array, sort by natural order, and second sort in reverse order. ",
    "example": "text = f1f10d3f4f5f9f0f6, result => {1,4,6,10}, {9,5,3}",
    "level": "easy",
    "solution": {
      "content": "public static void parseString(final String text) {\n        String[] newString = text.split(\"[^\\\\d]+\");\n\n        List<String> list = Arrays.stream(newString)\n                .filter(s -> !s.isEmpty())\n                .toList();\n\n        int[] numArr = new int[list.size()];\n\n        for (int i = 0; i < list.size(); i++) {\n            numArr[i] = Integer.parseInt(list.get(i));\n        }\n\n        int[] firstArray = new int[]{};\n        int[] secondArray = new int[]{};\n\n        for (int item : numArr) {\n            if (item % 2 == 0) {\n                int[] temp = new int[firstArray.length + 1];\n                System.arraycopy(firstArray, 0, temp, 0, firstArray.length);\n                temp[firstArray.length] = item;\n                firstArray = temp;\n            } else {\n                int[] temp = new int[secondArray.length + 1];\n                System.arraycopy(secondArray, 0, temp, 0, secondArray.length);\n                temp[secondArray.length] = item;\n                secondArray = temp;\n            }\n        }\n        naturalSort(firstArray);\n\n\n\n        reverseSort(secondArray);\n    }, private static void naturalSort(final int[] inputArray) {\n        for (int i = 0; i < inputArray.length; i++) {\n            int left = inputArray[i];\n            for (int j = i - 1; j >= 0; j--) {\n                int right = inputArray[j];\n                if (left < right) {\n                    inputArray[j + 1] = right;\n                    inputArray[j] = left;\n                }\n            }\n        }\n        for (int item : inputArray) {\n            System.out.print(\" \" + item);\n        }\n    }\n\n    private static void reverseSort(final int[] inputArray) {\n        for (int i = 0; i < inputArray.length - 1; i++) {\n            for (int j = i + 1; j < inputArray.length; j++) {\n                if (inputArray[i] < inputArray[j]) {\n                    int tempNumber = inputArray[i];\n                    inputArray[i] = inputArray[j];\n                    inputArray[j] = tempNumber;\n                }\n\n            }\n        }\n\n        for (int item : inputArray) {\n            System.out.print(\" \" + item);\n        }\n    }"
    }
  },
  {
    "title": "Valid Palindrome. The argument string and numeric",
    "body": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.",
    "example": "Input: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome. Input: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome. Input: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.",
    "level": "easy",
    "solution": {
      "content": "public static boolean isPoly(final String inputText) {\n        char[] newString = inputText\n                .replaceAll(\"^A-Za-z0-9]\", \"\")\n                .toLowerCase()\n                .toCharArray();\n\n        char[] reverseString = new char[newString.length];\n\n        for (int i = 0; i < newString.length; i++) {\n            reverseString[(newString.length - 1) - i] = newString[i];\n        }\n\n        return new String(reverseString).equalsIgnoreCase(inputText);\n    }    public boolean checkPalindromeNumber(final int number) {\n        if (number < 0 || (number != 0 && number % 10 == 0)) {\n            return false;\n        }\n\n        int reversed = 0;\n        int n = number;\n\n        while (n != 0) {\n            int digit = n % 10;\n            reversed = reversed * 10 + digit;\n            n /= 10;\n        }\n\n        return reversed == number;\n    }"
    }
  },
  {
    "title": "Quick Sort",
    "body": "Quicksort is a divide-and-conquer algorithm",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public static int[] quickSort(int[] inputNumber, int begin, int end) {\n        if (begin < end) {\n            int partitionIndex = partition(inputNumber, begin, end);\n\n            quickSort(inputNumber, begin, partitionIndex - 1);\n            quickSort(inputNumber, partitionIndex + 1, end);\n        }\n        return inputNumber;\n    }    private static int partition(int[] inputNumber, int begin, int end) {\n        int pivot = inputNumber[end];\n        int i = (begin - 1);\n\n        for (int j = begin; j < end; j++) {\n            if (inputNumber[j] <= pivot) {\n                i++;\n\n                int swapTemp = inputNumber[i];\n                inputNumber[i] = inputNumber[j];\n                inputNumber[j] = swapTemp;\n            }\n        }\n\n        int swapTemp = inputNumber[i + 1];\n        inputNumber[i + 1] = inputNumber[end];\n        inputNumber[end] = swapTemp;\n\n        return i + 1;\n    }"
    }
  },
  {
    "title": "Remove First Letter from ich word from list and sort",
    "body": "Remove the first character",
    "example": "{Tony, Anna, Tom}, result => {nna, ony, om}",
    "level": "easy",
    "solution": {
      "content": "public static List<String> removeFirstLetter(final List<String> names) {\n        return names.stream()\n                .map(name -> name.substring(1))\n                .sorted()\n                .toList();\n    }"
    }
  },
  {
    "title": "Reverse string",
    "body": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.",
    "example": "Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]; Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
    "level": "easy",
    "solution": {
      "content": "public static String reverseText(final String inputText) {\n        Objects.requireNonNull(inputText, \"The input text cannot be null\");\n\n        final String trimmed = inputText.trim();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The input text contains only spaces\");\n        }\n\n        if (trimmed.length() < 2) {\n            throw new IllegalArgumentException(\"The input must contain at least two characters\");\n        }\n\n        final char[] inputArray = trimmed.toCharArray();\n        final char[] reversed = new char[inputArray.length];\n\n        for (int i = 0; i < inputArray.length; i++) {\n            reversed[inputArray.length - i - 1] = inputArray[i];\n        }\n\n        return new String(reversed);\n    }"
    }
  },
  {
    "title": "Selection Sort",
    "body": "Implement Selection Sort is a comparison-based sorting algorithm",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public static int[] selectionSorting(final int... inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length < 2) {\n            throw new IllegalArgumentException(\"The array must contain at least two elements.\");\n        }\n\n        for (int i = 0; i < inputArray.length - 1; i++) {\n            int minimalValue = i;\n            for (int j = i + 1; j < inputArray.length; j++) {\n                if (inputArray[j] < inputArray[minimalValue]) {\n                    minimalValue = j;\n                }\n            }\n\n            if (minimalValue != i) {\n                final int temp = inputArray[minimalValue];\n                inputArray[minimalValue] = inputArray[i];\n                inputArray[i] = temp;\n            }\n        }\n\n        return Arrays.copyOf(inputArray, inputArray.length);\n    }"
    }
  },
  {
    "title": "Singleton",
    "body": "Implement a singleton pattern",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class Singleton {\n\n    private static volatile Singleton instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n\n        return instance;\n    }\n}"
    }
  },
  {
    "title": "Stack",
    "body": "Implement stack",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class Stack {\n    private final int[] stackArray;\n    private final int capacity;\n    private int top;\n\n    public Stack(int capacity) {\n        if (capacity <= 0) {\n            throw new IllegalArgumentException(\"The stack capacity must be greater than zero\");\n        }\n\n        this.capacity = capacity;\n\n        this.stackArray = new int[capacity];\n\n        this.top = -1;\n    }\n\n    public void push(int element) {\n        if (isFull()) {\n            throw new IllegalStateException(\"Stack is full\");\n        }\n        stackArray[++top] = element;\n    }\n\n    public int pop() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Stack is empty\");\n        }\n        return stackArray[top--];\n    }\n\n    public int peek() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Stack is empty\");\n        }\n        return stackArray[top];\n    }\n\n    public boolean isEmpty() {\n        return top == -1;\n    }\n\n    public boolean isFull() {\n        return top == capacity - 1;\n    }"
    }
  },
  {
    "title": "Queue",
    "body": "Implement queue",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class Queue {\n\n    private final int[] arr;\n    private int front;\n    private int rear;\n    private final int capacity;\n    private int count;\n\n\n    Queue(int size) {\n        arr = new int[size];\n        capacity = size;\n        front = 0;\n        rear = -1;\n        count = 0;\n    }\n\n    public void dequeue() {\n        if (isEmpty()) {\n            System.out.println(\"Underflow\\nProgram Terminated\");\n            System.exit(-1);\n        }\n\n        int x = arr[front];\n\n        System.out.println(\"Removing \" + x);\n\n        front = (front + 1) % capacity;\n        count--;\n\n    }\n\n    public void enqueue(int item) {\n        if (isFull()) {\n            System.out.println(\"Overflow\\nProgram Terminated\");\n            System.exit(-1);\n        }\n\n        System.out.println(\"Inserting \" + item);\n\n        rear = (rear + 1) % capacity;\n        arr[rear] = item;\n        count++;\n    }\n\n    public int peek() {\n        if (isEmpty()) {\n            System.out.println(\"Underflow\\nProgram Terminated\");\n            System.exit(-1);\n        }\n        return arr[front];\n    }\n\n    public int size() {\n        return count;\n    }\n\n    public boolean isEmpty() {\n        return (size() == 0);\n    }\n\n    public boolean isFull() {\n        return (size() == capacity);\n    }"
    }
  },
  {
    "title": "Remove one array from another array",
    "body": "Implement function for remove all the elements of the array1 from array2",
    "example": "elements in first array [100, 200, 300, 400, 500, 600]\nelements in second array [300, 500]\nfirst array after removing second array from first array\n[100, 200, 400, 600]",
    "level": "easy",
    "solution": {
      "content": "public static int[] subtractSecondArrayFromFirst(final int[] firstArray, final int... secondArray) {\n        List<Integer> firstList = new ArrayList<>(Arrays.stream(firstArray).boxed().toList());\n        List<Integer> secondList = Arrays.stream(secondArray).boxed().toList();\n\n        firstList.removeAll(secondList);\n\n        return firstList.stream().mapToInt(Integer::intValue).toArray();\n    }"
    }
  },
  {
    "title": "Find second min and max value in array",
    "body": "Given an array arr[] of size N, find the second max and second smallest element in an array.",
    "example": "nput: arr[] = {12, 13, 1, 10, 34, 1}; Output: 10 13",
    "level": "easy"
  },
  {
    "title": "Count words in String",
    "body": "Given a string, count the number of words in it. The words are separated by the following characters: space (' ') or new line ('\\n') or tab ('\\t') or a combination of these.",
    "example": "text = Hello world, result = 2",
    "level": "easy"
  },
  {
    "title": "Change the first word with last in String",
    "body": "Implement a function which change the first word with last in String",
    "example": "text = Hello world, result => world Hello",
    "level": "easy",
    "solution": {
      "content": "public String changeFirstAndLastWordsInSentence(final String text) {\n        Objects.requireNonNull(text, \"The sentence cannot be null\");\n\n        if (text.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence is empty or contains only whitespace.\");\n        }\n\n        String[] wordsArray = text.split(\"\\\\s+\");\n        if (wordsArray.length < 2) {\n            throw new IllegalArgumentException(\"The sentence must contain at least two words.\");\n        }\n\n        String firstItem = wordsArray[0];\n        wordsArray[0] = wordsArray[wordsArray.length - 1];\n        wordsArray[wordsArray.length - 1] = firstItem;\n\n        return String.join(\" \", wordsArray);\n    }"
    }
  },
  {
    "title": "Change the first element with last in Array",
    "body": "Implement a function which Change the first element with last in Array",
    "example": "[1,2,3,4], result => [4,2,3,1]",
    "level": "easy"
  },
  {
    "title": "Number of Armstrong",
    "body": "The k-digit number N is an Armstrong number if and only if the k-th power of each digit sums to N.\n\nGiven a positive integer N, return true if and only if it is an Armstrong number.",
    "example": "Input: 153\nOutput: true\nExplanation: \n153 is a 3-digit number, and 153 = 1^3 + 5^3 + 3^3; Input: 123\nOutput: false\nExplanation: \n123 is a 3-digit number, and 123 != 1^3 + 2^3 + 3^3 = 36.",
    "level": "easy",
    "solution": {
      "content": "public static boolean armstrongNumber(final int number) {\n        int temp = number;\n        int sum = 0;\n        int length = String.valueOf(number).length();\n\n        while (temp > 0) {\n            int digit = temp % 10;\n\n            sum += (int) Math.pow(digit, length);\n\n            temp /= 10;\n        }\n\n        return sum == number;\n    }"
    }
  },
  {
    "title": "Alternate capitalization",
    "body": "Given a string, capitalize the letters that occupy even indexes and odd indexes separately, and return as shown below. Index 0 will be considered even.",
    "example": "For example, capitalize(\"abcdef\") = ['AbCdEf', 'aBcDeF']. The input should be a lowercase string with no spaces)",
    "level": "easy",
    "solution": {
      "content": "public String[] capitalize(final String inputText) {\n        Objects.requireNonNull(inputText, \"The input cannot be null\");\n\n        final String trimmed = inputText.trim().toLowerCase();\n\n        if (trimmed.isEmpty()) {\n            throw new IllegalArgumentException(\"The input contains only spaces\");\n        }\n\n        StringBuilder evenCaps = new StringBuilder();\n        StringBuilder oddCaps = new StringBuilder();\n\n        for (int i = 0; i < trimmed.length(); i++) {\n            char c = trimmed.charAt(i);\n            if (i % 2 == 0) {\n                evenCaps.append(Character.toUpperCase(c));\n                oddCaps.append(c);\n            } else {\n                evenCaps.append(c);\n                oddCaps.append(Character.toUpperCase(c));\n            }\n        }\n\n        return new String[]{evenCaps.toString(), oddCaps.toString()};\n    }"
    }
  },
  {
    "title": "Valid Anagram",
    "body": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "example": "Example 1:\n\nInput: s = \"anagram\", t = \"nagaram\"\n\nOutput: true; Input: s = \"rat\", t = \"car\"\n\nOutput: false",
    "level": "easy",
    "solution": {
      "content": "public boolean isAnagram(final String first, final String second) {\n        Objects.requireNonNull(first, \"The first array cannot be null\");\n        Objects.requireNonNull(second, \"The second array cannot be null\");\n\n        char[] firstArray = first.trim().toLowerCase().toCharArray();\n        char[] secondArray = second.trim().toLowerCase().toCharArray();\n\n        if (firstArray.length != secondArray.length) {\n            return false;\n        }\n\n        Arrays.sort(firstArray);\n        Arrays.sort(secondArray);\n\n        return Arrays.equals(firstArray, secondArray);\n    }"
    }
  },
  {
    "title": "Add Binary",
    "body": "Given two binary strings a and b, return their sum as a binary string.",
    "example": "Example 1:\n\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"; Example 2:\n\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"",
    "level": "easy",
    "solution": {
      "content": "private static String addBinary(final String a, final String b) {\n        return Integer.toBinaryString(Integer.parseInt(a, 2) + Integer.parseInt(b, 2));\n    }"
    }
  },
  {
    "title": "Warm days",
    "body": "Find the number of days when the temperature was higher or equal to a certain set temperature.",
    "example": "{25, 30, 20, 28, 22, 35, 18}, temp = 25, result = 3",
    "level": "easy",
    "solution": {
      "content": "private static int countWarmDays(int threshold, int[] data) {\n        int count = 0;\n        for (int datum : data) {\n            if (datum > threshold) {\n                count = count + 1;\n            }\n        }\n        return count;\n    }"
    }
  },
  {
    "title": "Find First Palindromic String in the Array",
    "body": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\n\nA string is palindromic if it reads the same forward and backward.",
    "example": "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first; Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
    "level": "easy",
    "solution": {
      "content": "public static String firstPalindromeInArray(final String[] words) {\n        for (String word : words) {\n            if (new StringBuilder(word).reverse().toString().equals(word)) {\n                return word;\n            }\n        }\n        return \"\";\n    }"
    }
  },
  {
    "title": "Zero max",
    "body": "Return a version of the given array where each zero value in the array is replaced by the\n    largest odd value to the right of the zero in the array.\n    If there is no odd value to the right of the zero, leave the zero as a zero.",
    "example": "zeroMax([0, 5, 0, 3])  [5, 5, 3, 3]\n    zeroMax([0, 4, 0, 3])  [3, 4, 3, 3]\n        zeroMax([0, 1, 0])  [1, 1, 0]",
    "level": "easy",
    "solution": {
      "content": "public int[] zeroMax(final int[] inputArray) {\n        int maxValue = Integer.MIN_VALUE;\n\n        int[] result = Arrays.copyOf(inputArray, inputArray.length);\n\n        Objects.requireNonNull(inputArray, \"Input array must not be null\");\n\n        if (inputArray.length < 2) {\n            return new int[0];\n        }\n\n        for (int i = result.length - 1; i >= 0; i--) {\n            if (result[i] % 2 != 0) {\n                maxValue = Math.max(maxValue, result[i]);\n            }\n\n            if (result[i] == 0 && maxValue != Integer.MIN_VALUE) {\n                result[i] = maxValue;\n            }\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Double sort",
    "body": "Implement Double sorting, in the context of sorting algorithms, generally refers to sorting a list based on two criteria.",
    "example": "",
    "level": "easy"
  },
  {
    "title": "The decorator pattern",
    "body": "Implement Decorator is a structural design pattern",
    "example": "",
    "level": "easy"
  },
  {
    "title": "The builder pattern",
    "body": "Implement The builder pattern",
    "example": "",
    "level": "easy"
  },
  {
    "title": "The reverse integer",
    "body": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).",
    "example": "Input: x = 123\nOutput: 321, Input: x = -123\nOutput: -321, Input: x = 120\nOutput: 21",
    "level": "easy",
    "solution": {
      "content": "public Integer reverseNumbers(Integer number) {\n        var reverse = 0L;\n        var digit = 0;\n\n        while (number != 0) {\n            digit = number % 10;\n            reverse = reverse * 10 + digit;\n            number /= 10;\n        }\n\n        if (reverse > Integer.MAX_VALUE || reverse < Integer.MIN_VALUE) {\n            return 0;\n        }\n\n        return (int) reverse;\n    }"
    }
  },
  {
    "title": "Find Closest Number to Zero",
    "body": "Given an integer array nums of size n, return the number with the value closest to 0 in nums. If there are multiple answers, return the number with the largest value.",
    "example": "Input: nums = [-4,-2,1,4,8]\nOutput: 1, Input: nums = [2,-1,1]\nOutput: 1",
    "level": "easy",
    "solution": {
      "content": "public int findClosetNumberToZero(final int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"The array cannot be null\");\n\n        if (inputArray.length == 0) {\n            throw new IllegalArgumentException(\"The array should contain min 1 item\");\n        }\n\n        int result = inputArray[0];\n\n        for (int number : inputArray) {\n            int absNumber = Math.abs(number);\n            int absResult = Math.abs(result);\n\n            if (absNumber < absResult || (absNumber == absResult && number > result)) {\n                result = number;\n            }\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Counting Bits",
    "body": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.",
    "example": "Input: n = 2, Output: [0,1,1], Explanation:\n0 --> 0\n1 --> 1\n2 --> 10; Input: n = 5\nOutput: [0,1,1,2,1,2]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101",
    "level": "easy"
  },
  {
    "title": "Valid Boomerang",
    "body": "Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.\n\nA boomerang is a set of three points that are all distinct and not in a straight line.",
    "example": "Example 1:\n\nInput: points = [[1,1],[2,3],[3,2]]\nOutput: true; Example 2:\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: false",
    "level": "easy"
  },
  {
    "title": "Count Vowels in a String",
    "body": "Write a method that counts the number of vowels (a, e, i, o, u) in a given string. The method should ignore case.",
    "example": "text = test, result => 1",
    "level": "easy",
    "solution": {
      "content": "public class Exercise {\n    private static final Set<Character> VOWELS = Set.of('a', 'e', 'i', 'o', 'u');\n\n    public long countVowels(final String text) {\n        Objects.requireNonNull(text, \"The sentence cannot be null\");\n\n        final String normalizedText = text.toLowerCase().trim().replaceAll(\"[^a-z]\", \"\");\n\n        if (normalizedText.isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces or no vowels\");\n        }\n\n        return normalizedText\n                .chars()\n                .mapToObj(c -> (char) c)\n                .filter(VOWELS::contains)\n                .count();\n    }\n}"
    }
  },
  {
    "title": "Basic Banking Application (Object-Oriented)",
    "body": "Create a simplified banking application. Define a BankAccount class with attributes like accountNumber, accountHolderName, and balance. The class should have methods for:\n 1. Depositing money.\n 2. Withdrawing money (ensure sufficient balance).\n 3. Displaying account details; Then, create a Bank class that manages multiple BankAccount objects (e.g., using a List or Map). The Bank class should provide methods to:\n 1. Create a new bank account.\n 2. Find an account by account number.\n 3. Perform deposits and withdrawals on specific accounts.\n 4. Display details of all accounts; Hint: This exercise emphasizes object-oriented principles.\n\n",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class BankAccount {\n    private static final Logger LOGGER = Logger.getLogger(BankAccount.class.getName());\n\n    private static final AtomicInteger lastID = new AtomicInteger(1);\n    private final int accountNumber;\n    private final String accountHolderName;\n    private BigDecimal balance;\n\n    public BankAccount(String accountHolderName) {\n        this.accountNumber = lastID.getAndIncrement();\n        this.accountHolderName = accountHolderName;\n        this.balance = BigDecimal.ZERO;\n    }\n\n    public BigDecimal getBalance() {\n        return balance;\n    }\n\n    public int getAccountNumber() {\n        return accountNumber;\n    }\n\n    public String getAccountHolderName() {\n        return accountHolderName;\n    }\n\n    public void depositMoney(final BigDecimal money) {\n        if (money == null || money.compareTo(BigDecimal.ZERO) <= 0) {\n            throw new IllegalArgumentException(\"Deposit amount must be positive.\");\n        }\n\n        LOGGER.log(Level.INFO, \"Account {0}: Current balance before deposit: {1}\",\n                new Object[]{accountNumber, getBalance()});\n\n        this.balance = this.balance.add(money);\n\n        LOGGER.log(Level.INFO, \"Account {0}: Current balance after deposit: {1}\",\n                new Object[]{accountNumber, getBalance()});\n    }\n\n    public void withdrawMoney(final BigDecimal money) {\n        if (money == null || money.compareTo(BigDecimal.ZERO) <= 0) {\n            throw new IllegalArgumentException(\"Withdrawal amount must be positive.\");\n        }\n\n        if (this.balance.compareTo(money) < 0) {\n            throw new IllegalArgumentException(\"The balance %.2f doesn't have another money\".formatted(getBalance()));\n        }\n\n        LOGGER.log(Level.INFO, \"Account {0}: Current balance before withdrawal: {1}\",\n                new Object[]{accountNumber, getBalance()});\n\n        this.balance = this.balance.subtract(money);\n\n        LOGGER.log(Level.INFO, \"Account {0}: Current balance after withdrawal: {1}\",\n                new Object[]{accountNumber, getBalance()});\n    }\n\n    @Override\n    public String toString() {\n        return \"Account ID = %d, Name = %s, Balance = %s\".formatted(this.accountNumber, this.accountHolderName, this.balance.toPlainString());\n    }\n}     public class Bank {\n    private static final Logger LOGGER = Logger.getLogger(Bank.class.getName());\n\n    private final String name;\n    private final Map<Integer, BankAccount> bankAccountList;\n\n    public Bank(String name) {\n        this.name = name;\n        this.bankAccountList = new HashMap<>();\n    }\n\n    public void createNewBankAccount(final BankAccount bankAccount) {\n        BankAccount bankAccountByNumber = findBankAccountByNumber(bankAccount.getAccountNumber());\n        if (bankAccountByNumber == null) {\n            this.bankAccountList.put(bankAccount.getAccountNumber(), bankAccount);\n            LOGGER.info(\"The new bank account created\");\n        }\n    }\n\n    public void addDeposit(final int accountNumber, final BigDecimal amount) {\n        BankAccount bankAccountByNumber = findBankAccountByNumber(accountNumber);\n        if (bankAccountByNumber != null) {\n            bankAccountByNumber.depositMoney(amount);\n        } else {\n            LOGGER.log(Level.INFO, \"Account not found: {0}\", accountNumber);\n            throw new IllegalArgumentException(\"Account not found: {0}\" + accountNumber);\n        }\n    }\n\n    public void addDraw(final int accountNumber, final BigDecimal amount) {\n        BankAccount bankAccountByNumber = findBankAccountByNumber(accountNumber);\n        if (bankAccountByNumber != null) {\n            bankAccountByNumber.withdrawMoney(amount);\n        } else {\n            LOGGER.log(Level.INFO, \"Account not found: {0}\", accountNumber);\n            throw new IllegalArgumentException(\"Account not found: {0}\" + accountNumber);\n        }\n    }\n\n    private BankAccount findBankAccountByNumber(final int accountNumber) {\n        return bankAccountList.get(accountNumber);\n    }\n\n    public Map<Integer, BankAccount> getBankAccountList() {\n        return bankAccountList;\n    }\n\n    @Override\n    public String toString() {\n        return \"The bank with name = %s, and with accounts = [%s]\".formatted(this.name, getBankAccountList());\n    }\n}"
    }
  },
  {
    "title": "Basic Calculator",
    "body": "Create a console-based Java application that acts as a simple calculator. It should prompt the user to enter two numbers and then choose an operation (addition, subtraction, multiplication, or division). After the user makes their selections, the program should perform the calculation and display the result. You should handle potential InputMismatchException for non-numeric input and ArithmeticException for division by zero.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class BasicCalculator {\n    private static final Scanner SCANNER = new Scanner(System.in);\n    private static final Logger LOGGER = Logger.getLogger(BasicCalculator.class.getName());\n\n    public static void main(String[] args) {\n        userInput();\n    }\n\n    private static void userInput() {\n        boolean keepLooping = true;\n\n        while (keepLooping) {\n            LOGGER.log(Level.INFO, \"Enter first and second numbers or 'Q' to quit:\");\n            String firstInput = SCANNER.next().trim();\n            if (firstInput.equalsIgnoreCase(\"q\")) {\n                LOGGER.log(Level.INFO, \"Exit\");\n                return;\n            }\n\n            String secondInput = SCANNER.next().trim();\n            if (secondInput.equalsIgnoreCase(\"q\")) {\n                LOGGER.log(Level.INFO, \"Exit\");\n                return;\n            }\n\n            int a = Integer.parseInt(firstInput);\n            int b = Integer.parseInt(secondInput);\n\n            SCANNER.nextLine();\n\n            System.out.println(\"Enter an operation(addition, subtraction, multiplication, division) or 'Q' to quit: \");\n            String operation = SCANNER.nextLine().trim().toLowerCase();\n            if (operation.equalsIgnoreCase(\"q\")) {\n                LOGGER.log(Level.INFO, \"Exit\");\n                return;\n            }\n\n            try {\n                int result = calculate(a, b, operation);\n                LOGGER.log(Level.INFO, \"The result: {0}\", result);\n            } catch (ArithmeticException | IllegalArgumentException e) {\n                LOGGER.log(Level.WARNING, \"Calculation error: {0}\", e.getMessage());\n            } catch (InputMismatchException e) {\n                LOGGER.log(Level.WARNING, \"Non-numeric input received.\");\n                SCANNER.nextLine();\n            }\n        }\n    }\n\n    public static int calculate(int a, int b, String operation) {\n        return switch (operation) {\n            case \"addition\" -> (a + b);\n            case \"subtraction\" -> (a - b);\n            case \"multiplication\" -> (a * b);\n            case \"division\" -> {\n                if (b == 0) {\n                    throw new ArithmeticException(\"Division by zero is not allowed.\");\n                }\n                yield (a / b);\n            }\n            default -> throw new IllegalArgumentException(\"Invalid operation: \" + operation);\n        };\n    }\n}"
    }
  },
  {
    "title": "Student Management System (Console-Based)",
    "body": "Develop a console application to manage student records. The application should allow users to: \n 1. Add a new student (with properties like ID, name, age, and a list of courses). \n 2. Display details of all students. \n 3. Find a student by ID and display their details. \n 4. Update a student's age or courses.\n 5. Delete a student by ID; \n Hint: Use a List (e.g., ArrayList) to store Student objects. Each Student should be a separate class with appropriate attributes and methods.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public interface StudentOperations {\n\n    boolean addStudent(final Student student);\n\n    boolean updateStudentAge(final int studentId, final int age);\n\n    boolean addStudentCourse(final int studentId, final Course course);\n\n    boolean deleteStudent(final int studentId);\n}\n, public class Student {\n\n    private static final Logger LOGGER = Logger.getLogger(Student.class.getName());\n\n    private static final AtomicInteger idCounter = new AtomicInteger(1);\n\n    private final int studentId;\n    private final String studentName;\n    private int studentAge;\n    private final List<Course> courses;\n\n    public Student(String studentName, int studentAge, List<Course> courses) {\n        this.studentId = idCounter.getAndIncrement();\n        this.studentName = studentName;\n        this.studentAge = studentAge;\n        this.courses = new ArrayList<>(courses);\n    }\n\n    public int getStudentId() {\n        return studentId;\n    }\n\n    public void setStudentAge(int studentAge) {\n        this.studentAge = studentAge;\n    }\n\n    public String getStudentName() {\n        return studentName;\n    }\n\n    public List<Course> getCourses() {\n        return List.copyOf(this.courses);\n    }\n\n    public boolean addCourse(final Course course) {\n        if (this.courses.contains(course)) {\n            LOGGER.warning(\"Course \" + course.name() + \" already exists for student \" + this.studentId);\n            return false;\n        }\n        this.courses.add(course);\n        LOGGER.info(\"Course \" + course.name() + \" added to student \" + this.studentId);\n\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student[id=%d, name=%s, age=%d, courses=%s]\".formatted(this.studentId, this.studentName, this.studentAge, this.courses);\n    }\n}, public class ManageStudentSystem implements StudentOperations {\n\n    private static final Logger LOGGER = Logger.getLogger(ManageStudentSystem.class.getName());\n\n    private String name;\n\n    private List<Student> studentList = new ArrayList<>();\n\n    public ManageStudentSystem(String name) {\n        this.name = name;\n    }\n\n    public void showAllStudents() {\n        this.studentList.forEach(student -> System.out.println(\"The student: \" + student));\n    }\n\n    public Student findStudent(final int studentId) {\n        if (studentId <= 0) {\n            throw new IllegalArgumentException(\"Student ID must be non-zero.\");\n        }\n\n        for (final Student student : studentList) {\n            if (student.getStudentId() == studentId) {\n                LOGGER.info(\"The student  \" + student.getStudentName() + \" found\");\n                return student;\n            }\n        }\n        LOGGER.info(\"The student is not found\");\n        return null;\n    }\n\n    @Override\n    public boolean addStudent(Student student) {\n        if (student.getStudentId() <= 0) {\n            throw new IllegalArgumentException(\"Student ID must be positive.\");\n        }\n\n        final Student existStudent = findStudent(student.getStudentId());\n        if (Objects.isNull(existStudent)) {\n            this.studentList.add(student);\n            LOGGER.info(\"Student added: \" + student.getStudentName());\n            return true;\n        }\n        LOGGER.warning(\"Attempted to add duplicate student ID: \" + student.getStudentId());\n        return false;\n    }\n\n    @Override\n    public boolean updateStudentAge(final int studentId, int age) {\n        if (studentId <= 0 || age <= 0) {\n            throw new IllegalArgumentException(\"Student ID or Age must be non-zero.\");\n        }\n        final Student existStudent = findStudent(studentId);\n        if (!Objects.isNull(existStudent)) {\n\n            existStudent.setStudentAge(age);\n            LOGGER.info(\"For Student: \" + existStudent.getStudentName() + \" the age was changed\");\n            return true;\n        }\n        LOGGER.warning(\"The student doesn't update\");\n        return false;\n    }\n\n    @Override\n    public boolean addStudentCourse(int studentId, final Course course) {\n        final Student existStudent = findStudent(studentId);\n        if (!Objects.isNull(existStudent)) {\n            existStudent.addCourse(course);\n            LOGGER.info(\"For Student: \" + existStudent.getStudentName() + \"the course was added\" + course);\n            return true;\n        }\n        LOGGER.warning(\"For Student didn't add the course\");\n        return false;\n    }\n\n\n    @Override\n    public boolean deleteStudent(final int studentId) {\n        if (studentId == 0) {\n            throw new IllegalArgumentException(\"Student ID must be non-zero.\");\n        }\n\n        final Student existStudent = findStudent(studentId);\n        if (!Objects.isNull(existStudent)) {\n            this.studentList.remove(existStudent);\n            LOGGER.info(\"The Student: \" + existStudent.getStudentName() + \" was delete\");\n            return true;\n        }\n        LOGGER.warning(\"The Student: wasn't delete\");\n        return false;\n    }\n}, record Course(String name) {\n\n    @Override\n    public String toString() {\n        return String.format(\"The course name  = %s\", this.name);\n    }\n}"
    }
  },
  {
    "title": "Simple Inventory Management",
    "body": "Design a small inventory management system for a store. The system should allow users to:\n 1. Add new products (with properties like product ID, name, price, and quantity in stock). \n 2. Display all products and their current stock. \n 3. Update the quantity of a specific product. \n  4. Search for a product by name or ID.\n 5. Remove a product from the inventory; Hint: Again, use a List or Map (e.g., HashMap) to store Product objects, where Product is a separate class. Consider how to handle duplicate product IDs.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public enum Category {\n\n    PRODUCE, DAIRY, CEREAL, MEAT, BEVERAGE;\n} public class InventoryManagement implements InventoryOperations {\n    private static final Logger LOGGER = Logger.getLogger(InventoryManagement.class.getName());\n\n    private final String name;\n\n    private final Map<Integer, Product> productStore = new HashMap<>();\n\n    public InventoryManagement(String name) {\n        this.name = name;\n    }\n\n    public void listInventory() {\n        this.productStore.values().forEach(System.out::println);\n    }\n\n    public List<Product> findProductByName(final String name) {\n        return this.productStore.values()\n                .stream()\n                .filter(product -> product.getName().equalsIgnoreCase(name))\n                .toList();\n    }\n\n    public Optional<Product> findProduct(final int productId) {\n        if (productId <= 0) {\n            throw new IllegalArgumentException(\"The product ID must be non-zero.\");\n        }\n\n        Product exist = this.productStore.getOrDefault(productId, null);\n        if (!Objects.isNull(exist)) {\n            LOGGER.info(\"The product  \" + productId + \" found\");\n            return Optional.of(exist);\n        }\n\n        LOGGER.info(\"The product is not found\");\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return this.productStore.entrySet().stream()\n                .map(entry -> String.format(\"%-15s : and goods  = %s%n\", entry.getKey(), entry.getValue()))\n                .collect(Collectors.joining(\"\\n\"));\n    }\n\n    @Override\n    public void addProduct(final Product product) {\n        if (this.productStore.containsKey(product.getId())) {\n            LOGGER.info(\"The product \" + product.getId() + \" already exists in inventory system\" + this.name);\n            return;\n        }\n\n        this.productStore.put(product.getId(), product);\n        LOGGER.info(\"The product \" + product.getId() + \" added to inventory system\" + this.name);\n    }\n\n    @Override\n    public boolean updateProduct(final int productId, final int quantity) {\n        final Optional<Product> existProduct = findProduct(productId);\n        if (!Objects.isNull(existProduct)) {\n            LOGGER.info(\"The product \" + productId + \" update sucess in inventory system\" + this.name);\n            existProduct.ifPresentOrElse(product -> product.setQuantity(quantity), existProduct::get);\n            return true;\n        }\n        LOGGER.info(\"The product \" + productId + \" wasn't found to inventory system\" + this.name);\n        return false;\n    }\n\n    @Override\n    public boolean deleteProduct(final int productId) {\n        final Optional<Product> existProduct = findProduct(productId);\n        if (!Objects.isNull(existProduct)) {\n            LOGGER.info(\"The product \" + productId + \" removed successfully from inventory system\" + this.name);\n            this.productStore.remove(productId);\n            return true;\n        }\n        LOGGER.info(\"The product \" + productId + \" is not found to inventory system\" + this.name);\n        return false;\n    }\n}   public interface InventoryOperations {\n\n    void addProduct(final Product product);\n\n    boolean updateProduct(final int productId, final int quantity);\n\n    boolean deleteProduct(final int productId);\n}   public class Product {\n    private static final AtomicInteger idCounter = new AtomicInteger(1);\n\n    private final int id;\n    private final String name;\n    private final BigDecimal price;\n    private volatile int quantity;\n    private final Category category;\n\n    public Product(String name, BigDecimal price, int quantity, Category category) {\n        this.category = category;\n        this.id = idCounter.getAndIncrement();\n        this.name = validateName(name);\n        this.price = validatePrice(price);\n        this.quantity = validateQuantity(quantity);\n    }\n\n    private String validateName(String name) {\n        if (name == null || name.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The name is empty or contains only whitespace.\");\n        }\n        return name.trim();\n    }\n\n    private BigDecimal validatePrice(BigDecimal price) {\n        if (price == null || price.compareTo(BigDecimal.ZERO) <= 0) {\n            throw new IllegalArgumentException(\"The price must be positive.\");\n        }\n        return price;\n    }\n\n    private int validateQuantity(int quantity) {\n        if (quantity <= 0) {\n            throw new IllegalArgumentException(\"The quantity must be positive.\");\n        }\n        return quantity;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getQuantity() {\n        return quantity;\n    }\n\n    public void setQuantity(int quantity) {\n        if (quantity <= 0) {\n            throw new IllegalArgumentException(\"The quantity must be positive.\");\n        }\n        this.quantity = quantity;\n    }\n\n    @Override\n    public String toString() {\n        return \"The product [id = %d,  name = %s, price = %.2f, quantity = %d and category = %s]%n\".formatted(this.id, this.name, this.price, this.quantity, this.category);\n    }\n}"
    }
  },
  {
    "title": "Text File Analyzer",
    "body": "Write a Java program that takes a text file as input and performs the following analyses: \n 1. Counts the total number of words in the file.\n 2. Counts the total number of lines in the file.\n 3. Counts the occurrences of each unique word (case-insensitive).\n 4. Finds the 5 most frequent words. Hint: The program should handle FileNotFoundException and other potential IOExceptions. You will need to use FileReader, BufferedReader, and potentially Scanner for file processing, along with data structures like Map for word counts.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public class TextFileAnalyzer {\n    private static final Logger logger = Logger.getLogger(TextFileAnalyzer.class.getName());\n\n    private final Path filePath;\n\n    private String cachedContent;\n\n    public TextFileAnalyzer(String pathToFile) {\n        if (pathToFile == null || pathToFile.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"File path cannot be empty.\");\n        }\n\n        this.filePath = Path.of(pathToFile.trim());\n\n        if (!Files.exists(filePath)) {\n            throw new IllegalArgumentException(\"File does not exist at: \" + filePath);\n        }\n    }\n\n    private String readFileContent() {\n        if (cachedContent == null) {\n            try {\n                cachedContent = Files.readString(filePath, StandardCharsets.UTF_8);\n            } catch (IOException exception) {\n                logger.log(Level.WARNING, \"Error reading file: {0}\", exception.getMessage());\n                cachedContent = \"\";\n            }\n        }\n        return cachedContent;\n    }\n\n    public void countsTotalNumberWordsInFile() {\n        String[] words = readFileContent().toLowerCase().split(\"\\\\W+\");\n        logger.info(\"Total words:\" + words.length);\n    }\n\n    public void countsTotalNumberLinesInFile() {\n        try {\n            try (BufferedReader reader = Files.newBufferedReader(filePath)) {\n                long lines = reader.lines().count();\n                logger.info(\"Total lines:\" + lines);\n            }\n        } catch (IOException exception) {\n            logger.warning(\"Error reading lines\" + exception.getMessage());\n        }\n    }\n\n    public void countsOccurrencesUniqueWordInFile(final boolean top5) {\n        Map<String, Long> freq = Arrays.stream(readFileContent().split(\"\\\\W+\"))\n                .filter(words -> !words.isEmpty())\n                .map(String::toLowerCase)\n                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n\n        if (top5) {\n            freq\n                    .entrySet()\n                    .stream()\n                    .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))\n                    .limit(5)\n                    .forEach(e -> logger.info(e.getKey() + \" : \" + e.getValue()));\n        } else {\n            freq.forEach((key, value) -> logger.info(key + \":\" + value));\n        }\n    }\n}"
    }
  },
  {
    "title": "Check for Prime Number",
    "body": "Write a method that checks whether a given integer is a prime number. Return true if it is prime, otherwise return false.",
    "example": "2: The smallest prime number, and the only even prime number.\n3: Divisible only by 1 and 3.\n5: Divisible only by 1 and 5.\n7: Divisible only by 1 and 7.\n11: Divisible only by 1 and 11",
    "level": "easy",
    "solution": {
      "content": "public boolean checkPrimeNumber(final int number) {\n    if (number <= 1) return false;\n    if (number == 2) return true;\n\n    for (int i = 2; i <= Math.sqrt(number); i++) {\n        if (number % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}"
    }
  },
  {
    "title": "Sum of Digits",
    "body": "Write a method that takes a positive integer and returns the sum of its digits.",
    "example": "For example, 123 should return 6",
    "level": "easy",
    "solution": {
      "content": "public int sumOfDigits(final int number) {\n    int sum = 0;\n    int n = Math.abs(number);\n\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}"
    }
  },
  {
    "title": "Simple Calculator (Switch Case)",
    "body": "Implement a basic calculator that supports +, -, *, and /. The user provides two numbers and an operator, and the method returns the result.",
    "example": "",
    "level": "easy",
    "solution": {
      "content": "public int createSimpleCalculator(final int a, final int b, final String operator) {\n    int result;\n\n    switch (operator.trim()) {\n        case \"+\" -> result = a + b;\n        case \"-\" -> result = a - b;\n        case \"*\" -> result = a * b;\n        case \"/\" -> {\n            if (b == 0) {\n                throw new ArithmeticException(\"Cannot divide by zero\");\n            }\n            result = a / b;\n        }\n        default -> throw new IllegalArgumentException(\"Unsupported operator: \" + operator);\n    }\n\n    return result;\n}"
    }
  },
  {
    "title": "Create a Person Class",
    "body": "Create a Person class with the fields name, age, and email. Add constructors, getters, setters, and a method to display the information.",
    "example": "Hint: Think about validation (input integrity), string formatting and immutability",
    "level": "easy",
    "solution": {
      "content": "public class Person {\n    private final String name;\n    private final int age;\n    private final String email;\n\n    public Person(String name, int age, String email) {\n        if (name.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The name cannot be null\");\n        }\n        this.name = name;\n\n        if (age < 0) throw new IllegalArgumentException(\"Age cannot be negative\");\n        this.age = age;\n\n        if (email.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The email cannot be null\");\n        }\n        this.email = email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"The person name is : %s, with age is : %d, and email =  %s\", this.name, this.age, this.email);\n    }\n}"
    }
  },
  {
    "title": "Greatest Common Divisor of Strings",
    "body": "For two strings s and t, we say \"t divides s\" if and only if s = t + t + t + ... + t + t (i.e., t is concatenated with itself one or more times).\n\nGiven two strings str1 and str2, return the largest string x such that x divides both str1 and str2.",
    "example": "Input: str1 = \"ABCABC\", str2 = \"ABC\"\nOutput: \"ABC\", Input: str1 = \"ABABAB\", str2 = \"ABAB\"\nOutput: \"AB\", Input: str1 = \"LEET\", str2 = \"CODE\"\nOutput: \"\"",
    "level": "easy",
    "solution": {
      "content": ""
    }
  },
  {
    "title": "Temperature Converter",
    "body": "Create a console application that converts temperatures between Celsius and Fahrenheit. The program should:\n 1. Prompt the user to enter a temperature value. \n 2. Prompt the user to specify the original unit (Celsius or Fahrenheit). \n 3. Perform the conversion using the appropriate formulas: \n  -> Celsius to Fahrenheit: F=C9/5+32 \n -> Fahrenheit to Celsius: C=(F32)5/9 \n 4. Display the converted temperature in the new unit. \n 5. Allow the user to perform multiple conversions until they choose to exit.",
    "example": "Implement robust input validation to ensure numeric input and valid unit choices.",
    "level": "easy",
    "solution": {
      "content": "public class TemperatureConverter {\n\n    private static final Scanner SCANNER = new Scanner(System.in);\n    private static final Logger LOGGER = Logger.getLogger(TemperatureConverter.class.getName());\n\n    public static void main(String[] args) {\n        userInput();\n    }\n\n    private static void userInput() {\n        boolean keepLooping = true;\n\n        while (keepLooping) {\n            System.out.println(\"Enter a temperature number or 'Q' to quit:\");\n            String temperatureInput = SCANNER.next().trim();\n            if (temperatureInput.equalsIgnoreCase(\"q\")) {\n                LOGGER.log(Level.INFO, \"Exit\");\n                return;\n            }\n\n            double temperature;\n            try {\n                temperature = Double.parseDouble(temperatureInput);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid temperature input. Please enter a numeric value.\");\n                LOGGER.warning(\"Invalid temperature input: \" + temperatureInput);\n                continue;\n            }\n\n            SCANNER.nextLine();\n\n            System.out.println(\"Is the temperature in Celsius or Fahrenheit? (Type 'C' or 'F' or 'Q' to quit)\");\n            String operation = SCANNER.nextLine().trim().toLowerCase();\n            if (operation.equalsIgnoreCase(\"q\")) {\n                LOGGER.log(Level.INFO, \"User quit at temperature input\");\n                return;\n            }\n\n            try {\n                final double convertedTemperature = converter(temperature, operation);\n                String targetUnit = \"\";\n                if (operation.equals(\"celsius\") || operation.equalsIgnoreCase(\"c\")) {\n                    targetUnit = \"Fahrenheit\";\n                } else if (operation.equals(\"fahrenheit\") || operation.equalsIgnoreCase(\"f\")) {\n                    targetUnit = \"Celsius\";\n                } else {\n                    targetUnit = \"Unknown Unit\";\n                }\n                System.out.printf(\"The convertion temperature: %.3f to %s%n\".formatted(convertedTemperature, targetUnit));\n            } catch (ArithmeticException | IllegalArgumentException e) {\n                System.err.println(\"Error: Invalid conversion unit provided. Please choose 'Celsius' or 'Fahrenheit'.\");\n                LOGGER.log(Level.WARNING, \"Converter error: {0}\", e.getMessage());\n            }\n        }\n        SCANNER.nextLine();\n    }\n\n    public static double converter(final double temperature, final String operation) {\n        return switch (operation) {\n            case \"celsius\", \"c\" -> (temperature * 9.0 / 5.0) + 32.0;\n            case \"fahrenheit\", \"f\" -> (temperature - 32.0) * 5.0 / 9.0;\n            default -> throw new IllegalArgumentException(\"Invalid operation: \" + operation);\n        };\n    }\n}"
    }
  },
  {
    "title": "Simple Command-Line To-Do List",
    "body": "Create a basic command-line application that allows users to manage a to-do list. The application should support the following commands: \n add <task description>: Adds a new task to the list. \n list: Displays all tasks with their corresponding numbers. \n mark <task number>: Marks a task as completed. \n delete <task number>: Removes a task from the list. \n exit: Quits the application.",
    "example": "Use a List (e.g., ArrayList) to store String tasks. Consider how to handle invalid task numbers or commands.",
    "level": "easy",
    "solution": {
      "content": "public class Application {\n    private static final Logger LOGGER = Logger.getLogger(Application.class.getName());\n    private static final Scanner SCANNER = new Scanner(System.in);\n\n    public void runApplication() {\n        final TaskDAO taskDAO = new TaskDAO();\n        final TaskService taskService = new TaskService(taskDAO);\n\n        boolean keepLooping = true;\n\n        while (keepLooping) {\n            try {\n                displayMenu();\n                final String choice = SCANNER.next().trim().toLowerCase();\n                SCANNER.nextLine();\n                switch (choice) {\n                    case \"add\" -> {\n                        LOGGER.log(Level.INFO, \"The add method\");\n                        taskService.add();\n                    }\n                    case \"list\" -> {\n                        LOGGER.log(Level.INFO, \"The list method \");\n                        taskService.getAllTasks();\n                    }\n\n                    case \"mark\" -> {\n                        LOGGER.log(Level.INFO, \"The mark method\");\n                        taskService.markTask();\n                    }\n\n                    case \"delete\" -> {\n                        LOGGER.log(Level.INFO, \"The delete method \");\n                        taskService.delete();\n                    }\n                    case \"exit\" -> {\n                        LOGGER.log(Level.INFO, \"The exist method\");\n                        keepLooping = false;\n                    }\n                    default -> LOGGER.log(Level.INFO, \"{0} not a valid option \", choice);\n                }\n            } catch (IllegalArgumentException | ArithmeticException exception) {\n                LOGGER.warning(exception.getMessage());\n            }\n        }\n    }\n\n    private void displayMenu() {\n        System.out.println(\"\"\"\n                Choose:\n                \n                add - Adds a new task to the list.\n                list - Displays all tasks with their corresponding numbers.\n                mark - Marks a task as completed.\n                delete  - Removes a task from the list.\n                exit - Exit\n                \"\"\");\n    }\n}   public interface IService {\n\n    boolean add();\n\n    void getAllTasks();\n\n    void markTask();\n\n    void delete();\n}   public class Task {\n    private static final AtomicInteger lastId = new AtomicInteger(1);\n\n    private final int id;\n    private final String title;\n    private final String description;\n    private final TaskPriority taskPriority;\n    private boolean isFinished;\n\n    public Task(String title, String description, TaskPriority taskPriority) {\n        this.id = lastId.getAndIncrement();\n        this.title = title;\n        this.description = description;\n        this.taskPriority = taskPriority;\n        this.isFinished = false;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setFinished(boolean finished) {\n        isFinished = finished;\n    }\n\n    @Override\n    public String toString() {\n        return \"[ID=%d] Title: %s | Description: %s | Priority: %s | Status: %s\".formatted(\n                id, title, description, taskPriority, isFinished ? \"Finished\" : \"Not Finished\");\n    }\n}  public class TaskDAO {\n    private static final Logger LOGGER = Logger.getLogger(TaskDAO.class.getName());\n\n    private final List<Task> taskList = new ArrayList<>();\n\n    public List<Task> getAllTasks() {\n        LOGGER.info(\"Get all tasks \" + TaskDAO.class.getName());\n        return taskList;\n    }\n\n    public void addTask(final Task task) {\n        if (Objects.isNull(task)) {\n            LOGGER.warning(\"Add the task issue\" + TaskDAO.class.getName());\n            throw new IllegalArgumentException(\"The task can't be null or empty\");\n        }\n        taskList.add(task);\n    }\n\n    public void removeTask(final Task task) {\n        if (Objects.isNull(task)) {\n            LOGGER.warning(\"remove task issue\" + TaskDAO.class.getName());\n            throw new IllegalArgumentException(\"The task can't be null or empty\");\n        }\n        taskList.remove(task);\n    }\n\n    public boolean findTaskByTitle(final String title) {\n        if (title.trim().isEmpty()) {\n            LOGGER.warning(\"find Task By Title issue\" + TaskDAO.class.getName());\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n        final var tasks = getAllTasks();\n        for (var task : tasks) {\n            if (task.getTitle().equalsIgnoreCase(title)) {\n                return true;\n            }\n        }\n        LOGGER.warning(\"find Task By Title issue\" + TaskDAO.class.getName());\n        return false;\n    }\n\n    public Optional<Task> findTaskByNumber(final int taskNUmber) {\n        if (taskNUmber <= 0) {\n            throw new IllegalArgumentException(\"The taskNumber must be non-zero.\");\n        }\n\n        return getAllTasks().stream().filter(task -> task.getId() == taskNUmber).findFirst();\n    }\n}  public enum TaskPriority {\n    MINOR(\"MINOR\"),\n    MAJOR(\"MAJOR\"),\n    CRITICAL(\"CRITICAL\");\n\n    private final String priority;\n\n    TaskPriority(String priority) {\n        this.priority = priority;\n    }\n\n    public String getPriority() {\n        return priority;\n    }\n\n    public static TaskPriority findByValue(String value) {\n        return Arrays.stream(values())\n                .filter(taskPriority -> taskPriority.getPriority().equalsIgnoreCase(value))\n                .findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\"The %s value is not in the list\".formatted(value)));\n\n    }\n}  public class TaskService implements IService {\n    private static final Logger LOGGER = Logger.getLogger(TaskService.class.getName());\n    private static final Scanner SCANNER = new Scanner(System.in);\n\n    private final TaskDAO taskDao;\n\n    public TaskService(TaskDAO taskDao) {\n        this.taskDao = taskDao;\n    }\n\n    @Override\n    public boolean add() {\n        System.out.println(\"Add title, description, and priority(minor, major or critical) via comma:\");\n        final String inputText = SCANNER.nextLine();\n        final String[] data = inputText.replaceAll(\" +\", \"\").split(\",\");\n        final String userTitle = data[0];\n        final String userDescription = data[1];\n        final String userPriority = data[2];\n\n        if (userTitle.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        if (userDescription.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        if (userPriority.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"The sentence contains only spaces\");\n        }\n\n        if (this.taskDao.findTaskByTitle(userTitle)) {\n            System.out.printf(\"The task with title %s  = is exists in the list\".formatted(userTitle));\n            LOGGER.info(\"The task didn't find\");\n            return false;\n        }\n\n        Task newTask = new Task(userTitle, userDescription, TaskPriority.findByValue(userPriority.toUpperCase()));\n\n        this.taskDao.addTask(newTask);\n\n        LOGGER.info(\"The task was added\");\n\n        System.out.printf(\"The task %s was added%n\".formatted(newTask));\n\n        return true;\n    }\n\n    @Override\n    public void getAllTasks() {\n        LOGGER.info(\"Returns all tasks\");\n        if (this.taskDao.getAllTasks().isEmpty()) {\n            System.out.println(\"The list is emnty\");\n            return;\n        }\n        this.taskDao.getAllTasks().forEach(task -> System.out.println(\"The task:\" + task));\n    }\n\n    @Override\n    public void markTask() {\n        int taskNumber = 0;\n        System.out.println(\"Add a task number, please:\");\n        try {\n            taskNumber = Integer.parseInt(SCANNER.nextLine().trim());\n        } catch (InputMismatchException exception) {\n            System.out.println(\"Invalid number. Please enter a numeric task ID.\");\n            LOGGER.log(Level.WARNING, \"The issue {0}\", exception.getMessage());\n            LOGGER.log(Level.WARNING, \"The stack trace {0}\", exception.getStackTrace());\n            return;\n        }\n\n\n        int finalTaskNumber = taskNumber;\n\n        taskDao.findTaskByNumber(taskNumber).ifPresentOrElse(task -> {\n                    task.setFinished(true);\n                    System.out.println(\"The task was marked\");\n                },\n                () -> {\n                    LOGGER.warning(\"The task with ID = %s doesn't exist, The task wasn't marked %n\".formatted(finalTaskNumber));\n                    System.out.println(\"The task wasn't marked\");\n                });\n    }\n\n    @Override\n    public void delete() {\n        System.out.println(\"Add a task number, please:\");\n        int taskNumber = 0;\n        try {\n            taskNumber = SCANNER.nextInt();\n        } catch (InputMismatchException exception) {\n            System.out.println(\"Invalid number. Please enter a numeric task ID.\");\n            LOGGER.log(Level.WARNING, \"The issue {0}\", exception.getMessage());\n            LOGGER.log(Level.WARNING, \"The stack trace {0}\", exception.getStackTrace());\n        }\n\n        this.taskDao.findTaskByNumber(taskNumber).ifPresentOrElse(task -> {\n            taskDao.removeTask(task);\n            System.out.println();\n        }, () -> {\n            LOGGER.warning(\"The task wasn't deleted as it doesn't exist.\");\n            System.out.println(\"The task was deleted\");\n        });\n\n    }\n}"
    }
  },
  {
    "title": "Basic File Operations (Copy & Rename)",
    "body": "Write a Java program that allows a user to perform basic file operations. The program should: \n 1. Prompt the user for a source file path. \n 2. Prompt the user for a destination file path. \n 3. Implement a feature to copy the content of the source file to the destination file. \n 4. Implement a feature to rename the source file to a new name provided by the user (after copying, or as a separate operation).",
    "example": "Handle potential IOExceptions (e.g., file not found, permission denied) and provide informative messages to the user. Use java.io.File or java.nio.file.Path and Files for operations.",
    "level": "easy",
    "solution": {
      "content": "public interface IFileOperations {\n    void showFiles();\n\n    void readFile();\n\n    void copyFile();\n\n    void renameFile();\n\n    void deleteFile();\n}  public class FileOperationsService implements IFileOperations {\n    private static final Logger LOGGER = Logger.getLogger(FileOperationsService.class.getName());\n    private static final String BACK_TO_MENU_TEXT = \"Back to Main menu\";\n    private static final String NO_FILE_FOUND = \"No file found\";\n\n    private final Scanner scanner;\n\n    public FileOperationsService(Scanner scanner) {\n        this.scanner = scanner;\n    }\n\n    @Override\n    public void showFiles() {\n        System.out.println(\"Add the path for the read files in directory, please:\");\n        final String directory = this.scanner.nextLine();\n        try {\n            listFiles(Path.of(directory));\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"The issue message, in show file method is: \", exception);\n        }\n    }\n\n    @Override\n    public void readFile() {\n        System.out.println(\"Add the path for the read source file or type 'q' for back to the main menu, please:\");\n        final String pathToFile = this.scanner.nextLine().trim();\n\n        if (isQuitCommand(pathToFile)) {\n            return;\n        }\n\n        final Path path = Path.of(pathToFile);\n\n        if (!Files.exists(path)) {\n            System.out.println(NO_FILE_FOUND);\n            return;\n        }\n\n        try {\n            final String content = Files.readString(path);\n            System.out.println(content);\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"The issue message, in read file method is: \", exception);\n            System.out.printf(\"The file %s didn't read %n\".formatted(pathToFile));\n        }\n    }\n\n    @Override\n    public void copyFile() {\n        System.out.println(\"Add the path for the copy source file, and path to destination file. Or type 'q' for back to the main menu, please:\");\n        final String sourceFile = this.scanner.nextLine();\n        final String destinationFile = this.scanner.nextLine();\n\n        if (isQuitCommand(sourceFile)) {\n            return;\n        }\n        if (isQuitCommand(destinationFile)) {\n            return;\n        }\n\n        if (!Files.exists(Path.of(sourceFile))) {\n            System.out.println(NO_FILE_FOUND);\n            return;\n        }\n\n        try {\n            Files.copy(Path.of(sourceFile), Path.of(destinationFile), StandardCopyOption.REPLACE_EXISTING);\n            System.out.printf(\"The file %s, copied to destination file %s with content %n\".formatted(sourceFile, destinationFile));\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"The issue message, in copy file method is: \", exception);\n            System.out.printf(\"The file %s didn't copy %n\".formatted(sourceFile));\n        }\n    }\n\n    @Override\n    public void renameFile() {\n        System.out.println(\"Add the path for the rename file, and new file name. Or type 'q' for back to the main menu, please:\");\n        final String pathToFile = this.scanner.nextLine().trim();\n        final String newFileName = this.scanner.nextLine().trim();\n\n        if (isQuitCommand(pathToFile)) {\n            return;\n        }\n\n        if (isQuitCommand(newFileName)) {\n            return;\n        }\n\n        if (!Files.exists(Path.of(pathToFile))) {\n            System.out.println(NO_FILE_FOUND);\n            return;\n        }\n\n        try {\n            Files.move(Path.of(pathToFile), Paths.get(pathToFile).resolveSibling(newFileName));\n            System.out.printf(\"The file %s renamed successfully with new file name is %s%n\".formatted(pathToFile, newFileName));\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"The issue message, in rename file method is: \", exception);\n            System.out.printf(\"The file %s didn't rename %n\".formatted(pathToFile));\n        }\n    }\n\n    @Override\n    public void deleteFile() {\n        System.out.println(\"Add the path for the delete source file or type 'q' for back to the main menu, please:\");\n        final String pathToFile = this.scanner.nextLine();\n        final Path path = Path.of(pathToFile);\n\n        if (isQuitCommand(pathToFile)) {\n            return;\n        }\n\n        if (!Files.exists(path)) {\n            System.out.println(NO_FILE_FOUND);\n            return;\n        }\n\n        if (!Files.isDirectory(path)) {\n            System.out.println(\"It is not a directory\");\n        }\n\n        try {\n            Files.deleteIfExists(path);\n            System.out.println(\"File deleted successfully.\");\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"The issue message, in delete file method is:\", exception);\n            System.out.printf(\"The file %s was not found%n\".formatted(pathToFile));\n        }\n    }\n\n    private void listFiles(final Path directory) throws IOException {\n        if (!Files.isDirectory(directory)) {\n            throw new IllegalArgumentException(\"Provided path is not a directory or incorrect path: \" + directory);\n        }\n\n        try (Stream<Path> pathStream = Files.list(directory);) {\n            pathStream.filter(Files::isRegularFile)\n                    .map(path -> path.getFileName().toString())\n                    .forEach(file -> System.out.printf(\".... %s%n\".formatted(file)));\n        }\n    }\n\n    private static boolean isQuitCommand(String input) {\n        if (input.equalsIgnoreCase(\"q\")) {\n            LOGGER.log(Level.INFO, BACK_TO_MENU_TEXT);\n            return true;\n        }\n        return false;\n    }\n}   public class Main {\n    private static final Logger LOGGER = Logger.getLogger(Main.class.getName());\n    private static final Scanner SCANNER = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        runApplication();\n    }\n\n    public static void runApplication() {\n        final FileOperationsService operationsService = new FileOperationsService(SCANNER);\n        boolean keepLooping = true;\n\n        while (keepLooping) {\n            try {\n                displayMenu();\n                final String choice = SCANNER.next().trim().toLowerCase();\n                SCANNER.nextLine();\n\n                switch (choice) {\n                    case \"show\" -> {\n                        LOGGER.log(Level.INFO, \"The show method\");\n                        operationsService.showFiles();\n                    }\n\n                    case \"read\" -> {\n                        LOGGER.log(Level.INFO, \"The read method\");\n                        operationsService.readFile();\n                    }\n                    case \"copy\" -> {\n                        LOGGER.log(Level.INFO, \"The copy method \");\n                        operationsService.copyFile();\n                    }\n\n                    case \"rename\" -> {\n                        LOGGER.log(Level.INFO, \"The rename method\");\n                        operationsService.renameFile();\n                    }\n\n                    case \"delete\" -> {\n                        LOGGER.log(Level.INFO, \"The delete method \");\n                        operationsService.deleteFile();\n                    }\n                    case \"exit\" -> {\n                        LOGGER.log(Level.INFO, \"The exit method\");\n                        keepLooping = false;\n                    }\n                    default -> LOGGER.log(Level.INFO, \"{0} not a valid option \", choice);\n                }\n            } catch (IllegalArgumentException | ArithmeticException exception) {\n                LOGGER.warning(exception.getMessage());\n            }\n        }\n    }\n\n    private static void displayMenu() {\n        System.out.println(\"\"\"\n                You need to write the name of the action:\n                \n                1\uFE0F. show:     Show files in directory.\n                2\uFE0F. read:     Read source file.\n                3\uFE0F. copy:     Copy content of the source file to the destination file.\n                4\uFE0F. rename:   Rename the source file to a new name provided by the use.\n                5\uFE0F. delete:   Delete file.\n                6\uFE0F. exit:     Exit\n                \n                \"\"\");\n    }\n}"
    }
  },
  {
    "title": "Basic E-commerce Shopping Cart",
    "body": "Design a console application that simulates a simple e-commerce shopping cart. The application should allow users to: \n 1. View available products (each product having an ID, name, price, and perhaps a category). \n 2. Add products to the cart by product ID and quantity. \n 3. View items in the cart with their quantities and subtotal for each. \n  4. Remove items from the cart by product ID. \n  5. Calculate the total cost of all items in the cart.",
    "example": "You'll need a Product class and a ShoppingCart class. The ShoppingCart should manage a collection of products (e.g., using a Map where the key is product ID and the value is the quantity, or a custom CartItem class).",
    "level": "easy",
    "solution": {
      "content": ""
    }
  },
  {
    "title": "Ransom Note",
    "body": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\n\nEach letter in magazine can only be used once in ransomNote.",
    "example": "Example 1:\n\nInput: ransomNote = \"a\", magazine = \"b\"\nOutput: false\nExample 2:\n\nInput: ransomNote = \"aa\", magazine = \"ab\"\nOutput: false\nExample 3:\n\nInput: ransomNote = \"aa\", magazine = \"aab\"\nOutput: true",
    "level": "easy",
    "solution": {
      "content": "public boolean canConstruct(String ransomNote, String magazine) {\n        final Map<Character, Integer> frequencyLetter = new HashMap<>();\n\n        for (char letter : magazine.toCharArray()) {\n            frequencyLetter.merge(letter, 1, Integer::sum);\n        }\n\n        for (char letter : ransomNote.toCharArray()) {\n            if (frequencyLetter.getOrDefault(letter, 0) > 0) {\n                frequencyLetter.merge(letter, -1, Integer::sum);\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }"
    }
  },
  {
    "title": "3Sum",
    "body": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.",
    "example": "Input: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]], Input: nums = [0,1,1]\nOutput: [], Input: nums = [0,0,0]\nOutput: [[0,0,0]]",
    "level": "medium",
    "solution": {
      "content": "public List<List<Integer>> threeSum(int[] inputArray) {\n        Objects.requireNonNull(inputArray, \"Input array cannot be null\");\n        List<List<Integer>> result = new ArrayList<>();\n\n        if (inputArray.length < 3) return result;\n\n        Arrays.sort(inputArray);\n\n        for (int i = 0; i < inputArray.length - 2; i++) {\n            if (i > 0 && inputArray[i] == inputArray[i - 1]) continue; // Skip duplicates for i\n\n            int left = i + 1;\n            int right = inputArray.length - 1;\n\n            while (left < right) {\n                int sum = inputArray[i] + inputArray[left] + inputArray[right];\n\n                if (sum == 0) {\n                    result.add(Arrays.asList(inputArray[i], inputArray[left], inputArray[right]));\n                    left++;\n                    right--;\n\n                    while (left < right && inputArray[left] == inputArray[left - 1]) left++;\n                    while (left < right && inputArray[right] == inputArray[right + 1]) right--;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "Longest Palindromic Substring",
    "body": "Given a string s, return the longest palindromic substring in s.",
    "example": "Example 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"",
    "level": "medium",
    "solution": {
      "content": "public String longestPalindrome(String s) {\n        if (Objects.isNull(s) || s.isEmpty()) {\n            return \"\";\n        }\n\n        String longest = \"\";\n\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i; j < s.length(); j++) {\n                if (isPoly(s, i, j) && (j - i + 1) > longest.length()) {\n                    longest = s.substring(i, j + 1);\n                }\n            }\n        }\n        return longest;\n    }\n\n    private boolean isPoly(final String sentence, int start, int end) {\n        while (start < end) {\n            if (sentence.charAt(start) != sentence.charAt(end)) {\n                return false;\n            }\n            start++;\n            end--;\n        }\n\n        return true;\n    }"
    }
  },
  {
    "title": "Concurrent Web Scraper",
    "body": "Develop a Java application that concurrently scrapes data from a list of predefined URLs. For each URL, your application should download the HTML content and extract specific information, such as all links (<a> tags) and their href attributes.",
    "example": "Concurrency: Implement this using Java's Concurrency API. A good approach would be to use an ExecutorService to manage a pool of threads. Each thread should be a Callable that scrapes a single URL and returns the extracted links. \n Data Handling: The results from all threads should be collected into a single, thread-safe data structure (e.g., ConcurrentHashMap, CopyOnWriteArrayList). \n  Error Handling: The application must handle network-related issues gracefully, such as connection timeouts or IOExceptions. \n Implementation: Consider using a library like Jsoup to parse the HTML content, as it simplifies the process of traversing the DOM and extracting data.",
    "level": "medium",
    "solution": {
      "content": "public class Main {\n    private static final Logger logger = Logger.getLogger(Main.class.getName());\n\n    public static void main(String[] args) throws InterruptedException {\n        final ConcurrentHashMap<String, List<String>> results = new ConcurrentHashMap<>();\n\n        final List<String> stringList = new ArrayList<>(List.of(\n                \"https://www.google.com/\",\n                \"https://www.wikipedia.org/\"\n        ));\n\n        try (final ExecutorService executorService = Executors.newCachedThreadPool()) {\n            final List<Callable<Void>> tasks = stringList\n                    .stream().map(url -> (Callable<Void>) () -> {\n                        final List<String> links = scrapHtml(url);\n                        results.put(url, links);\n                        return null;\n                    }).toList();\n\n            executorService.invokeAll(tasks);\n\n            results.forEach((key, value) -> logger.log(Level.INFO, \" %s : %s\".formatted(key, value)));\n        }\n    }\n\n    private static List<String> scrapHtml(final String destinationUrl) throws IOException, InterruptedException {\n        if (!destinationUrl.startsWith(\"http\")) {\n            throw new IllegalArgumentException(\"The destination url, must contain URI shema\");\n        }\n\n        try (final HttpClient client = HttpClient.newBuilder().followRedirects(HttpClient.Redirect.ALWAYS).build()) {\n            final HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(destinationUrl))\n                    .build();\n\n            final HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n            final Document doc = Jsoup.parse(response.body());\n            final Elements links = doc.select(\"a\");\n            return links.stream()\n                    .map(link -> link.attr(\"abs:href\"))\n                    .filter(href -> !href.isEmpty())\n                    .toList();\n        }\n    }\n}"
    }
  },
  {
    "title": "The shortest path",
    "body": "A string consisting of the letters 'X', 'Y' and '0' is given.\nIt is necessary to find the shortest distance between the letters 'X' and 'y' to get the value 0 if 'X' or 'Y' are missing.",
    "example": "\"\" -> \n\"XX\" -> \n\"XY\" -> 1\n\"YOX\" -> 2\n\"000XOOYOXO\" -> 2\n\"000X0OY\" -> 2",
    "level": "medium"
  },
  {
    "title": "Binary Tree Right Side View",
    "body": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
    "example": "Input: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4];   Input: root = [1,null,3]\nOutput: [1,3];    Input: root = []\nOutput: []",
    "level": "medium"
  },
  {
    "title": "House Robber",
    "body": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "example": "Input: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4;   Input: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.",
    "level": "medium"
  },
  {
    "title": "Rotate Array",
    "body": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\n",
    "example": "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n; Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]",
    "level": "medium"
  },
  {
    "title": "Repeated DNA Sequences",
    "body": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\n\nFor example, \"ACGAATTCCG\" is a DNA sequence.\nWhen studying DNA, it is useful to identify repeated sequences within the DNA.\n\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.",
    "example": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]; Input: s = \"AAAAAAAAAAAAA\"\nOutput: [\"AAAAAAAAAA\"]",
    "level": "medium"
  },
  {
    "title": "Daily Temperatures",
    "body": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
    "example": "Input: temperatures = [73,74,75,71,69,72,76,73], Output: [1,1,4,2,1,1,0,0] \n Input: temperatures = [30,40,50,60], Output: [1,1,1,0] \n Input: temperatures = [30,60,90], Output: [1,1,0]",
    "level": "medium",
    "solution": {
      "content": "public static int[] dailyTemperatures(final int[] temps) {\n        Objects.requireNonNull(temps, \"The array cannot be null\");\n\n        int[] result = new int[temps.length];\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for (int i = 0; i < temps.length; i++) {\n\n            while (!stack.isEmpty() && temps[i] > temps[stack.peek()]) {\n                final int index = stack.pop();\n                result[index] = i - index;\n            }\n            stack.push(i);\n        }\n        return result;\n    }"
    }
  },
  {
    "title": "Longest Word in Dictionary",
    "body": "Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words.\n If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.\n Note that the word should be built from left to right with each additional character being added to the end of a previous word. \n",
    "example": "Input: words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"], Output: \"world\", Explanation: The word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\". \n Input: words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"], Output: \"apple\", Explanation: Both \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\". \n",
    "level": "medium"
  },
  {
    "title": "Reverse Words in a String",
    "body": "Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
    "example": "Input: s = \"the sky is blue\", Output: \"blue is sky the\";\n Input: s = \"  hello world  \", Output: \"world hello\", Explanation: Your reversed string should not contain leading or trailing spaces.;\n Input: s = \"a good   example\", Output: \"example good a\", Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.",
    "level": "medium"
  },
  {
    "title": "The Truck problem",
    "body": "You need to write three classes:\n 1st class car, the car has a default maximum speed of 100 km/h, the name and condition are empty/ loaded\n2 - The car's heir is a passenger car. By default, any passenger car is not loaded. However, this state can only change after the car is created (not during creation). \n3 - The car's heir is a cargo truck. By default, any truck is loaded. However, this state can change both during the creation of the car and after. \nAt the same time, the maximum speed of this car depends on the workload. If it is loaded, then its speed drops by half.\nAs well: \nIt is necessary to implement the ability to compare trucks by name and current maximum speed.\n It is necessary to write code that verifies the correctness of the implementation of tasks (speed versus workload, truck comparisons)",
    "example": "Nothing",
    "level": "medium",
    "solution": {
      "content": "class Car {\n    protected String name;\n    protected boolean condition; // true = loaded, false = empty\n    protected int maxSpeed;\n\n    public Car(String name, boolean condition) {\n        this.name = name;\n        this.condition = condition;\n        this.maxSpeed = 100;\n    }\n\n    @Override\n    public String toString() {\n        return \"Car(name=\" + name + \", condition=\" + (condition ? \"Loaded\" : \"Empty\") + \", maxSpeed=\" + maxSpeed + \" km/h)\";\n    }\n}\n\nclass PassengerCar extends Car {\n    public PassengerCar(String name) {\n        super(name, false); // Always starts as empty\n    }\n\n    public void load(boolean condition) {\n        this.condition = condition; // Can change after creation\n    }\n}\n\nclass CargoTruck extends Car implements Comparable<CargoTruck> {\n    public CargoTruck(String name, boolean condition) {\n        super(name, condition);\n        updateSpeed();\n    }\n\n    private void updateSpeed() {\n        this.maxSpeed = condition ? 50 : 100; // Speed is halved when loaded\n    }\n\n    public void load(boolean condition) {\n        this.condition = condition;\n        updateSpeed();\n    }\n\n    @Override\n    public int compareTo(CargoTruck other) {\n        int nameComparison = this.name.compareTo(other.name);\n        if (nameComparison == 0) {\n            return Integer.compare(this.maxSpeed, other.maxSpeed);\n        }\n        return nameComparison;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        CargoTruck truck = (CargoTruck) obj;\n        return name.equals(truck.name) && maxSpeed == truck.maxSpeed;\n    }\n\n    @Override\n    public String toString() {\n        return \"CargoTruck(name=\" + name + \", condition=\" + (condition ? \"Loaded\" : \"Empty\") + \", maxSpeed=\" + maxSpeed + \" km/h)\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"--- Creating Vehicles ---\");\n        Car car1 = new Car(\"GenericCar\", true);\n        System.out.println(car1);\n\n        PassengerCar pcar = new PassengerCar(\"Passenger1\");\n        System.out.println(pcar);\n        pcar.load(true);\n        System.out.println(\"After loading passenger car: \" + pcar);\n\n        CargoTruck truck1 = new CargoTruck(\"TruckA\", true);\n        CargoTruck truck2 = new CargoTruck(\"TruckB\", false);\n        System.out.println(truck1);\n        System.out.println(truck2);\n\n        System.out.println(\"--- Changing Load States ---\");\n        truck1.load(false);\n        truck2.load(true);\n        System.out.println(truck1);\n        System.out.println(truck2);\n\n        System.out.println(\"--- Comparing Trucks ---\");\n        CargoTruck truck3 = new CargoTruck(\"TruckA\", false);\n        System.out.println(\"Truck1 == Truck3? \" + truck1.equals(truck3));\n        System.out.println(\"Truck1 < Truck2? \" + (truck1.compareTo(truck2) < 0));\n        System.out.println(\"Truck2 < Truck3? \" + (truck2.compareTo(truck3) < 0));\n    }"
    }
  },
  {
    "title": "Validate IP Address",
    "body": "Write a method that takes a string and determines whether it is a valid IPv4 or IPv6 address. Return \"IPv4\" if valid IPv4, \"IPv6\" if valid IPv6, or \"Neither\" if invalid.",
    "example": "\"172.16.254.1\"  \"IPv4\", \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"  \"IPv6, \"256.256.256.256\"  \"Neither\"",
    "level": "medium",
    "solution": {
      "content": "public class ValidateIPAddress {\n    public String validateIPAddress(final String ipAddress) {\n        Objects.requireNonNull(ipAddress, \"The sentence cannot be null\");\n        final String trimmed = ipAddress.trim().toLowerCase();\n\n        if (trimmed.isEmpty()) return \"Neither\";\n\n        if (isIpV4Valid(trimmed)) return \"IPv4\";\n        if (isIpV6Valid(trimmed)) return \"IPv6\";\n\n        return \"Neither\";\n    }\n\n    private boolean isIpV4Valid(final String text) {\n        String[] items = text.split(\"\\\\.\", -1);\n        if (items.length != 4) return false;\n\n        for (String item : items) {\n            if (item.isEmpty() || (item.length() > 1 && item.startsWith(\"0\"))) return false;\n            try {\n                int value = Integer.parseInt(item);\n                if (value < 0 || value > 255) return false;\n            } catch (NumberFormatException exception) {\n                return false;\n            }\n\n        }\n        return true;\n    }\n\n    private boolean isIpV6Valid(final String text) {\n        String[] items = text.split(\":\", -1);\n        if (items.length != 8) return false;\n\n        for (String item : items) {\n            if (item.isEmpty() || item.length() > 4) return false;\n\n            for (char symbol : item.toCharArray()) {\n                if ((!Character.isDigit(symbol) && ((Character.toLowerCase(symbol) < 'a') || (Character.toLowerCase(symbol) > 'f')))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}"
    }
  },
  {
    "title": "Implement a Custom Stack with Min Function",
    "body": "Design and implement a CustomStack class that supports push(int), pop(), peek(), and getMin()  all in constant time.\nThe getMin() method should return the smallest element in the stack.",
    "example": "Concepts Tested:\n\nStack implementation\n\nConstant-time algorithms\n\nAuxiliary data structures",
    "level": "medium"
  },
  {
    "title": "Group Anagrams",
    "body": "Given a list of strings, group them by anagrams. Return a list of grouped anagrams, where each group contains strings that are anagrams of each other.",
    "example": "Example Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Expected Output Format: [\n  [\"eat\", \"tea\", \"ate\"],\n  [\"tan\", \"nat\"],\n  [\"bat\"]\n]; Concepts Tested:\n\nString manipulation\n\nHashing and grouping\n\nWorking with Map and List collections",
    "level": "medium"
  },
  {
    "title": "Implement a Thread-Safe Singleton Logger",
    "body": "Create a singleton Logger class that ensures only one instance is used throughout the application. The logger should be thread-safe and lazily initialized. Add a method to write messages to a log file with timestamps.",
    "example": "",
    "level": "medium",
    "solution": {
      "content": "public class SingletonLogger {\n    private static final Logger logger = Logger.getLogger(SingletonLogger.class.getName());\n\n    private static SingletonLogger log;\n\n    private static final String LOG_FILE = \"singleton_log.txt\";\n\n    private SingletonLogger() {\n        try {\n            FileHandler fileHandler = new FileHandler(LOG_FILE, true);\n            fileHandler.setFormatter(new SimpleFormatter());\n            if (logger.getHandlers().length == 0) {\n                logger.addHandler(fileHandler);\n            }\n        } catch (IOException exception) {\n            logger.log(Level.WARNING, \"Failed to set up file handler: {0}\", exception.getMessage());\n        }\n    }\n\n    public static synchronized SingletonLogger getLog() {\n        if (log == null) {\n            log = new SingletonLogger();\n        }\n        return log;\n    }\n\n    public void log(Level level, String message) {\n        logger.log(level, message);\n    }\n}"
    }
  },
  {
    "title": "Create a Custom HashMap Implementation",
    "body": "Implement a simplified version of HashMap<K, V> using an array of buckets and linked lists for collision handling. Provide support for basic operations: put(), get(), remove(), and containsKey()",
    "example": "",
    "level": "medium"
  },
  {
    "title": "Implement an Event Scheduler System",
    "body": "Design and implement a class EventScheduler that allows scheduling tasks to run at a specified future time. Each task should be a Runnable. Provide functionality to cancel scheduled tasks.",
    "example": "",
    "level": "medium"
  },
  {
    "title": "Build a File Search Utility",
    "body": "Develop a program that recursively searches through a directory and its subdirectories to find all files matching a given filename pattern (e.g., all .txt files containing a certain keyword).",
    "example": "",
    "level": "medium",
    "solution": {
      "content": "public class SearchFile {\n    private static final Logger logger = Logger.getLogger(SearchFile.class.getName());\n\n    public List<String> searchWithWc(final Path rootDir, final String pattern) {\n        Objects.requireNonNull(rootDir, \"The rootDir variable cannot be null\");\n        Objects.requireNonNull(pattern, \"The pattern variable cannot be null\");\n\n        List<String> matchesList = new ArrayList<>();\n\n        final FileVisitor<Path> matcherVisitor = new SimpleFileVisitor<>() {\n            @Override\n            public @NotNull FileVisitResult visitFile(Path file, final @NotNull BasicFileAttributes attribs) {\n                final PathMatcher matcher = FileSystems.getDefault().getPathMatcher(pattern);\n                if (matcher.matches(file.getFileName())) {\n                    matchesList.add(file.toAbsolutePath().toString());\n                }\n                return FileVisitResult.CONTINUE;\n            }\n        };\n        try {\n            Files.walkFileTree(rootDir, matcherVisitor);\n        } catch (IOException exception) {\n            logger.log(Level.WARNING, \"Error during file traversal: {0}\", exception.getMessage());\n        }\n        return matchesList;\n    }\n}"
    }
  },
  {
    "title": "Implement of a thread-safe singleton logger",
    "body": "Create a singleton Logger class that ensures only one instance is used throughout the application. The logger should be thread-safe and lazily initialized. Add a method to write messages to a log file with timestamps.",
    "example": "",
    "level": "medium",
    "solution": {
      "content": "public class SingletonLogger {\n    private static final Logger logger = Logger.getLogger(SingletonLogger.class.getName());\n\n    private static SingletonLogger log;\n\n    private static final String LOG_FILE = \"singleton_log.txt\";\n\n    private SingletonLogger() {\n        try {\n            FileHandler fileHandler = new FileHandler(LOG_FILE, true);\n            fileHandler.setFormatter(new SimpleFormatter());\n            if (logger.getHandlers().length == 0) {\n                logger.addHandler(fileHandler);\n            }\n        } catch (IOException exception) {\n            logger.log(Level.WARNING, \"Failed to set up file handler: {0}\", exception.getMessage());\n        }\n    }\n\n    public static synchronized SingletonLogger getLog() {\n        if (log == null) {\n            log = new SingletonLogger();\n        }\n        return log;\n    }\n\n    public void log(Level level, String message) {\n        logger.log(level, message);\n    }\n}"
    }
  },
  {
    "title": "Create a Custom HashMap Implementation",
    "body": "Implement a simplified version of HashMap<K, V> using an array of buckets and linked lists for collision handling. Provide support for basic operations: put(), get() and remove()",
    "example": "",
    "level": "medium",
    "solution": {
      "content": "public class HashMapCustom<K, V> {\n    static class Entry<K, V> {\n        K key;\n        V value;\n        HashMapCustom.Entry<K, V> next;\n\n        public Entry(K key, V value, HashMapCustom.Entry<K, V> next) {\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n    }\n\n    private static final float LOAD_FACTOR = 0.75f;\n    private int size;\n    private int capacity = 4;\n    @SuppressWarnings(\"unchecked\")\n    private HashMapCustom.Entry<K, V>[] bucket = new HashMapCustom.Entry[capacity];\n\n    public HashMapCustom() {\n        capacity = 4;\n        bucket = (HashMapCustom.Entry<K, V>[]) new HashMapCustom.Entry[capacity];\n    }\n\n    public void put(K key, V value) {\n        if (key == null) return;\n\n        if ((float) size / capacity >= LOAD_FACTOR) {\n            resize();\n        }\n\n        int hash = hash(key);\n        HashMapCustom.Entry<K, V> current = bucket[hash];\n\n        if (current == null) {\n            bucket[hash] = new HashMapCustom.Entry<>(key, value, null);\n            size++;\n            return;\n        }\n\n        while (current != null) {\n            if (current.key.equals(key)) {\n                current.value = value;\n                return;\n            }\n            if (current.next == null) {\n                current.next = new HashMapCustom.Entry<>(key, value, null);\n                size++;\n                return;\n            }\n            current = current.next;\n        }\n    }\n\n    public V get(K key) {\n        if (key == null) return null;\n        int hash = hash(key);\n        HashMapCustom.Entry<K, V> current = bucket[hash];\n        while (current != null) {\n            if (current.key.equals(key)) return current.value;\n            current = current.next;\n        }\n        return null;\n    }\n\n    public boolean remove(K key) {\n        if (key == null) return false;\n        int hash = hash(key);\n        HashMapCustom.Entry<K, V> current = bucket[hash];\n        HashMapCustom.Entry<K, V> prev = null;\n\n        while (current != null) {\n            if (current.key.equals(key)) {\n                if (prev == null) {\n                    bucket[hash] = current.next;\n                } else {\n                    prev.next = current.next;\n                }\n                size--;\n                return true;\n            }\n            prev = current;\n            current = current.next;\n        }\n\n        return false;\n    }\n\n    private int hash(K key) {\n        return Math.abs(key.hashCode()) % capacity;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void resize() {\n        int newCapacity = capacity * 2;\n        HashMapCustom.Entry<K, V>[] oldBucket = bucket;\n        bucket = (HashMapCustom.Entry<K, V>[]) new HashMapCustom.Entry[newCapacity];\n        capacity = newCapacity;\n        size = 0;\n\n        for (HashMapCustom.Entry<K, V> head : oldBucket) {\n            while (head != null) {\n                put(head.key, head.value);\n                head = head.next;\n            }\n        }\n    }\n\n    public int size() {\n        return size;\n    }"
    }
  },
  {
    "title": "Build a File Search Utility",
    "body": "Develop a program that recursively searches through a directory and its subdirectories to find all files matching a given filename pattern (e.g., all .txt files containing a certain keyword).",
    "example": "",
    "level": "medium",
    "solution": {
      "content": "public class SearchFile {\n    private static final Logger logger = Logger.getLogger(SearchFile.class.getName());\n\n    public List<String> searchWithWc(final Path rootDir, final String pattern) {\n        Objects.requireNonNull(rootDir, \"The rootDir variable cannot be null\");\n        Objects.requireNonNull(pattern, \"The pattern variable cannot be null\");\n\n        List<String> matchesList = new ArrayList<>();\n\n        final FileVisitor<Path> matcherVisitor = new SimpleFileVisitor<>() {\n            @Override\n            public @NotNull FileVisitResult visitFile(Path file, final @NotNull BasicFileAttributes attribs) {\n                final PathMatcher matcher = FileSystems.getDefault().getPathMatcher(pattern);\n                if (matcher.matches(file.getFileName())) {\n                    matchesList.add(file.toAbsolutePath().toString());\n                }\n                return FileVisitResult.CONTINUE;\n            }\n        };\n        try {\n            Files.walkFileTree(rootDir, matcherVisitor);\n        } catch (IOException exception) {\n            logger.log(Level.WARNING, \"Error during file traversal: {0}\", exception.getMessage());\n        }\n        return matchesList;\n    }\n}"
    }
  },
  {
    "title": "RESTful API Client",
    "body": "Create a Java application that interacts with a third-party RESTful API. A good choice would be the GitHub API to retrieve information about a user's repositories or the OpenWeatherMap API to get weather data for a city.",
    "example": "HTTP Communication: Use a modern HTTP client library like OkHttp or java.net.http.HttpClient (from Java 11+) to make GET requests to the API endpoints. \n JSON Parsing: The API responses will be in JSON format. Use a library such as Jackson or Gson to deserialize the JSON into custom Java objects (POJOs or records). \n Object-Oriented Design: Create a dedicated class for each resource you're retrieving (e.g., a Repository class or a Weather class). \n  Error Handling: Implement robust error handling for different HTTP status codes (e.g., 404 Not Found, 401 Unauthorized, 500 Internal Server Error).",
    "level": "medium",
    "solution": {
      "content": "public class WeatherService {\n    private static final Logger LOGGER = Logger.getLogger(WeatherService.class.getName());\n    private static final OkHttpClient OK_HTTP_CLIENT = new OkHttpClient();\n    private static final Gson GSON = new Gson();\n\n    Optional<WeatherResponse> sendGetRequest(final String url) {\n        final Request request = new Request.Builder().url(url).build();\n\n        try (Response response = OK_HTTP_CLIENT.newCall(request).execute()) {\n\n            handleStatusCode(response);\n\n            final ResponseBody body = Objects.requireNonNull(response.body(), \"The response body is empty\");\n\n            final WeatherResponse entity = GSON.fromJson(body.string(), WeatherResponse.class);\n\n            if (Objects.isNull(entity)) {\n                throw new IllegalArgumentException(\"The entity is empty\");\n            }\n            return Optional.of(entity);\n        } catch (IOException exception) {\n            LOGGER.log(Level.WARNING, \"Error fetching weather data\", exception);\n            return Optional.empty();\n        }\n    }\n\n    private void handleStatusCode(Response response) throws IOException {\n        int code = response.code();\n        switch (code) {\n            case HTTP_UNAUTHORIZED -> throw new IOException(\"Invalid API key (401)\");\n            case HTTP_BAD_REQUEST -> throw new IOException(\"Incorrect path (400)\");\n            case HTTP_NOT_FOUND -> throw new IOException(\"City not found (404)\");\n            case 429 -> throw new IOException(\"Rate limit exceeded (429)\");\n            default -> {\n                if (code >= HTTP_INTERNAL_ERROR) throw new IOException(\"Server error (\" + code + \")\");\n            }\n        }\n    }\n}    public class UrlBuilder {\n    private final String url;\n    private final String lat;\n    private final String lon;\n    private final String apiKey;\n    private final String unit;\n\n    public UrlBuilder(String url, String lat, String lon, String apiKey, String unit) {\n        this.url = url;\n        this.lat = lat;\n        this.lon = lon;\n        this.apiKey = apiKey;\n        this.unit = unit;\n    }\n\n    public String buildUrlString() {\n        return String.format(\"%s?lat=%s&lon=%s&appid=%s&units=%s\",\n                url, lat, lon, apiKey, unit);\n    }\n\n    public static class Builder {\n        private String url;\n        private String lat;\n        private String lon;\n        private String apiKey;\n        private String unit;\n\n        public Builder setUrl(String url) {\n            this.url = url;\n\n            return this;\n        }\n\n        public Builder setLat(String lat) {\n            this.lat = lat;\n            return this;\n        }\n\n        public Builder setLon(String lon) {\n            this.lon = lon;\n            return this;\n        }\n\n        public Builder setApiKey(String apiKey) {\n            this.apiKey = apiKey;\n\n            return this;\n        }\n\n        public Builder setUnit(String unit) {\n            this.unit = unit;\n            return this;\n        }\n\n        public UrlBuilder builder() {\n            return new UrlBuilder(url, lat, lon, apiKey, unit);\n        }\n    }\n}   public class WeatherResponse{\n\tprivate int visibility;\n\tprivate int timezone;\n\tprivate Main main;\n\tprivate Clouds clouds;\n\tprivate Sys sys;\n\tprivate int dt;\n\tprivate Coord coord;\n\tprivate List<WeatherItem> weather;\n\tprivate String name;\n\tprivate int cod;\n\tprivate int id;\n\tprivate String base;\n\tprivate Wind wind; }"
    }
  },
  {
    "title": "Database Interaction with JDBC",
    "body": "Build a Java application that uses the Java Database Connectivity (JDBC) API to interact with a relational database. You can use an in-memory database like H2 or SQLite to avoid a complex setup.",
    "example": "CRUD Operations: The application should be able to perform all CRUD (Create, Read, Update, Delete) operations on a single table (e.g., a Product table with columns like id, name, price, stock). \n Resource Management: You must use the try-with-resources statement to ensure that Connection, Statement, and ResultSet objects are always closed properly, preventing resource leaks. \n Prepared Statements: To prevent SQL injection vulnerabilities, use PreparedStatement for all database queries that involve user input. \n Configuration: Externalize the database connection details (URL, username, password) into a configuration file (e.g., config.properties) and load them at runtime.",
    "level": "medium",
    "solution": {
      "content": "public class ProductDao {\n    private static final String INSERT_QUERY = \"INSERT INTO goods.product (id, name, price, stock) VALUES (?,?,?,?)\";\n    private static final String UPDATE_QUERY = \"UPDATE goods.product SET name = ?, price = ?, stock = ? WHERE ID = ?\";\n    private static final String DELETE_QUERY = \"DELETE FROM goods.product WHERE id = ?\";\n    private static final String FIND_BY_ID_QUERY = \"SELECT * FROM goods.product WHERE id = ?\";\n\n    private final Connection connection;\n\n    public ProductDao(Connection connection) {\n        this.connection = connection;\n    }\n\n    public void insert(final Connection connection, final Product product) throws SQLException {\n        try (final PreparedStatement statement = connection.prepareStatement(INSERT_QUERY);) {\n            statement.setInt(1, product.id());\n            statement.setString(2, product.name());\n            statement.setBigDecimal(3, product.price());\n            statement.setInt(4, product.stock());\n            statement.executeUpdate();\n        } catch (final SQLException exception) {\n            throw new DataAccessException(\"Failed to Insert product\", exception);\n        }\n    }\n\n    public void update(final Connection connection, final Product product) throws SQLException {\n        try (final PreparedStatement statement = connection.prepareStatement(UPDATE_QUERY);) {\n            statement.setString(1, product.name());\n            statement.setBigDecimal(2, product.price());\n            statement.setInt(3, product.stock());\n            statement.setInt(4, product.id());\n            statement.executeUpdate();\n        } catch (final SQLException exception) {\n            throw new DataAccessException(\"Failed to update product\", exception);\n        }\n    }\n\n    public void delete(final Connection connection, final int productId) throws SQLException {\n        try (final PreparedStatement statement = connection.prepareStatement(DELETE_QUERY);) {\n            statement.setInt(1, productId);\n            statement.executeUpdate();\n        } catch (SQLException exception) {\n            throw new DataAccessException(\"Failed to delete product\", exception);\n        }\n    }\n\n    public Optional<Product> findById(final Connection connection, final int id) {\n        try (PreparedStatement stmt = connection.prepareStatement(FIND_BY_ID_QUERY)) {\n            stmt.setInt(1, id);\n            try (ResultSet rs = stmt.executeQuery()) {\n                if (rs.next()) {\n                    return Optional.of(mapToProduct(rs));\n                }\n            }\n        } catch (SQLException exception) {\n            throw new DataAccessException(\"Find by id failed\", exception);\n        }\n        return Optional.empty();\n    }\n\n    private Product mapToProduct(ResultSet rs) throws SQLException {\n        final int id = rs.getInt(\"id\");\n        final String name = rs.getString(\"name\");\n        final BigDecimal price = rs.getBigDecimal(\"price\");\n        final int stock = rs.getInt(\"stock\");\n        return new Product(id, name, price, stock);\n    }\n}  record Product(int id, String name, BigDecimal price, int stock) {\n}\n\npublic class Main {\n    private static final Logger LOGGER = Logger.getLogger(Main.class.getName());\n\n    public static void main(String[] args) {\n        final Properties properties = new Properties();\n\n        try (final InputStream inputStream = Files.newInputStream(Path.of(\"jdbc.properties\"), READ)) {\n            properties.load(inputStream);\n\n            final var dataSource = new MysqlDataSource();\n\n            dataSource.setServerName(properties.getProperty(\"serverName\"));\n            dataSource.setPort(Integer.parseInt(properties.getProperty(\"port\")));\n            dataSource.setDatabaseName(properties.getProperty(\"databaseName\"));\n            dataSource.setUser(properties.getProperty(\"user\"));\n            dataSource.setPassword(properties.getProperty(\"password\"));\n            Connection connection = null;\n            try {\n                connection = dataSource.getConnection();\n                connection.setAutoCommit(false);\n                final ProductDao dao = new ProductDao(connection);\n\n                dao.insert(connection, new Product(1, \"orange\", new BigDecimal(10), 5));\n                dao.update(connection, new Product(1, \"apple\", new BigDecimal(\"100\"), 15));\n                dao.delete(connection, 1);\n\n                Optional<Product> result = dao.findById(connection, 1);\n\n                result.ifPresentOrElse(\n                        p -> LOGGER.info(\"Product: \" + p),\n                        () -> LOGGER.info(\"Product not found\"));\n                connection.commit();\n            } catch (final SQLException exception) {\n                try {\n                    if (!Objects.isNull(connection)) {\n                        connection.rollback();\n                    }\n                } catch (SQLException e) {\n                    throw new DataAccessException(\"Failed to rollback data\", e);\n                }\n                throw new DataAccessException(\"Database issue\", exception);\n            }\n        } catch (IOException exception) {\n            LOGGER.warning(exception.getMessage());\n        }\n    }\n}  public class DataAccessException extends RuntimeException {\n    public DataAccessException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n"
    }
  },
  {
    "title": "Simple In-Memory Messaging Queue",
    "body": "Design and implement a basic, thread-safe, in-memory messaging queue. The queue should be able to store a fixed number of messages and be used by multiple threads simultaneously.",
    "example": "Concurrency: Your queue must be thread-safe. It should support a put() method for producers to add messages and a take() method for consumers to retrieve messages. \n Blocking Operations:\n\nIf the queue is full, the put() method should block until space becomes available.\n\nIf the queue is empty, the take() method should block until a message is added.\n\n  Implementation: The best way to implement this is by using Java's built-in concurrency utilities. A BlockingQueue (like ArrayBlockingQueue or LinkedBlockingQueue) is a perfect fit for this task. Alternatively, for a deeper challenge, you could use a lower-level approach with wait(), notifyAll(), and ReentrantLock to build the blocking behavior yourself.",
    "level": "medium",
    "solution": {
      "content": "public class InMemoryQueueService implements QueueService {\n    private static final Logger LOGGER = Logger.getLogger(InMemoryQueueService.class.getName());\n    private final Map<Long, BlockingQueue<Message>> queues = new ConcurrentHashMap<>();\n    private final int capacity;\n\n    public InMemoryQueueService(int capacity) {\n        this.capacity = capacity;\n    }\n\n    @Override\n    public void put(final Long queueId, final String message) {\n        try {\n            queues.computeIfAbsent(queueId, _ -> new ArrayBlockingQueue<>(capacity))\n                    .put(new Message(message));\n        } catch (InterruptedException exception) {\n            LOGGER.warning(exception.getMessage());\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    @Override\n    public Message take(final Long queueId) {\n        final BlockingQueue<Message> queue = Optional.ofNullable(queues.get(queueId))\n                .orElseThrow(() -> new QueueNotFoundException(String.format(\"Queue with ID =%s was not found\", queueId)));\n        try {\n            return queue.take();\n        } catch (InterruptedException exception) {\n            System.err.println(exception.getMessage());\n            Thread.currentThread().interrupt();\n            throw new QueueNotFoundException(String.format(\"Queue with ID =%s was not found\", queueId));\n        }\n    }\n\n    @Override\n    public boolean delete(final Long queueId) {\n        return queues.remove(queueId).isEmpty();\n    }\n}   public interface QueueService {\n    void put(Long queueId, String message);\n\n    Message take(Long queueId);\n\n    boolean delete(Long queueId);\n}\n  public class QueueNotFoundException extends RuntimeException {\n    public QueueNotFoundException(String message) {\n        super(message);\n    }\n}  public class Message {\n    private static final AtomicLong MESSAGE_ID_GENERATOR = new AtomicLong(1);\n    private final Long messageId;\n    private final String messageBody;\n\n    public Message(String messageBody) {\n        this.messageId = MESSAGE_ID_GENERATOR.getAndIncrement();\n\n        this.messageBody = messageBody;\n    }\n\n    public long getMessageId() {\n        return messageId;\n    }\n\n    public String getMessageBody() {\n        return messageBody;\n    }\n}"
    }
  },
  {
    "title": "Basic Spring Boot Microservice (CRUD)",
    "body": "Create a simple RESTful API using the Spring Boot framework. The microservice should manage a single resource (e.g., a Book resource with properties like title, author, and isbn). \n API Endpoints: Implement REST endpoints for basic CRUD operations: \n POST /api/books - Create a new book. \n GET /api/books/{id} - Read a book by its ID. \n GET /api/books - Read all books. \n  PUT /api/books/{id} - Update an existing book. \n DELETE /api/books/{id} - Delete a book by its ID.",
    "example": "Persistence: Use Spring Data JPA with an in-memory database like H2 to manage the data persistence layer.\n\nDependency Injection: Leverage Spring's dependency injection (@Autowired) to manage the components of your application (Controller, Service, Repository).\n\nError Handling: Use @ControllerAdvice or @ExceptionHandler annotations to provide custom, meaningful error responses for scenarios like \"resource not found\" or \"invalid input.\"",
    "level": "medium",
    "solution": {
      "content": "@Log4j2\n@Service\n@AllArgsConstructor\n@Transactional\npublic class BookService implements IBookService {\n\n    private final BookRepository bookRepository;\n\n    private final BookMapper mapper;\n\n    @Override\n    public BookDto addBook(BookDto bookDto) {\n        if (Objects.isNull(bookDto)) {\n            log.warn(\"The bookDto is null\");\n            throw new IllegalArgumentException(\"The entity cannot be null\");\n        }\n\n        final Optional<BookEntity> existBook = bookRepository.findByIsbn(bookDto.getIsbn());\n\n        if (existBook.isPresent()) {\n            log.warn(\"The entity is present in database\");\n            throw new BookFoundException(\"The book was found in database\");\n        }\n\n        final BookDto saved = mapper.convertToDto(bookRepository.save(mapper.convertToEntity(bookDto)));\n\n        log.info(\"Book saved successfully: [uuid={}, isbn={}]\", saved.getUuid(), saved.getIsbn());\n\n        return saved;\n    }\n\n    @Override\n    public BookDto readBook(UUID uuid) {\n        BookEntity existBook = bookRepository\n                .findById(uuid)\n                .orElseThrow(\n                        () -> new BookNotFoundException(String.format(\"The book with UUID = %s was not found\".formatted(uuid))));\n\n        return mapper.convertToDto(existBook);\n    }\n\n    @Override\n    public List<BookDto> readBooks() {\n        return StreamSupport.stream(bookRepository.findAll().spliterator(), false)\n                .map(mapper::convertToDto)\n                .toList();\n    }\n\n    @Override\n    public BookDto updateBook(BookDto bookDto) {\n        if (Objects.isNull(bookDto)) {\n            log.warn(\"The entity is null\");\n            throw new IllegalArgumentException(\"The entity cannot be null\");\n        }\n\n        final Optional<BookEntity> existBook = bookRepository.findById(bookDto.getUuid());\n\n        if (existBook.isEmpty()) {\n            log.warn(\"The entity is empty\");\n            throw new BookNotFoundException(String.format(\"The book with UUID = %s was not found\".formatted(bookDto.getUuid())));\n        }\n\n        log.info(\"The entity update successfully\");\n\n        return mapper.convertToDto(bookRepository.save(mapper.convertToEntity(bookDto)));\n    }\n\n    @Override\n    public void deleteBook(UUID uuid) {\n        if (!bookRepository.existsById(uuid)) {\n            throw new BookNotFoundException(\"Book with UUID = %s not found\".formatted(uuid));\n        }\n\n        bookRepository.deleteById(uuid);\n\n        log.info(\"Book deleted successfully [uuid={}]\", uuid);\n\n    }\n}  @Validated\n@RestController\n@RequestMapping(\"/api/v1/books\")\n@AllArgsConstructor\npublic class BookController {\n\n    private final BookService bookService;\n\n    @PostMapping\n    ResponseEntity<BookDto> addBook(@RequestBody @Valid BookDto bookDto) {\n        final BookDto savedEntity = bookService.addBook(bookDto);\n        return ResponseEntity.status(HttpStatus.CREATED).body(savedEntity);\n    }\n\n    @GetMapping\n    ResponseEntity<List<BookDto>> readBooks() {\n        return ResponseEntity.ok(bookService.readBooks());\n    }\n\n    @GetMapping(\"/{uuid}\")\n    ResponseEntity<BookDto> readBook(final @PathVariable UUID uuid) {\n        final BookDto existBook = bookService.readBook(uuid);\n        return ResponseEntity.status(HttpStatus.OK).body(existBook);\n    }\n\n    @PutMapping\n    ResponseEntity<BookDto> updateBook(@Valid @RequestBody BookDto bookDto) {\n        final BookDto updatedBook = bookService.updateBook(bookDto);\n        return ResponseEntity.status(HttpStatus.OK).body(updatedBook);\n    }\n\n    @DeleteMapping(\"/{uuid}\")\n    ResponseEntity<Void> deleteBook(final @PathVariable UUID uuid) {\n        bookService.deleteBook(uuid);\n        return ResponseEntity.status(HttpStatus.NO_CONTENT).build();\n    }\n} @Repository\npublic interface BookRepository extends CrudRepository<BookEntity, UUID> {\n    Optional<BookEntity> findByIsbn(Long isbn);\n}"
    }
  },
  {
    "title": "Permutations",
    "body": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n",
    "example": "Input: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n  Input: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
    "level": "medium",
    "solution": {
      "content": ""
    }
  },
  {
    "title": "Implement a Simple In-Memory Library System",
    "body": "Build a small book management system in Java. \n Implement a Book class with:\n\nUUID id\n\nString title\n\nString author\n\nLong isbn\n\nint availableCopies \n mplement a LibraryService class with methods:\n\nBook addBook(Book book)  Adds a new book (if isbn already exists, increase availableCopies).\n\nOptional<Book> findBookByIsbn(Long isbn)  Finds a book by ISBN.\n\nList<Book> searchByAuthor(String author)  Returns all books by a given author (case-insensitive).\n\nboolean borrowBook(Long isbn)  Decreases availableCopies by 1 if available.\n\nvoid returnBook(Long isbn)  Increases availableCopies by 1.\n\nList<Book> getAllBooksSortedByTitle()  Returns all books sorted alphabetically. \n  Constraints:\n\nUse Java Streams where appropriate.\n\nEnsure thread safety of the service (multiple users may borrow/return books at the same time).\n\nWrite unit tests for at least borrowBook and returnBook.",
    "example": "LibraryService library = new LibraryService();\n\nlibrary.addBook(new Book(UUID.randomUUID(), \"Clean Code\", \"Robert Martin\", 12345L, 3));\nlibrary.addBook(new Book(UUID.randomUUID(), \"Effective Java\", \"Joshua Bloch\", 54321L, 2));\n\nlibrary.borrowBook(12345L); // now \"Clean Code\" has 2 copies\nlibrary.borrowBook(12345L); // now \"Clean Code\" has 1 copy\nlibrary.returnBook(12345L); // now \"Clean Code\" has 2 copies again",
    "level": "medium",
    "solution": {
      "content": "public class Book {\n    private UUID id;\n    private final String title;\n    private final String author;\n    private final Long isbn;\n    private final AtomicInteger availableCopies;\n\n    public Book(UUID id, String title, String author, Long isbn, int availableCopies) {\n        this.id = id;\n        this.title = title;\n        this.author = author;\n        this.isbn = isbn;\n        this.availableCopies = new AtomicInteger(availableCopies);\n    }\n\n    public int getAvailableCopies() {\n        return availableCopies.get();\n    }\n\n    public void increaseCopies() {\n        availableCopies.incrementAndGet();\n    }\n\n    public boolean decreaseCopies() {\n        while (true) {\n            int current = availableCopies.get();\n            if (current == 0) return false;\n            if (availableCopies.compareAndSet(current, current - 1)) return true;\n        }\n    }\n\n    public UUID getId() {\n        return id;\n    }\n\n    public void setId(UUID id) {\n        this.id = id;\n    }\n\n    public Long getIsbn() {\n        return isbn;\n    }\n\n    public String getAuthor() {\n        return author;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    @Override\n    public String toString() {\n        return \"Book [title=%s, author=%s, isbn=%d, availableCopies=%d]\".formatted(title, author, isbn, availableCopies.get());\n    }\n}  public interface ILibrary {\n    Book addBook(Book book);\n\n    Optional<Book> findBookByIsbn(Long isbn);\n\n    List<Book> searchByAuthor(String author);\n\n    boolean borrowBook(Long isbn);\n\n    void returnBook(Long isbn);\n\n    List<Book> getAllBooksSortedByTitle();\n}  public class LibraryDao {\n\n    private static final Logger LOGGER = Logger.getLogger(LibraryDao.class.getName());\n\n    private final Map<Long, Book> books = new ConcurrentHashMap<>();\n\n    public Book addBook(final Book book) {\n        if (Objects.isNull(book)) {\n            LOGGER.warning(\"The book entity null or empty\");\n            throw new IllegalArgumentException(\"The book can't be null or empty\");\n        }\n\n        LOGGER.info(\"The book was added\");\n        final Book savedBook = this.books.putIfAbsent(book.getIsbn(), book);\n\n        if (!Objects.isNull(savedBook)) {\n            throw new IllegalArgumentException(\"The book with ISBN = %d is present in library\".formatted(book.getIsbn()));\n        }\n\n        LOGGER.info(\"The book was added\");\n        return book;\n    }\n\n    public Optional<Book> findBookByIsbn(Long isbn) {\n        return Optional.ofNullable(books.get(isbn));\n    }\n\n    public List<Book> searchByAuthor(final String author) {\n        LOGGER.info(\"The book list via author has been returned\");\n        return this.books\n                .values()\n                .stream()\n                .filter(book -> book.getAuthor().equalsIgnoreCase(author))\n                .toList();\n    }\n\n    public synchronized boolean borrowBook(Long isbn) {\n        Book book = books.get(isbn);\n        return book != null && book.decreaseCopies();\n    }\n\n    public synchronized void returnBook(Long isbn) {\n        Book book = books.get(isbn);\n        if (book != null) {\n            book.increaseCopies();\n        }\n    }\n\n    public List<Book> getAllBooksSortedByTitle() {\n        LOGGER.warning(\"The book was found by title and sorted\");\n        return this.books.values().stream().sorted(Comparator.comparing(Book::getTitle)).toList();\n    }\n}  public class LibraryService implements ILibrary {\n\n    private static final LibraryDao libraryDao = new LibraryDao();\n\n    @Override\n    public Book addBook(Book book) {\n        return libraryDao.addBook(book);\n    }\n\n    @Override\n    public Optional<Book> findBookByIsbn(Long isbn) {\n        return libraryDao.findBookByIsbn(isbn);\n    }\n\n    @Override\n    public List<Book> searchByAuthor(String author) {\n        return libraryDao.searchByAuthor(author);\n    }\n\n    @Override\n    public boolean borrowBook(Long isbn) {\n        return libraryDao.borrowBook(isbn);\n    }\n\n    @Override\n    public void returnBook(Long isbn) {\n        libraryDao.returnBook(isbn);\n    }\n\n    @Override\n    public List<Book> getAllBooksSortedByTitle() {\n        return libraryDao.getAllBooksSortedByTitle();\n    }\n}  public class LibraryServiceTest {\n\n    @Test\n    public void borrowBookShouldDecreaseCopies() {\n        final LibraryService library = new LibraryService();\n        final Book book = new Book(UUID.randomUUID(), \"Clean Code\", \"Robert Martin\", 12345L, 3);\n        library.addBook(book);\n        final boolean borrowed = library.borrowBook(book.getIsbn());\n\n        assertTrue(borrowed);\n        assertEquals(2, library.findBookByIsbn(12345L).get().getAvailableCopies());\n    }\n\n    @Test\n    public void borrowBookShouldFailWhenNoCopies() {\n        final LibraryService library = new LibraryService();\n        Book book = new Book(UUID.randomUUID(), \"Test\", \"Author\", 123L, 0);\n        library.addBook(book);\n\n        boolean borrowed = library.borrowBook(123L);\n\n        assertFalse(borrowed);\n    }\n\n    @Test\n    public void rerunBookShouldIncreaseCopies() {\n        final LibraryService library = new LibraryService();\n        final Book book = new Book(UUID.randomUUID(), \"Effective Java\", \"Joshua Bloch\", 54321L, 1);\n        library.addBook(book);\n        library.returnBook(book.getIsbn());\n\n        assertEquals(2, library.findBookByIsbn(54321L).get().getAvailableCopies());\n    }\n}"
    }
  },
  {
    "title": "A continuous subsequence",
    "body": "Given an array of integers, find a non-empty subarray (a continuous subsequence) with a given sum target, or return -1 if not available.",
    "example": "findTarget([9, -6, 5, 1, 4, -2], 10) -> (2, 4), (-1, -1) if not available",
    "level": "medium",
    "solution": {
      "content": ""
    }
  },
  {
    "title": "Top K Frequent Elements",
    "body": "Given an integer array and an integer k, return the k most frequent elements. Optimize for time complexity better than O(n log n)",
    "example": "Input: nums = [1,1,1,2,2,3], k = 2, Output: [1,2]",
    "level": "hard",
    "solution": {
      "content": "public int[] topFrequentElements(final int[] inputArray, final int k) {\n        Objects.requireNonNull(inputArray, \"Input array cannot be null\");\n\n        if (inputArray.length == 0 || k <= 0) {\n            throw new IllegalArgumentException(\"Array must not be empty and k must be > 0\");\n        }\n\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : inputArray) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        PriorityQueue<Map.Entry<Integer, Integer>> maxHeap =\n                new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n\n        maxHeap.addAll(frequencyMap.entrySet());\n\n        int[] result = new int[k];\n        for (int i = 0; i < k; i++) {\n            result[i] = Objects.requireNonNull(maxHeap.poll()).getKey();\n        }\n\n        return result;\n    }"
    }
  },
  {
    "title": "Best Time to Buy and Sell Stock IV",
    "body": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\n\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "example": "Input: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2; Input: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.",
    "level": "hard"
  },
  {
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "body": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.\n\nImplement the RandomizedCollection class:\n\nRandomizedCollection() Initializes the empty RandomizedCollection object.\nbool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.\nbool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.\nint getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of the same values the multiset contains.\nYou must implement the functions of the class such that each function works on average O(1) time complexity.\n\nNote: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.\n\n",
    "example": "Input\n[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"]\n[[], [1], [1], [2], [], [1], []]\nOutput\n[null, true, false, true, 2, true, 1]",
    "level": "hard"
  },
  {
    "title": "Longest Increasing Path in a Matrix",
    "body": "Given an m x n integers matrix, return the length of the longest increasing path in matrix., From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\n",
    "example": "Input: matrix = [[9,9,4],[6,6,8],[2,1,1]], Output: 4, Explanation: The longest increasing path is [1, 2, 6, 9]; Input: matrix = [[3,4,5],[3,2,6],[2,2,1]], Output: 4, Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.; Input: matrix = [[1]], Output: 1",
    "level": "hard"
  },
  {
    "title": "Concatenated Words",
    "body": "Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.",
    "example": "Input: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"], Output: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"], Explanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n\"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\"; Input: words = [\"cat\",\"dog\",\"catdog\"], Output: [\"catdog\"]",
    "level": "hard"
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "body": "Given a string, find the length of the longest substring without repeating characters.",
    "example": "Input: \"abcabcbb\", Output: 3 (substring is \"abc\")",
    "level": "hard"
  },
  {
    "title": "Word Ladder (Transform Words with Dictionary)",
    "body": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
    "example": "Example 1:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long \n Example 2:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.",
    "level": "hard"
  }
]